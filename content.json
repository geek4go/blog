[{"title":"「8」Redux 进阶 - react 全家桶学习笔记（二）","date":"2017-01-01T16:48:29.000Z","path":"2017/01/02/8.advanced-redux/","text":"零、前言在上一篇中介绍了 Redux 的各项基础 api。接着一步一步地介绍如何与 React 进行结合，并从引入过程中遇到的各个痛点引出 react-redux 的作用和原理。 不过目前为止还都是纸上谈兵，在日常的开发中最常见异步操作（如通过 ajax、jsonp 等方法 获取数据），在学习完上一篇后你可能依然没有头绪。因此本文将深入浅出地对于 redux 的进阶用法进行介绍。 一、中间件（MiddleWare） It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. ———— by Dan Abramov 这是 redux 作者对 middleware 的描述，middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。 说得好像很吊…不过有啥用咧…？ 1.1. 日志应用场景[2]因为改变 store 的唯一方法就是 dispatch 一个 action，所以有时需要将每次 dispatch 操作都打印出来作为操作日志，这样一来就可以很容易地看出是哪一次 dispatch 导致了异常。 1.1. 第一次尝试：强行怼…12345const action = addTodo('Use Redux');console.log('dispatching', action);store.dispatch(action);console.log('next state', store.getState()); 显然这种在每一个 dispatch 操作的前后都手动加代码的方法，简直让人不忍直视… 1.2. 第二次尝试：封装 dispatch聪明的你一定马上想到了，不如将上述代码封装成一个函数，然后直接调用该方法。 1234567function dispatchAndLog(store, action) &#123; console.log('dispatching', action); store.dispatch(action); console.log('next state', store.getState());&#125;dispatchAndLog(store, addTodo('Use Redux')); 矮油，看起来不错哟。 不过每次使用都需要导入这个额外的方法，一旦不想使用又要全部替换回去，好麻烦啊… 1.3. 第三次尝试：猴子补丁（Monkey Patch）在此暂不探究为啥叫猴子补丁而不是什么其他补丁。 简单来说猴子补丁指的就是：以替换原函数的方式为其添加新特性或修复 bug。 123456789let next = store.dispatch; // 暂存原方法store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); // 应用原方法 console.log('next state', store.getState()); return result;&#125;; 这样一来我们就“偷梁换柱”般的为原 dispatch 添加了输出日志的功能。 1.4. 第四次尝试：隐藏猴子补丁目前看起来很不错，然鹅假设我们又要添加别的一个中间件，那么代码中将会有重复的 let next = store.dispatch; 代码。 对于这个问题我们可以通过参数传递，返回新的 dispatch 来解决。 1234567891011121314function logger(store) &#123; const next = store.dispatch; return function dispatchAndLog(action) &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result; &#125;&#125;store.dispatch = logger(store);store.dispatch = anotherMiddleWare(store); 注意到最后应用中间件的代码其实就是一个链式的过程，所以还可以更进一步优化绑定中间件的过程。 1234567891011121314151617function applyMiddlewareByMonkeypatching(store, middlewares) &#123; // 因为传入的是原对象引用的值，slice 方法会生成一份拷贝， // 所以之后调用的 reverse 方法不会改变原数组 middlewares = middlewares.slice(); // 我们希望按照数组原本的先后顺序触发各个中间件， // 所以最后的中间件应当最接近原本的 dispatch， // 就像洋葱一样一层一层地包裹原 dispatch middlewares.reverse(); // 在每一个 middleware 中变换 store.dispatch 方法。 middlewares.forEach((middleware) =&gt; store.dispatch = middleware(store); );&#125;// 先触发 logger，再触发 anotherMiddleWare 中间件（类似于 koa 的中间件机制）applyMiddlewareByMonkeypatching(store, [ logger, anotherMiddleWare ]); so far so good~! 现在不仅隐藏了显式地缓存原 dispatch 的代码，而且调用起来也很优雅~，然鹅这样就够了么？ 1.5. 第五次尝试：移除猴子补丁注意到，以上写法仍然是通过 store.dispatch = middleware(store); 改写原方法，并在中间件内部通过 const next = store.dispatch; 读取当前最新的方法。 本质上其实还是 monkey patch，只不过将其封装在了内部，不过若是将 dispatch 方法通过参数传递进来，这样在 applyMiddleware 函数中就可以暂存 store.dispatch（而不是一次又一次的改写），岂不美哉？ 123456789101112131415161718// 通过参数传递function logger(store, next) &#123; return function dispatchAndLog(action) &#123; // ... &#125;&#125;function applyMiddleware(store, middlewares) &#123; // ... // 暂存原方法 let dispatch = store.dispatch; // middleware 中通过闭包获取 dispatch，并且更新 dispatch middlewares.forEach((middleware) =&gt; dispatch = middleware(store, dispatch); );&#125; 接着应用函数式编程的 curry 化（一种使用匿名单参数函数来实现多参数函数的方法。），还可以再进一步优化。（其实是为了使用 compose 将中间件函数先组合再绑定） 1234567891011121314151617181920212223242526272829303132function logger(store) &#123; return function(next) &#123; return function(action) &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result; &#125; &#125;&#125;// -- 使用 es6 的箭头函数可以让代码更加优雅更函数式... --const logger = (store) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', store.getState()); return result;&#125;;function applyMiddleware(store, middlewares) &#123; // ... let dispatch = store.dispatch; middlewares.forEach((middleware) =&gt; dispatch = middleware(store)(dispatch); // 注意调用了两次 ); // ...&#125; 以上方法离 Redux 中最终的 applyMiddleware 实现已经很接近了， 1.6. 第六次尝试：组合（compose，函数式方法）在 Redux 的最终实现中，并没有采用我们之前的 slice + reverse 的方法来倒着绑定中间件。而是采用了 map + compose + reduce 的方法。 先来说这个 compose 函数，在数学中以下等式十分的自然。 f(g(x)) = (f o g)(x)f(g(h(x))) = (f o g o h)(x) 用代码来表示这一过程就是这样。 123456// 传入参数为函数数组function compose(...funcs) &#123; // 返回一个闭包， // 将右边的函数作为内层函数执行，并将执行结果作为外层函数再次执行 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));&#125; 不了解 reduce 函数的人可能对于以上代码会感到有些费解，举个栗子来说，有函数数组 [f, g, h]传入 compose 函数执行。 首次 reduce 执行的结果是返回一个函数 (...args) =&gt; f(g(...args)) 接着该函数作为下一次 reduce 函数执行时的参数 a，而参数 b 是 h 再次执行时 h(...args) 作为参数传入 a，即最后返回的还是一个函数 (...args) =&gt; f(g(h(...args))) 因此最终版 applyMiddleware 实现中并非依次执行绑定，而是采用函数式的思维，将作用于 dispatch 的函数首先进行组合，再进行绑定。（所以要中间件要 curry 化） 12345678910111213141516171819202122232425262728293031// 传入中间件函数的数组function applyMiddleware(...middlewares) &#123; // 返回一个函数的原因在 createStore 部分再进行介绍 return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] // 保存绑定了 middlewareAPI 后的函数数组 const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 使用 compose 函数按照从右向左的顺序绑定（执行顺序是从左往右） dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125;// store -&gt; &#123; getState &#125; 从传递整个 store 改为传递部分 apiconst logger = (&#123; getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); const result = next(action); // 应用原方法 console.log('next state', getState()); return result;&#125;; 综上如下图所示整个中间件的执行顺序是类似于洋葱一样首先按照从外到内的顺序执行 dispatch 之前的中间件代码，在 dispatch（洋葱的心）执行后又反过来，按照从内到左外的顺序执行 dispatch 之后的中间件代码。 桥都麻袋！ 你真的都理解了么？ 在之前的实现中直接传递 store，为啥在最终实现中传递的是 middlewareAPI？ middlewareAPI 里的 dispatch 是为啥一个匿名函数而不直接传递 dispatch？ 如下列代码所示，如果在中间件里不用 next 而是调用 store.dispatch 会怎样呢？ 12345678const logger = (store) =&gt; (next) =&gt; (action) =&gt; &#123; console.log('dispatching', action); // 调用原始 dispatch，而不是上一个中间件传进来的 const result = store.dispatch(action); // &lt;- 这里 console.log('next state', store.getState()); return result;&#125;; 1.7. middleware 中调用 store.dispatch[6] 正常情况下，如图左，当我们 dispatch 一个 action 时，middleware 通过 next(action) 一层一层处理和传递 action 直到 redux 原生的 dispatch。如果某个 middleware 使用 store.dispatch(action) 来分发 action，就发生了右图的情况，相当于从外层重新来一遍，假如这个 middleware 一直简单粗暴地调用 store.dispatch(action)，就会形成无限循环了。（其实就相当于猴子补丁没补上，不停地调用原来的函数） 因此最终版里不是直接传递 store，而是传递 getState 和 dispatch，传递 getState 的原因是可以通过 getState 获取当前状态。并且还将 dispatch 用一个匿名函数包裹 dispatch: (action) =&gt; dispatch(action)，这样不但可以防止 dispatch 被中间件修改，而且只要 dispatch 更新了，middlewareAPI 中的 dispatch 也会随之发生变化。 1.8. createStore 进阶在上一篇中我们使用 createStore 方法只用到了它前两个参数，即 reducer 和 preloadedState，然鹅其实它还拥有第三个参数 enhancer。 enhancer 参数可以实现中间件、时间旅行、持久化等功能，Redux 仅提供了 applyMiddleware 用于应用中间件（就是 1.6. 中的那个）。 在日常使用中，要应用中间件可以这么写。 1234567891011121314151617181920212223242526import &#123; createStore, combineReducers, applyMiddleware,&#125; from 'redux';// 组合 reducerconst rootReducer = combineReducers(&#123; todos: todosReducer, filter: filterReducer,&#125;);// 中间件数组const middlewares = [logger, anotherMiddleWare];const store = createStore( rootReducer, initialState, applyMiddleware(...middlewares),);// 如果不需要 initialState 的话也可以忽略const store = createStore( rootReducer, applyMiddleware(...middlewares),); 在上文 applyMiddleware 的实现中留了个悬念，就是为什么返回的是一个函数，因为 enhancer 被定义为一个高阶函数，接收 createStore 函数作为参数。 12345678910111213141516171819202122232425262728293031/** * 创建一个 redux store 用于保存状态树， * 唯一改变 store 中数据的方法就是对其调用 dispatch * * 在你的应用中应该只有一个 store，想要针对不同的部分状态响应 action， * 你应该使用 combineReducers 将多个 reducer 合并。 * * @param &#123;函数&#125; reducer 不多解释了 * @param &#123;对象&#125; preloadedState 主要用于前后端同构时的数据同步 * @param &#123;函数&#125; enhancer 很牛逼，可以实现中间件、时间旅行，持久化等 * ※ Redux 仅提供 applyMiddleware 这个 Store Enhancer ※ * @return &#123;Store&#125; */export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; // enhancer 是一个高阶函数，接收 createStore 函数作为参数 return enhancer(createStore)(reducer, preloadedState) &#125; // ... // 后续内容推荐看看参考资料部分的【Redux 莞式教程】&#125; 总的来说 Redux 有五个 API，分别是： createStore(reducer, [initialState], enhancer) combineReducers(reducers) applyMiddleware(…middlewares) bindActionCreators(actionCreators, dispatch) compose(…functions) createStore 生成的 store 有四个 API，分别是： getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) 以上 API 我们还没介绍的应该就剩 bindActionCreators 了。这个 API 其实就是个语法糖起了方便地给 action creator 绑定 dispatch 的作用。 12345678910111213141516171819202122232425// 一般写法function mapDispatchToProps(dispatch) &#123; return &#123; onPlusClick: () =&gt; dispatch(increment()), onMinusClick: () =&gt; dispatch(decrement()), &#125;;&#125;// 使用 bindActionCreatorsimport &#123; bindActionCreators &#125; from 'redux';function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; onPlusClick: increment, onMinusClick: decrement, // 还可以绑定更多函数... &#125;, dispatch);&#125;// 甚至如果定义的函数输入都相同的话还能更加简洁export default connect( mapStateToProps, // 直接传一个对象，connect 自动帮你绑定 dispatch &#123; onPlusClick: increment, onMinusClick: decrement &#125;,)(App); 二、异步操作下面让我们告别干净的同步世界，进入“肮脏”的异步世界~。 在函数式编程中，异步操作、修改全局变量等与函数外部环境发生的交互叫做副作用（Side Effect）通常认为这些操作是邪恶（evil）肮脏（dirty）的，并且也是导致 bug 的源头。因为与之相对的是纯函数（pure function），即对于同样的输入总是返回同样的输出的函数，使用这样的函数很容易做组合、测试等操作，很容易验证和保证其正确性。（它们就像数学公式一般准确） 2.1. 通知应用场景[3]现在有这么一个显示通知的应用场景，在通知显示后5秒钟隐藏该通知。 首先当然是编写 action 显示：SHOW_NOTIFICATION 隐藏：HIDE_NOTIFICATION 2.1.1. 最直观的写法最直观的写法就是首先显示通知，然后使用 setTimeout 在5秒后隐藏通知。 1234store.dispatch(&#123; type: 'SHOW_NOTIFICATION', text: 'You logged in.' &#125;);setTimeout(() =&gt; &#123; store.dispatch(&#123; type: 'HIDE_NOTIFICATION' &#125;);&#125;, 5000); 然鹅，一般在组件中尤其是展示组件中没法也没必要获取 store，因此一般将其包装成 action creator。 123456789101112131415// actions.jsexport function showNotification(text) &#123; return &#123; type: 'SHOW_NOTIFICATION', text &#125;;&#125;export function hideNotification() &#123; return &#123; type: 'HIDE_NOTIFICATION' &#125;;&#125;// component.jsimport &#123; showNotification, hideNotification &#125; from '../actions';this.props.dispatch(showNotification('You just logged in.'));setTimeout(() =&gt; &#123; this.props.dispatch(hideNotification());&#125;, 5000); 或者更进一步地先使用 connect 方法包装。 1234this.props.showNotification('You just logged in.');setTimeout(() =&gt; &#123; this.props.hideNotification();&#125;, 5000); 到目前为止，我们没有用任何 middleware 或者别的概念。 2.1.2. 异步 action creator上一种直观写法有一些问题 每当我们需要显示一个通知就需要手动先显示，然后再手动地让其消失。其实我们更希望通知到时间后自动地消失。 通知目前没有自己的 id，所以有些场景下存在竞争条件（race condition），即假如在第一个通知结束前触发第二个通知，当第一个通知结束时，第二个通知也会被提前关闭。 所以为了解决以上问题，我们可以为通知加上 id，并将显示和消失的代码包起来。 1234567891011121314151617181920212223242526// actions.jsconst showNotification = (text, id) =&gt; (&#123; type: 'SHOW_NOTIFICATION', id, text,&#125;);const hideNotification = (id) =&gt; (&#123; type: 'HIDE_NOTIFICATION', id,&#125;);let nextNotificationId = 0;export function showNotificationWithTimeout(dispatch, text) &#123; const id = nextNotificationId++; dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; dispatch(hideNotification(id)); &#125;, 5000);&#125;// component.jsshowNotificationWithTimeout(this.props.dispatch, 'You just logged in.');// otherComponent.jsshowNotificationWithTimeout(this.props.dispatch, 'You just logged out.'); 为啥 showNotificationWithTimeout 函数要接收 dispatch 作为第一个参数呢？虽然通常一个组件都拥有触发 dispatch 的权限，但是现在我们想让一个外部函数（showNotificationWithTimeout）来触发 dispatch，所以需要将 dispatch 作为参数传入。 2.1.3. 单例 store可能你会说如果有一个从其他模块中导出的单例 store，那么是不是同样也可以不传递 dispatch 以上代码也可以这样写。 1234567891011121314151617181920212223// store.jsexport default createStore(reducer);// actions.jsimport store from './store';// ...let nextNotificationId = 0;export function showNotificationWithTimeout(text) &#123; const id = nextNotificationId++; store.dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; store.dispatch(hideNotification(id)); &#125;, 5000);&#125;// component.jsshowNotificationWithTimeout('You just logged in.');// otherComponent.jsshowNotificationWithTimeout('You just logged out.'); 这样看起来似乎更简单一些，不过墙裂不推荐这样的写法。主要的原因是这样的写法强制让 store 成为一个单例。这样一来要实现服务器端渲染（Server Rendering）将十分困难。因为在服务端，为了让不同的用户得到不同的预先获取的数据，你需要让每一个请求都有自己的 store。 并且单例 store 也将让测试变得困难。当测试 action creator 时你将无法自己模拟一个 store，因为它们都引用了从外部导入的那个特定的 store，所以你甚至无法从外部重置状态。 2.1.4. redux-thunk 中间件首先声明 redux-thunk 这种方案对于小型的应用来说足够日常使用，然鹅对于大型应用来说，你可能会发现一些不方便的地方。（例如对于 action 需要组合、取消、竞争等复杂操作的场景） 首先来明确什么是 thunk… A thunk is a function that wraps an expression to delay its evaluation. 简单来说 thunk 就是封装了表达式的函数，目的是延迟执行该表达式。不过有啥应用场景呢？ 目前为止，在上文中的 2.1.2. 异步 action creator 部分，最后得出的方案有以下明显的缺点 我们必须将 dispatch 作为参数传入。 这样一来任何使用了异步操作的组件都必须用 props 传递 dispatch（不管有多深…）。我们也没法像之前各种同步操作一样使用 connect 函数来绑定回调函数，因为 showNotificationWithTimeout 函数返回的不是一个 action。 此外，在日常使用时，我们还需要区分哪些函数是同步的 action creator，那些是异步的 action creator。（异步的需要传 dispatch…） 同步的情况: store.dispatch(actionCreator(payload)) 异步的情况: asyncActionCreator(store.dispatch, payload) 计将安出？ 其实问题的本质在于 Redux “有眼不识 function”，目前为止 dispatch 函数接收的参数只能是 action creator 返回的普通的 action。所以如果我们让 dispatch 对于 function 网开一面，走走后门潜规则一下不就行啦~ 实现方式很简单，想想第一节介绍的为 dispatch 添加日志功能的过程。 123456789101112131415// redux-thunk 源码function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; 以上就是 redux-thunk 的源码，就是这么简单，判断下如果传入的 action 是函数的话，就执行这个函数…（withExtraArgument 是为了添加额外的参数，详情见 redux-thunk 的 README.md） 这样一来如果我们 dispatch 了一个函数，redux-thunk 会传给它一个 dispatch 参数，我们就利用 thunk 解决了组件中不方便获取 dispatch 的问题。 并且由于 redux-thunk 拦截了函数，也可以防止 reducer 接收到函数而出现异常。 添加了 redux-thunk 中间件后代码可以这么写。 123456789101112131415161718192021// actions.js// ...let nextNotificationId = 0;export function showNotificationWithTimeout(text) &#123; // 返回一个函数 return function(dispatch) &#123; const id = nextNotificationId++; dispatch(showNotification(id, text)); setTimeout(() =&gt; &#123; dispatch(hideNotification(id)); &#125;, 5000); &#125;;&#125;// component.js 像同步函数一样的写法this.props.dispatch(showNotificationWithTimeout('You just logged in.'));// 或者 connect 后直接调用this.props.showNotificationWithTimeout('You just logged in.'); 2.2. 接口应用场景目前我们对于简单的延时异步操作的处理已经了然于胸了，现在让我们来考虑一下通过 ajax 或 jsonp 等接口来获取数据的异步场景。 很自然的，我们会发起一个请求，然后等待请求的响应（请求可能成功或是失败）。 即有基本的三种状态和与之对应的 action： 请求开始的 action：isFetching 为真，UI 显示加载界面{ type: &#39;FETCH_POSTS_REQUEST&#39; } 请求成功的 action：isFetching 为假，隐藏加载界面并显示接收到的数据{ type: &#39;FETCH_POSTS_SUCCESS&#39;, response: { ... } } 请求失败的 action：isFetching 为假，隐藏加载界面，可能保存失败信息并在 UI 中显示出来{ type: &#39;FETCH_POSTS_FAILURE&#39;, error: &#39;Oops&#39; } 按照这个思路，举一个简单的栗子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Constantsconst FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';const FETCH_POSTS_FAILURE = 'FETCH_POSTS_FAILURE';// Actionsconst requestPosts = (id) =&gt; (&#123; type: FETCH_POSTS_REQUEST, payload: id,&#125;);const receivePosts = (res) =&gt; (&#123; type: FETCH_POSTS_SUCCESS, payload: res,&#125;);const catchPosts = (err) =&gt; (&#123; type: FETCH_POSTS_FAILURE, payload: err,&#125;);const fetchPosts = (id) =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(id)); return api.getData(id) .then(res =&gt; dispatch(receivePosts(res))) .catch(error =&gt; dispatch(catchPosts(error)));&#125;;// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case FETCH_POSTS_REQUEST: return requestState; case FETCH_POSTS_SUCCESS: return successState; case FETCH_POSTS_FAILURE: return errorState; default: return oldState; &#125;&#125;; 尽管这已经是最简单的调用接口场景，我们甚至还没写一行业务逻辑代码，但讲道理的话代码还是比较繁琐的。 而且其实代码是有一定的“套路”的，比如其实整个代码都是针对请求、成功、失败三部分来处理的，这让我们自然联想到 Promise，同样也是分为 pending、fulfilled、rejected 三种状态。 那么这两者可以结合起来让模版代码精简一下么？ 2.2.1. redux-promise 中间件[8]首先开门见山地使用 redux-promise 中间件来改写之前的代码看看效果。 12345678910111213141516171819202122232425// Constantsconst FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';// Actionsconst fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS_REQUEST, payload: api.getData(id), // payload 为 Promise 对象&#125;);// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case FETCH_POSTS_REQUEST: // requestState 被“吃掉”了 // 而成功、失败的状态通过 status 来判断 if (action.status === 'success') &#123; return successState; &#125; else &#123; return errorState; &#125; default: return oldState; &#125;&#125;; 可以看出 redux-promise 中间件比较激进、比较原教旨。 不但将发起请求的初始状态被拦截了（原因见下文源码），而且使用 action.status 而不是 action.type 来区分两个 action 这一做法也值得商榷（个人倾向使用 action.type 来判断）。 1234567891011121314151617181920212223242526272829// redux-promise 源码import &#123; isFSA &#125; from 'flux-standard-action';function isPromise(val) &#123; return val &amp;&amp; typeof val.then === 'function';&#125;export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) // 直接调用 Promise.then（所以发不出请求开始的 action） ? action.payload.then( // 自动 dispatch result =&gt; dispatch(&#123; ...action, payload: result &#125;), // 自动 dispatch error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125; ) : next(action); &#125;;&#125; 以上是 redux-promise 的源码，十分简单。主要逻辑是判断如果是 Promise 就执行 then 方法。此外还根据是不是 FSA 决定调用的是 action 本身还是 action.payload 并且对于 FSA 会自动 dispatch 成功和失败的 FSA。 2.2.2. redux-promise-middleware 中间件尽管 redux-promise 中间件节省了大量代码，然鹅它的缺点除了拦截请求开始的 action，以及使用 action.status 来判断成功失败状态以外，还有就是由此引申出的一个无法实现的场景————乐观更新（Optimistic Update）。 乐观更新比较直观的栗子就是在微信、QQ等通讯软件中，发送的消息立即在对话窗口中展示，如果发送失败了，在消息旁边展示提示即可。由于在这种交互方式中“乐观”地相信操作会成功，因此称作乐观更新。 因为乐观更新发生在用户发起操作时，所以要实现它，意味着必须有表示用户初始动作的 action。 因此为了解决这些问题，相对于比较原教旨的 redux-promise 来说，更加温和派一点的 redux-promise-middleware 中间件应运而生。先看看代码怎么说。 12345678910111213141516171819202122232425262728// Constantsconst FETCH_POSTS = 'FETCH_POSTS'; // 前缀// Actionsconst fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS, // 传递的是前缀，中间件会自动生成中间状态 payload: &#123; promise: api.getData(id), data: id, &#125;,&#125;);// reducerconst reducer = (oldState, action) =&gt; &#123; switch (action.type) &#123; case `$&#123;FETCH_POSTS&#125;_PENDING`: return requestState; // 可通过 action.payload.data 获取 id case `$&#123;FETCH_POSTS&#125;_FULFILLED`: return successState; case `$&#123;FETCH_POSTS&#125;_REJECTED`: return errorState; default: return oldState; &#125;&#125;; 如果不需要乐观更新，fetchPosts 函数可以更加简洁。12345// 此时初始 actionGET_DATA_PENDING 仍然会触发，但是 payload 为空。const fetchPosts = (id) =&gt; (&#123; type: FETCH_POSTS, // 传递的是前缀 payload: api.getData(id), // 等价于 payload: &#123; promise: api.getData(id) &#125;,&#125;); 相对于 redux-promise 简单粗暴地直接过滤初始 action，从 reducer 可以看出，redux-promise-middleware 会首先自动触发一个 FETCH_POSTS_PENDING 的 action，以此保留乐观更新的能力。 并且，在状态的区分上，回归了通过 action.type 来判断状态的“正途”，其中 _PENDING、_FULFILLED、_REJECTED 后缀借用了 Promise 规范 (当然它们是可配置的) 。 后缀可以配置全局或局部生效，例如全局配置可以这么写。12345applyMiddleware( promiseMiddleware(&#123; promiseTypeSuffixes: ['LOADING', 'SUCCESS', 'ERROR'] &#125;)) 源码地址点我，类似 redux-promise 也是在中间件中拦截了 payload 中有 Promise 的 action，并主动 dispatch 三种状态的 action，注释也很详细在此就不赘述了。 注意：redux-promise、redux-promise-middleware 与 redux-thunk 之间并不是互相替代的关系，而更像一种补充优化。 2.3. redux-loop 中间件简单小结一下，Redux 的数据流如下所示： UI =&gt; action =&gt; action creator =&gt; reducer =&gt; store =&gt; react =&gt; v-dom =&gt; UI redux-thunk 的思路是保持 action 和 reducer 简单纯粹，然鹅副作用操作（在前端主要体现在异步操作上）的复杂度是不可避免的，因此它将其放在了 action creator 步骤，通过 thunk 函数手动控制每一次的 dispatch。 redux-promise 和 redux-promise-middleware 只是在其基础上做一些辅助性的增强，处理异步的逻辑本质上是相同的，即将维护复杂异步操作的责任推到了用户的身上。 这种实现方式固然很好理解，而且理论上可以应付所有异步场景，但是由此带来的问题就是模版代码太多，一旦流程复杂那么异步代码就会到处都是，很容易导致出现 bug。 因此有一些其他的中间件，例如 redux-loop 就将异步处理逻辑放在 reducer 中。（Redux 的思想借鉴了 Elm，注意并不是“饿了么”，而 Elm 就是将异步处理放在 update（reducer） 层中）。 Synchronous state transitions caused by returning a new state from the reducer in response to an action are just one of all possible effects an action can have on application state.这种通过响应一个 action，在 reducer 中返回一个新 state，从而引起同步状态转换的方式，只是在应用状态中一个 action 能拥有的所有可能影响的一种。（可能没翻好~欢迎勘误~） redux-loop 认为许多其他的处理异步的中间件，尤其是通过 action creator 方式实现的中间件，错误地让用户认为异步操作从根本上与同步操作并不相同。这样一来无形中鼓励了中间件以许多特殊的方式来处理异步状态。 与之相反，redux-loop 专注于让 reducer 变得足够强大以便处理同步和异步操作。在具体实现上 reducer 不仅能够根据特定的 action 决定当前的转换状态，而且还能决定接着发生的操作。 应用中所有行为都可以在一个地方（reducer）中被追踪，并且这些行为可以轻易地分割和组合。（redux 作者 Dan 开了个至今依然 open 的 issue：Reducer Composition with Effects in JavaScript，讨论关于对 reducer 进行分割组合的问题。） redux-loop 模仿 Elm 的模式，引入了 Effect 的概念，在 reducer 中对于异步等操作使用 Effect 来处理。如下官方示例所示： 123456789101112131415161718192021222324import &#123; Effects, loop &#125; from 'redux-loop';function fetchData(id) &#123; return fetch(`endpoint/$&#123;id&#125;`) .then((r) =&gt; r.json()) .then((data) =&gt; (&#123; type: 'FETCH_SUCCESS', payload: data &#125;)) .catch((error) =&gt; (&#123; type: 'FETCH_FAILURE', payload: error.message &#125;));&#125;function reducer(state, action) &#123; switch(action.type) &#123; case 'FETCH_START': return loop( // &lt;- 并没有直接返回 state，实际上了返回数组 [state, effect] &#123; ...state, loading: true &#125;, Effects.promise(fetchData, action.payload.id) ); case 'FETCH_SUCCESS': return &#123; ...state, loading: false, data: action.payload &#125;; case 'FETCH_FAILURE': return &#123; ...state, loading: false, errorMessage: action.payload &#125;; &#125;&#125; 虽然这个想法很 Elm 很函数式，不过由于修改了 reducer 的返回类型，这样一来会导致许多已有的 Api 和第三方库无法使用，甚至连 redux 库中的 combineReducers 方法都需要使用 redux-loop 提供的定制版本。因此这也是 redux-loop 最终无法转正的原因： “If a solution doesn’t work with vanilla combineReducers(), it won’t get into Redux core.” 三、复杂异步操作3.1. 更复杂的通知场景[9]让我们的思路重新回到通知的场景，之前的代码实现了： 展示一个通知并在数秒后消失 可以同时展示多个通知。 现在假设可亲可爱的产品又提出了新需求： 同时不展示多于3个的通知 如果已有3个通知正在展示，此时的新通知请求将排队延迟展示。 “这个实现不了…”（全文完） 这个当然可以实现，只不过如果只用之前的 redux-thunk 实现起来会很麻烦。例如可以在 store 中增加两个数组分别表示当前展示列表和等待队列，然后在 reducer 中手动控制各个状态时这俩数组的变化。 3.2. redux-saga 中间件首先来看看使用了 redux-saga 后代码会变成怎样~（代码来自生产环境的某 app） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function* toastSaga() &#123; const MaxToasts = 3; const ToastDisplayTime = 4000; let pendingToasts = []; // 等待队列 let activeToasts = []; // 展示列表 function* displayToast(toast) &#123; if ( activeToasts &gt;= MaxToasts ) &#123; throw new Error(\"can't display more than \" + MaxToasts + \" at the same time\"); &#125; activeToasts = [...activeToasts, toast]; // 新增通知到展示列表 yield put(events.toastDisplayed(toast)); // 展示通知 yield call(delay, ToastDisplayTime); // 通知的展示时间 yield put(events.toastHidden(toast)); // 隐藏通知 activeToasts = _.without(activeToasts,toast); // 从展示列表中删除 &#125; function* toastRequestsWatcher() &#123; while (true) &#123; const event = yield take(Names.TOAST_DISPLAY_REQUESTED); // 监听通知展示请求 const newToast = event.data.toastData; pendingToasts = [...pendingToasts, newToast]; // 将新通知放入等待队列 &#125; &#125; function* toastScheduler() &#123; while (true) &#123; if (activeToasts.length &lt; MaxToasts &amp;&amp; pendingToasts.length &gt; 0) &#123; const [firstToast,...remainingToasts] = pendingToasts; pendingToasts = remainingToasts; yield fork(displayToast, firstToast); // 取出队头的通知进行展示 // 增加一点延迟，这样一来两个并发的通知请求不会同时展示 yield call(delay, 300); &#125; else &#123; yield call(delay, 50); &#125; &#125; &#125; yield [ call(toastRequestsWatcher), call(toastScheduler) ]&#125;// reducerconst reducer = (state = &#123;toasts: []&#125;, event) =&gt; &#123; switch (event.name) &#123; case Names.TOAST_DISPLAYED: return &#123; ...state, toasts: [...state.toasts, event.data.toastData] &#125;; case Names.TOAST_HIDDEN: return &#123; ...state, toasts: _.without(state.toasts, event.data.toastData) &#125;; default: return state; &#125;&#125;; 先不要在意代码的细节，简单分析一下上述代码的逻辑： store 上只有一个 toasts 节点，且 reducer 十分干净 排队等具体的业务逻辑都放到了 toastSaga 函数中 displayToast 函数负责单个通知的展示和消失逻辑 toastRequestsWatcher 函数负责监听请求，将其加入等待队列 toastScheduler 函数负责将等待队列中的元素加入展示列表 基于这样逻辑分离的写法，还可以继续满足更加复杂的需求： 如果在等待队列中有太多通知，动态减少通知的展示时间 根据窗口大小的变化，改变最多展示的通知数量 … redux-saga V.S. redux-thunk[11]redux-saga 的优点： 易于测试，因为 redux-saga 中所有操作都 yield 简单对象，所以测试只要判断返回的对象是否正确即可，而测试 thunk 通常需要你在测试中引入一个 mockStore redux-saga 提供了一些方便的辅助方法。（takeLatest、cancel、race 等） 在 saga 函数中处理业务逻辑和异步操作，这样一来通常代码更加清晰，更容易增加和更改功能 使用 ES6 的 generator，以同步的方式写异步代码 redux-saga 的缺点： generator 的语法（”又是 * 又是 yield 的，很难理解诶~”） 学习曲线陡峭，有许多概念需要学习（”fork、join 这不是进程的概念么？这些 yield 是以什么顺序执行的？”） API 的稳定性，例如新增了 channel 特性，并且社区也不是很大。 通知场景各种中间件写法的完整代码可以看这里 3.3. 理解 Saga Pattern[14]3.3.1. Saga 是什么Sagas 的概念来源于这篇论文，该论文从数据库的角度谈了 Saga Pattern。 Saga 就是能够满足特定条件的长事务（Long Lived Transaction） 暂且不提这个特定条件是什么，首先一般学过数据库的都知道事务（Transaction）是啥~ 如果不知道的话可以用转账来理解，A 转给 B 100 块钱的操作需要保证完成 A 先减 100 块钱然后 B 加 100 块钱这两个操作，这样才能保证转账前后 A 和 B 的存款总额不变。如果在给 B 加 100 块钱的过程中发生了异常，那么就要返回转账前的状态，即给 A 再加上之前减的 100 块钱(不然钱就不翼而飞了)，这样的一次转账（要么转成功，要么失败返回转账前的状态）就是一个事务。 3.3.2. 长事务的问题 长事务顾名思义就是一个长时间的事务。 一般来说是通过给正在进行事务操作的对象加锁，来保证事务并发时不会出错。 例如 A 和 B 都给 C 转 100 块钱。 如果不加锁，极端情况下 A 先转给 C 100 块，而 B 读取到了 C 转账前的数值，这时 B 的转账会覆盖 A 的转账，C 只加了 100 块钱，另 100 块不翼而飞了。 如果加了锁，这时 B 的转账会等待 A 的转账完成后再进行。所以 C 能正确地收到 200 块钱。 以押尾光太郎的指弹演奏会售票举例，在一个售票的时间段后，最终举办方需要确定售票数量，这就是一个长事务。 然鹅，对于长事务来说总不能一直锁住对应数据吧？ 为了解决这个问题，假设一个长事务：T， 可以被拆分成许多相互独立的子事务（subtransaction）：t_1 ~ t_n。 以上述押尾桑的表演为例，每个 t 就是一笔售票记录。 假如每次购票都一次成功，且没有退票的话，整个流程就如下图一般被正常地执行。 那假如有某次购票失败了怎么办？ 3.3.3. Saga 的特殊条件 A LLT is a saga if it can be written as a sequence of transactions that can be interleaved with other transactions.Saga 就是能够被写成事务的序列，并且能够在执行过程中被其他事务插入执行的长事务。 Saga 通过引入补偿事务（Compensating Transaction）的概念，解决事务失败的问题。 即任何一个 saga 中的子事务 t_i，都有一个补偿事务 c_i 负责将其撤销（undo）。 注意是撤销该子事务，而不是回到子事务发生前的时间点。 根据以上逻辑，可以推出很简单的公式： Saga 如果全部执行成功那么子事务序列看起来像这样：t_1, t_2, t_3, ..., t_n Saga 如果执行全部失败那么子事务序列看起来像这样：t_1, t_2, t_3, ..., t_n, c_n, ..., c_1 注意到图中的 c_4 其实并没有必要，不过因为每次撤销执行都应该是幂等（Idempotent）的，所以也不会出错。 篇幅有限在此就不继续深入介绍… 推荐看看从分布式系统方面讲 Saga Pattern 的视频：GOTO 2015 • Applying the Saga Pattern • Caitie McCaffrey MSDN 的文章：A Saga on Sagas 3.4. 响应式编程（Reactive Programming）[15]redux-saga 中间件基于 Sagas 的理论，通过监听 action，生成对应的各种子 saga（子事务）解决了复杂异步问题。 而接下来要介绍的 redux-observable 中间件背后的理论是响应式编程（Reactive Programming）。 In computing, reactive programming is a programming paradigm oriented around data flows and the propagation of change. 简单来说，响应式编程是针对异步数据流的编程并且认为：万物皆流（Everything is Stream）。 流（Stream）就是随着时间的流逝而发生的一系列事件。 例如点击事件的示意图就是这样。 用字符表示【上上下下左右左右BABA】可以像这样。（注意顺序是从左往右） 123456--上----上-下---下----左---右-B--A-B--A---X-|-&gt;上, 下, 左, 右, B, A 是数据流发射的值X 是数据流发射的错误| 是完成信号---&gt; 是时间线 那么我们要根据一个点击流来计算点击次数的话可以这样。（一般响应式编程库都会提供许多辅助方法如 map、filter、scan 等） 12345 clickStream: ---c----c--c----c------c--&gt; map(c becomes 1) ---1----1--1----1------1--&gt; scan(+)counterStream: ---1----2--3----4------5--&gt; 如上所示，原始的 clickStream 经过 map 后产生了一个新的流（注意原始流不变），再对该流进行 scan(+) 的操作就生成了最终的 counterStream。 再来个栗子~，假设我们需要从点击流中得到关于双击的流（250ms 以内），并且对于大于两次的点击也认为是双击。先想一想应该怎么用传统的命令式、状态式的方式来写，然后再想想用流的思考方式又会是怎么样的~。 这里我们用了以下辅助方法： 节流：throttle(250ms)，将原始流在 250ms 内的所有数据当作一次事件发射 缓冲（不造翻译成啥比较好）：buffer，将 250ms 内收集的数据放入一个数据包裹中，然后发射这些包裹 映射：map，这个不解释 过滤：filter，这个也不解释 更多内容请继续学习 RxJS。 3.5. redux-observable 中间件[16]redux-observable 就是一个使用 RxJS 监听每个 action 并将其变成可观测流（observable stream）的中间件。 其中最核心的概念叫做 epic，就是一个监听流上 action 的函数，这个函数在接收 action 并进行一些操作后可以再返回新的 action。 At the highest level, epics are “actions in, actions out” redux-observable 通过在后台执行 .subscribe(store.dispatch) 实现监听。 Epic 像 Saga 一样也是 Long Lived，即在应用初始化时启动，持续运行到应用关闭。虽然 redux-observable 是一个中间件，但是类似于 redux-saga，可以想象它就像新开的进/线程，监听着 action。 在这个运行流程中，epic 不像 thunk 一样拦截 action，或阻止、改变任何原本 redux 的生命周期的其他东西。这意味着每个 dispatch 的 action 总会经过 reducer 处理，实际上在 epic 监听到 action 前，action 已经被 reducer 处理过了。 所以 epic 的功能就是监听所有的 action，过滤出需要被监听的部分，对其执行一些带副作用的异步操作，然后根据你的需要可以再发射一些新的 action。 举个自动保存的栗子，界面上有一个输入框，每次用户输入了数据后，去抖动后进行自动保存，并在向服务器发送请求的过程中显示正在保存的 UI，最后显示成功或失败的 UI。 使用 redux-observable 中间件编写代码，可以仅用十几行关键代码就实现上述功能。 123456789101112131415161718192021222324252627282930import &#123; Observable &#125; from 'rxjs/Observable';import 'rxjs/add/observable/dom/ajax';import 'rxjs/add/observable/of';import 'rxjs/add/operator/catch';import 'rxjs/add/operator/debounceTime';import 'rxjs/add/operator/map';import 'rxjs/add/operator/mergeMap';import 'rxjs/add/operator/startWith';import &#123; isSaving, savingSuccess, savingError,&#125; from '../actions/autosave-actions.js';const saveField = (action$) =&gt; ( // 一般在变量后面加 $ 表示是个 stream action$ .ofType('SAVE_FIELD') // 使用 ofType 监听 'SAVE_FIELD' action .debounceTime(500) // 防抖动 .mergeMap((&#123; payload &#125;) =&gt; ( // 即 map + mergeAll 因为异步导致 map 后有多个流需要 merge Observable.ajax(&#123; // 发起请求 method: 'PATCH', url: payload.url, body: JSON.stringify(payload), &#125;) .map(res =&gt; savingSuccess(res)) // 发出成功的 action .catch(err =&gt; Observable.of(savingError(err))) // 捕捉错误并发出 action .startWith(isSaving()); // 发出请求开始的 action )););export default saveField; 篇幅有限在此就不继续深入介绍… 关于 redux-observable 的前世今生推荐看看 Netfix 工程师的这个视频：Netflix JavaScript Talks - RxJS + Redux + React = Amazing! 如果觉得看视频听英语麻烦的话知乎有人翻译了… RxJS + Redux + React = Amazing!（译一） RxJS + Redux + React = Amazing!（译二） 四、总结本文从为 Redux 应用添加日志功能（记录每一次的 dispatch）入手，引出 redux 的中间件（middleware）的概念和实现方法。 接着从最简单的 setTimeout 的异步操作开始，通过对比各种实现方法引出 redux 最基础的异步中间件 redux-thunk。 针对 redux-thunk 使用时模版代码过多的问题，有介绍了用于优化的 redux-promise 和 redux-promise-middleware 两款中间件。 由于本质上以上中间件都是基于 thunk 的机制来解决异步问题，所以不可避免地将维护异步状态的责任推给了开发者，并且也因为难以测试的原因。在复杂的异步场景下使用起来难免力不从心，容易出现 bug。 所以还简单介绍了一下将处理副作用的步骤放到 reducer 中并通过 Effect 进行解决的 redux-loop 中间件。然鹅因为其无法使用官方 combineReducers 的原因而无法被纳入 redux 核心代码中。 此外社区根据 Saga 的概念，利用 ES6 的 generator 实现了 redux-saga 中间件。虽然通过 saga 函数将业务代码分离，并且可以用同步的方式流程清晰地编写异步代码，但是较多的新概念和 generator 的语法可能让部分开发者望而却步。 同样是基于观察者模式，通过监听 action 来处理异步操作的 redux-observable 中间件，背后的思想是响应式编程（Reactive Programming）。类似于 saga，该中间件提出了 epic 的概念来处理副作用。即监听 action 流，一旦监听到目标 action，就处理相关副作用，并且还可以在处理后再发射新的 action，继续进行处理。尽管在处理异步流程时同样十分方便，但对于开发者的要求同样很高，需要开发者学习关于函数式的相关理论。 五、参考资料 Redux 英文原版文档 Redux 中文文档 Dan Abramov - how to dispatch a redux action with a timeout 阮一峰 - Redux 入门教程（二）：中间件与异步操作 Redux 莞式教程 redux middleware 详解 Thunk 函数的含义和用法 Redux异步方案选型 Sebastien Lorber - how to dispatch a redux action with a timeout Sagas 论文 Pros/cons of using redux-saga with ES6 generators vs redux-thunk with ES7 async/await Redux-saga 英文文档 Redux-saga 中文文档 Saga Pattern 在前端的應用 The introduction to Reactive Programming you’ve been missing Epic Middleware in Redux 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://buptsteve.github.io/blog/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://buptsteve.github.io/blog/tags/React/"}]},{"title":"「7」Redux 基础 - react 全家桶学习笔记（一）","date":"2016-10-25T15:00:35.000Z","path":"2016/10/25/7.redux-basis/","text":"零、环境搭建参考资料 英文原版文档 中文文档 墙裂推荐作者出的教学视频 基础篇 墙裂推荐作者出的教学视频 高级篇 首先要明确一点，虽然 redux 是由 flux 演变而来，但我们完全可以并且也应该抛开 react 进行学习，这样可以避免一开始就陷入各种细节之中。 所以推荐使用 jsbin 进行调试学习，或者使用 react-create-app 作为项目脚手架。 一、Redux 是什么？ Redux is a predictable state container for JavaScript apps.Redux 是一个 JavaScript 状态容器，提供可预测化的状态管理。 先不要在意那些细节 总的来说，redux 使用 store 保存并管理页面中的各种状态（state） 当需要改变 state 时，使用 dispatch 调用 action creators 触发 action 接着使用纯函数（pure function）reducer 来处理这些 action，它会根据当前 state 和 action 返回（注意这里不是修改）新的 state view 层可以对于 state 进行订阅（subscribe），这样就可以得到新的 state，从而可以刷新界面（所以十分适合数据驱动的前端框架） 纯函数：简单的说就是对于同样的输入总是返回同样的输出，并且没有副作用的函数。（推荐学习了解下函数式编程） 1.1. 为什么选择 redux？ 随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗？当然不是。 这里的复杂性很大程度上来自于：我们总是将两个难以厘清的概念混淆在一起：变化和异步。 我称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 试图在视图层禁止异步和直接操作 DOM 来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。 跟随 Flux、CQRS 和 Event Sourcing 的脚步，通过限制更新发生的时间和方式，Redux 试图让 state 的变化变得可预测。这些限制条件反映在 Redux 的 三大原则中。 简单总结就是使用 Redux 我们就可以没有蛀牙（大雾） 拥有可预测（predictable）的应用状态，所以应用的行为也是可预测的 因为 reducer 是纯函数，所以方便对于状态迁移进行自动化测试 方便地记录日志，甚至实现时间旅行（time travel） 1.2. 三大原则（哲♂学）1.2.1. 单一数据源（Single source of truth）整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中 便于调试，在开发时可以将状态保存在本地 Undo/Redo 可以轻松实现，从而实现时间旅行 1.2.2. State 是只读的（State is read-only）惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，（dispatch 同步调用 reduce 函数）因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。 1.2.3. 使用纯函数来执行修改（Changes are made with pure functions）为了描述 action 如何改变 state tree ，你需要编写 reducer。 Reducer 只是纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分。 二、Redux 基础2.1. actionAction 就是一个普通的 JavaScript Object。 redux 唯一限制的一点是必须有一个 type 属性用来表示执行哪种操作，值最好用字符串，而不是 Symbols，因为字符串是可被序列化的。 其他属性用来传递此次操作所需传递的数据，redux 对此不作限制，但是在设计时可以参照 Flux 标准 Action。 简单总结 Flux Standard action 就是 一个 action 必须是一个 JavaScript Object，并且有一个 type 属性。 一个 action 可以有 payload/error/meta 属性。 一个 action 不能有其他属性。 2.2. reducerReducer 的工作就是接收旧的 state 和 action，返回新的 state。 (previousState, action) =&gt; newState 之所以称作 reducer 是因为它将被传递给 Array.prototype.reduce(reducer, ?initialValue) 方法。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 2.3. storeStore 就是用来维持应用所有的 state 树的一个对象。 在 redux 中只有一个 store（区别于 flux 的多个 store），在 store 中保存所有的 state，可以把它当成一个封装了 state 的类。而除了对其 dispatch 一个 action 以外无法改变内部的 state。 在实际操作中我们只需要把根部的 reducer 函数传递给 createStore 就可以得到一个 store。 12345678910111213import &#123; createStore &#125; from 'redux';function reducer(state, action) &#123; switch (action.type) &#123; case 'SOME_ACTION': // 一些操作 return newState; // 返回新状态 default: return state; &#125;&#125;const store = createStore(reducer); redux 中提供了这几个 api 操作 store 2.3.1. getState返回当前的整个 state 树。 2.3.2. dispatch(action)分发 action 给对应的 reducer。 该函数会调用 getState() 和传入的 action 以【同步】的方式调用 store 的 reduce 函数，然后返回新的 state。从而 state 得到了更新，并且变化监听器（change listener）会被触发。（对于异步操作则将其放到了 action creator 这个步骤） 2.3.3. subscribe(listener)为 store 添加一个变化监听器，每当 dispatch 的时候就会执行，你可以在 listener（回调函数）中使用 getState() 来得到当前的 state。 这个 api 设计的挺有意思，它会返回一个函数，而你执行这个函数后就可以取消订阅。 2.3.4. replaceReducer(nextReducer)替换 store 当前用来计算 state 的 reducer。 这是一个高级 API。只有在你需要实现代码分隔，而且需要立即加载一些 reducer 的时候才可能会用到它。在实现 Redux 热加载机制的时候也可能会用到。 2.4. createStore忽略各种类型判断，实现一个最简的 createStore 可以用以下代码。参考资料 123456789101112131415161718192021222324const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); // 调用 reducer listeners.forEach(listener =&gt; listener()); // 调用所有变化监听器 &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; // 返回解除监听函数 listeners = listeners.filter(l =&gt; l !== listener); &#125;; &#125; dispatch(&#123;&#125;); // 初始化 return &#123; getState, dispatch, subscribe &#125;;&#125;; 2.5. 计数器例子 纯 JavaScript 不涉及界面（可以在右侧 console 中尝试 store.dispatch） 增加界面 三、与 React 进行结合3.1. 通过 script 标签导入 react实现同样功能的 Counter 3.2. 用 Redux 和 React 实现 TodoApp在添加 react-redux 之前，为了体会下 react-redux 的作用，首先来实现一个比计数器更复杂一点儿的 TodoApp 栗子~ 3.2.1. 分析与设计1. 容器组件 V.S. 展示组件组件一般分为 容器组件（Smart/Container Components） 展示组件（Dumb/Presentational Components） 容器组件 展示组件 Location 最顶层，路由处理 中间和子组件 Aware of Redux 是 否 读取数据 从 Redux 获取 state 从 props 获取数据 修改数据 向 Redux 派发 actions 从 props 调用回调函数 最佳实践一般是由容器组件负责一些数据的获取，进行 dispatch 等操作。而展示组件组件不应该关心逻辑，所有数据都通过 props 传入。 这样才能达到展示组件可以在多处复用，在具体复用时就是通过容器组件将其包装，为其提供所需的各种数据。 2. 应用设计 一个 TodoApp 包含了三个部分： 顶部的 AddTodo 输入部分 中间的 TodoList 展示部分 底部的 Footer 过滤部分 State 应该包含： filter：过滤 todos 的条件 SHOW_ALL SHOW_ACTIVE SHOW_COMPLETED todos：所有的 todo todo：包含 id、text 和 completed 然而传到应用中的 props 只需要： visibleTodos：过滤后的 todos filter：过滤条件 Action 应该有三种： ADD_TODO TOGGLE_TODO SET_VISIBILITY_FILTER 3.2.2. 编码实现1. action 部分123456789101112131415// 暂且使用数字作为 idlet nextTodoId = 0;/*-- action creators --*/const addTodo = (text) =&gt; ( &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;);const toggleTodo = (id) =&gt; ( &#123; type: 'TOGGLE_TODO', id &#125;);const setVisibilityFilter = (filter) =&gt; ( &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;); 2. reducer 部分12345678910111213141516171819202122232425262728293031323334353637383940// 默认初始状态const initialState = &#123; filter: 'SHOW_ALL', todos: [] &#125;;function rootReducer(state = initialState, action) &#123; switch (action.type) &#123; case 'ADD_TODO': // 对象解构 const &#123; id, text &#125; = action; return &#123; ...state, todos: [ ...state.todos, &#123; id, text, completed: false &#125;, ], &#125;; case 'TOGGLE_TODO': return &#123; ...state, todos: state.todos.map(todo =&gt; &#123; if (todo.id !== action.id) return todo; return &#123; ...todo, completed: !todo.completed, &#125;; &#125;), &#125;; case 'SET_VISIBILITY_FILTER': return &#123; ...state, filter: action.filter, &#125;; default: return state; &#125;&#125; 注意! 不要直接修改原有的 state，而是返回一个新的 state。可以使用 Object.assign() 新建一个新的 state。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对 ES7 提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 的情况下返回旧的 state，用来兼容遇到未知的 action 这样的错误。 拆分 reducer目前代码看着比较冗长，其实在逻辑上 todos 的处理和 filter 的处理应该分开，所以在 state 没有互相耦合时，可以将其拆分，从而让 reducer 精细地对于对应 state 的子树进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 处理单个 todoconst todoReducer = (state, action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; id: action.id, text: action.text, completed: false, &#125;; case 'TOGGLE_TODO': if (state.id !== action.id) return state; return &#123; ...state, completed: !state.completed, &#125;; default: return state; &#125;&#125;;// 处理 todosconst todosReducer = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, todoReducer(undefined, action), ]; case 'TOGGLE_TODO': return state.map(t =&gt; todoReducer(t, action)); default: return state; &#125;;&#125;;// 处理 filterconst filterReducer = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; &#125;;&#125;;const rootReducer = (state = initialState, action) =&gt; (&#123; todos: todosReducer(state.todos, action), filter: filterReducer(state.filter, action),&#125;); 注意观察最后的 rootReducer 函数，返回的是一个经过各种 reducer 处理过并合并后的新 state。 然鹅，注意这里 todos: todos(state.todos, action), 传入 state.todos，返回的一定也是 todos（因为都是 state 树上的节点）。 所以 redux 提供了很实用的 combineReducers api，用于简化 reducer 的合并。 123456789import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos: todosReducer, filter: filterReducer,&#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 并且如果 reducer 与 state 节点同名的话（即 todosReducer -&gt; todos）还能通过 es6 的语法更进一步地简化 123456import &#123; combineReducers &#125; from 'redux';const rootReducer = combineReducers(&#123; todos, filter &#125;);// initialState 可以作为第二个参数传入const store = createStore(rootReducer, initialState); 随着应用的膨胀，我们还可以将拆分后的 reducer 放到不同的文件中, 以保持其独立性并用于专门处理不同的数据域。 3. view 部分1. 只有根组件首先只写一个根组件 &lt;TodoApp /&gt;，store 通过 props 传入 TodoApp，并在生命周期的 componentDidMount 和 componentWillUnmount 时分别订阅与取消订阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import React, &#123; Component &#125; from 'react';class TodoApp extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 渲染单个 todo _renderTodo(todo) &#123; const &#123; store &#125; = this.props; return ( &lt;li key=&#123;todo.id&#125; onClick=&#123;() =&gt; store.dispatch(toggleTodo(todo.id))&#125; style=&#123;&#123; textDecoration: todo.completed ? 'line-through' : 'none', cursor: todo.completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;todo.text&#125; &lt;/li&gt; ); &#125; // 根据当前 filter 是否匹配，返回字符串或是 a 链接 _renderFilter(renderFilter, name) &#123; const &#123; store &#125; = this.props; const &#123; filter &#125; = store.getState(); if (renderFilter === filter) return name; return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); store.dispatch(setVisibilityFilter(renderFilter)) &#125;&#125;&gt; &#123;name&#125; &lt;/a&gt; ); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); let input; return ( &lt;div&gt; &#123;/* AddTodo */&#125; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &#123;/* TodoList */&#125; &lt;ul&gt; &#123;this._getVisibleTodos(todos, filter) .map(this._renderTodo.bind(this)) &#125; &lt;/ul&gt; &#123;/* Footer */&#125; &lt;p&gt; Show: &#123;' '&#125; &#123;this._renderFilter('SHOW_ALL', 'all')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_COMPLETED', 'completed')&#125; &#123;', '&#125; &#123;this._renderFilter('SHOW_ACTIVE', 'active')&#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; TodoApp 只有根组件 2. 组件拆分将所有界面内容全写在 TodoApp 中实在是太臃肿了，接下来根据之前的分析结果将其分为以下子组件（全是展示组件） AddTodo TodoList Todo Footer FilterLink 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const AddTodo = (&#123; onAddClick &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; onAddClick(input.value); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);const FilterLink = (&#123; filter, onClick, renderFilter, children &#125;) =&gt; &#123; if (renderFilter === filter) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(renderFilter); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;const Footer = (&#123; filter, onFilterClick &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ALL\" onClick=&#123;onFilterClick&#125; &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_COMPLETED\" onClick=&#123;onFilterClick&#125; &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=&#123;filter&#125; renderFilter=\"SHOW_ACTIVE\" onClick=&#123;onFilterClick&#125; &gt; active &lt;/FilterLink&gt; &lt;/p&gt;); 所以 TodoApp 精简后是这样~ 1234567891011121314151617181920212223242526272829303132class TodoApp extends Component &#123; // ... render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;div&gt; &lt;AddTodo onAddClick=&#123;text =&gt; &#123; if (!text) return; store.dispatch(addTodo(text)); &#125;&#125; /&gt; &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; store.dispatch(toggleTodo(id))&#125; /&gt; &lt;Footer filter=&#123;filter&#125; onFilterClick=&#123;filter =&gt; &#123; store.dispatch(setVisibilityFilter(filter)); &#125;&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 3. 增加容器组件现在我们仍然是以 TodoApp 作为容器组件，其中各个子组件都是展示组件。 但是这样做的话一旦子组件需要某个属性，就需要从根组件层层传递下来，比如 FilterLink 中的 filter 属性。 所以下面我们增加容器组件，让展示组件通过容器组件获得所需属性。 AddTodo(container) VisibleTodoList(container) TodoList Todo Footer FilterLink(container) Link 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182// store.dispatch 又被放回来了，// 因为暂时我们只在 AddTodo 组件中使用 addTodo 这个 action// 以后增加了新的 form 之后可以考虑再将 store.dispatch 移出去const AddTodo = (&#123; store &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123; if (!input.value) return; store.dispatch(addTodo(input.value)); input.value = ''; &#125;&#125;&gt; addTodo &lt;/button&gt; &lt;/div&gt; );&#125;;const Todo = (&#123; text, onClick, completed &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123;&#123; textDecoration: completed ? 'line-through' : 'none', cursor: completed ? 'default' : 'pointer', &#125;&#125; &gt; &#123;text&#125; &lt;/li&gt;);const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; )&#125; &lt;/ul&gt;);// 容器组件class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; // 根据当前 filter 过滤需要渲染的 todos _getVisibleTodos(todos, filter) &#123; switch (filter) &#123; case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed); case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed); default: return todos; &#125; &#125; render() &#123; const &#123; store &#125; = this.props; const &#123; todos, filter &#125; = store.getState(); return ( &lt;TodoList todos=&#123;this._getVisibleTodos(todos, filter)&#125; onTodoClick=&#123;id =&gt; &#123; store.dispatch(toggleTodo(id)) &#125;&#125; /&gt; ); &#125;&#125;// 原本的 FilterLink 改成 Link，去掉 filter 和 renderFilter 属性，改为传入 activeconst Link = (&#123; active, onClick, children &#125;) =&gt; &#123; if (active) return (&lt;span&gt;&#123;children&#125;&lt;/span&gt;); return ( &lt;a href='#' onClick=&#123;e =&gt; &#123; e.preventDefault(); onClick(); &#125;&#125;&gt; &#123;children&#125; &lt;/a&gt; );&#125;;// 容器组件class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.props; this.unsubscribe = store.subscribe( this.forceUpdate.bind(this) ); &#125; // 取消订阅 componentWillUnmount() &#123; this.unsubscribe(); &#125; render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125;// 展示组件const Footer = (&#123; store &#125;) =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ALL\" &gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_COMPLETED\" &gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink store=&#123;store&#125; renderFilter=\"SHOW_ACTIVE\" &gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 在不使用全局变量 store 的情况下，// 暂时只能通过 props 传递进来，// Don't worry~很快就不会这么麻烦了~const TodoApp = (&#123; store &#125;) =&gt; ( &lt;div&gt; &lt;AddTodo store=&#123;store&#125; /&gt; &lt;VisibleTodoList store=&#123;store&#125; /&gt; &lt;Footer store=&#123;store&#125; /&gt; &lt;/div&gt;); 通过观察重构后的代码可以发现有三点麻烦的地方 根组件需要通过 props 将 store 传给各个子组件 容器组件都要定义 componentDidMount 进行订阅和 componentWillUnmount 取消订阅 应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 4. Provider让我们先来解决第一个麻烦~，利用 React 提供的 context 特性 123456789101112131415class Provider extends Component &#123; // 通过该方法向 children 的 context 注入 store getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;// 必须要声明传入 context 的 store 的类型Provider.childContextTypes = &#123; store: React.PropTypes.object,&#125;; 自顶向下地看一下如何使用到 TodoApp 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// 1. 使用 Provider 包裹 TodoApp，并将 store 作为 props 传入ReactDOM.render( &lt;Provider store=&#123;createStore(rootReducer, initialState)&#125;&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('container'),);// 2. 根组件 TodoApp: 和 store say goodbye~，// 因为 TodoApp 并不是容器组件~const TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);// 3. AddTodo: 由于 props 固定作为第一个传入子组件的参数，// 所以 &#123; store &#125; 要声明在第二位，然鹅需要声明 contextTypes...const AddTodo = (props, &#123; store &#125;) =&gt; &#123; // ...&#125;;// 必须声明AddTodo.contextTypes = &#123; store: React.PropTypes.object,&#125;;// 4. VisibleTodoList: 从 props 改成从 context 中获取 store，// 同样声明 contextTypes...class VisibleTodoList extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; store &#125; = this.context; // props -&gt; context const &#123; todos, filter &#125; = store.getState(); // ... &#125;&#125;// 必须声明VisibleTodoList.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- TodoList 和 Todo 不变 --// 5. Footer：和 store say goodbye...const Footer = () =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink renderFilter=\"SHOW_ALL\"&gt; all &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_COMPLETED\"&gt; completed &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink renderFilter=\"SHOW_ACTIVE\"&gt; active &lt;/FilterLink&gt; &lt;/p&gt;);// 6. FilterLink: 同 VisibleTodoList（props + contextTypes...）class FilterLink extends Component &#123; // 订阅 store 的变化 componentDidMount() &#123; const &#123; store &#125; = this.context; // props -&gt; context // ... &#125; // ... render() &#123; const &#123; renderFilter, children &#125; = this.props; const &#123; store &#125; = this.context; // props -&gt; context const &#123; filter &#125; = store.getState(); // ... &#125;&#125;// 必须声明FilterLink.contextTypes = &#123; store: React.PropTypes.object,&#125;;// -- Link 不变 -- 现在中间的非容器组件完全不用为了自己的孩子而费劲地传递 store={store}所以以上我们就实现了简化版的由 react-redux 提供的第一个组件 &lt;Provider /&gt;。 然鹅，有木有觉得老写 contextTypes 好烦啊，而且 context 特性并不稳定，所以 context 并不应该直接写在我们的应用代码里。 计将安出？ 5. connect OOP思维：这还不简单？写个函数把容器组件传进去作为父类，然后返回写好了 componentDidMount，componentWillUnmount 和 contextTypes 的子类不就好啦~ 恭喜你~面向对象的思想学的很不错~ 虽然 JavaScript 底层各种东西都是面向对象，然而在前端一旦与界面相关，照搬面向对象的方法实现起来会很麻烦… React 早期用户：这还不简单？写个 mixin 岂不美哉~~？ 作为 react 亲生的 mixin 确实在多组件间共享方法提供了一些便利，然而使用 mixin 的组件需要了解细节，从而避免状态污染，所以一旦 mixin 数量多了之后会越来越难维护。 Unfortunately, we will not launch any mixin support for ES6 classes in React. That would defeat the purpose of only using idiomatic JavaScript concepts. 所以官方也放弃了在 ES6 class 中对 mixin 的支持。 函数式（FP）：高阶组件 High Order Component（下称 hoc）才是终极解决方案~~ hocFactory:: W: React.Component =&gt; E: React.Component 如上所示 hoc 的构造函数接收一个 W（代表 WrappedComponent）返回一个 E（代表 Enhanced Component），而 E 就是这个高阶组件。 假设我们有一个旧组件 Comp，然鹅现在接收参数有些变动。 当然你可以复制粘贴再修改旧组件的代码…（大侠受窝一拜） 也可以这么写，返回一个新组件来包裹旧组件。 123456789class NewComp extends Component &#123; mapProps(props) &#123; return &#123;/* new props */&#125;; &#125; render() &#123; return (&lt;Comp &#123;...this.mapProps(this.props)&#125; /&gt;); &#125;&#125; 然鹅，如果有同样逻辑的更多的组件需要适配呢？？？总不能有几个抄几遍吧… 所以骚年你听说过高阶组件么~？ 12345678910// 先返回一个函数，而那个函数再返回新组件const mapProps = mapFn =&gt; Comp =&gt; &#123; return class extends Component &#123; render() &#123; return (&lt;Comp &#123;...this.mapFn(this.props)&#125; /&gt;); &#125; &#125;;&#125;;const NewComp = mapProps(mapFn)(Comp); // 注意调用了两次 可以看到借助高阶组件我们将 mapFn 和 Comp 解耦合，这样就算需要再嵌套多少修改逻辑都没问题~天黑都不怕~ ok，扯了这么多的淡，终于要说到 connect 了是哒，你木有猜错，react-redux 提供的第二个也是最后一个 api —— connect 返回的就是一个高阶组件。 使用的时候只需要 connect()(WrappedComponent) 返回的 component 自动就完成了在 componentDidMount 中订阅 store，在 componentWillUnmount 中取消订阅和声明 contextTypes。 这样就只剩下最后一个麻烦 3.应用其实并不需要渲染所有的 todos，所以内部很麻烦地定义了 _getVisibleTodos 函数 其实 connect 函数的第一个参数叫做 mapStateToProps，作用就是将 store 中的数据提前处理或过滤后作为 props 传入内部组件，以便内部组件高效地直接调用。这样最后一个麻烦也解决了~ 然鹅，我们问自己这样就够了么？并没有… 还有最后一个细节，以 FilterLink 为例。 12345678910111213141516171819class FilterLink extends Component &#123; // ... render() &#123; const &#123; store, renderFilter, children &#125; = this.props; const &#123; filter &#125; = store.getState(); return ( &lt;Link active=&#123;filter === renderFilter&#125; onClick=&#123;() =&gt; store.dispatch( setVisibilityFilter(renderFilter) )&#125; &gt; &#123;children&#125; &lt;/Link&gt; ); &#125;&#125; 除了从 store 中获取数据（filter），我们还从中获取了 dispatch，以便触发 action。如果将回调函数 onClick 的内容也加到 props 中，那么借助 connect 整个 FilterLink 的逻辑岂不是都被我们抽象完了？ 是哒，connect 的第二个参数叫做 mapDispatchToProps，作用就是将各个调用到 dispatch 的地方都抽象成函数加到 props 中的传给内部组件。这样最后一个麻烦终于真的被解决了~ 12345678910111213141516171819const mapStateToLinkProps = (state, ownProps) =&gt; (&#123; // ownProps 是原组件的 props， // 这里为了和高阶组件的 props 区分 active: ownProps.renderFilter === state.filter,&#125;);const mapDispatchToLinkProps = (dispatch, ownProps) =&gt; (&#123; onClick() &#123; dispatch( setVisibilityFilter(ownProps.renderFilter) ); &#125;,&#125;);// 注意原 FilterLink 整个都被我们删了const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link); TodoApp 使用 react-redux 四、总结本文从 Redux 的理论基础和源码出发，介绍了 Redux 的各项基础 api。 接着一步一步地介绍如何与 React 进行结合，从过程中的各个痛点引出 react-redux 的作用和原理。 然鹅，还有好多的坑没填，比如：大型项目的文件结构、前端路由（react-router）、中间件（middlewares）、网络请求等各类异步操作、服务器端同构直出… 以上 to be continued…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"https://buptsteve.github.io/blog/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://buptsteve.github.io/blog/tags/React/"}]},{"title":"「6」JavaScript 函数表达式学习笔记","date":"2016-03-23T07:27:58.000Z","path":"2016/03/23/6.js-function-chapter7/","text":"零、前言《JavaScript 高级程序设计（第三版）》第7章 函数表达式，学习笔记整理。 主要内容有如下三部分 函数表达式的特征 使用函数实现递归 使用闭包定义私有变量 一、第7章 函数表达式7.0. 函数定义在 JavaScript 中定义函数有两种方法： 函数声明 函数表达式 7.0.1. 函数声明123456function functionName(arg0, arg1, arg2) &#123; // 函数体&#125;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // functionName，函数名称 函数声明一个重要特征就是：函数声明提升（function declaration hoisting），简单来说就是 JS 引擎会在执行阶段之前读取函数声明，这就是我们才能够在函数声明之前就调用它的原因。 7.0.2. 函数表达式1234567// 有多种形式，以下为最常见的一种，即创建一个匿名函数并将其赋值给变量 functionNamevar functionName = function(arg0, arg1, arg2) &#123; // 函数体&#125;;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // 空字符串 当然函数表达式就没有声明提升这种特征了。以下是一个比较常见的坑… 1234567891011121314151617181920212223242526// 千万别这样做！// 因为有的浏览器会返回 first 的这个 function，而有的浏览器返回的却是第二个if (true) &#123; function foo() &#123; return 'first'; &#125;&#125; else &#123; function foo() &#123; return 'second'; &#125;&#125;foo();// 相反，这样情况，我们要用函数表达式var foo;if (true) &#123; foo = function() &#123; return 'first'; &#125;;&#125; else &#123; foo = function() &#123; return 'second'; &#125;;&#125;foo(); 7.1. 递归 先说个段子：要想理解递归，首先要理解…递归。 说正经的，递归就是函数自己调用自己。 12345678910111213function factorial(num) &#123; // 递归结束条件 if (num &lt;= 1) return 1; // 通过在全局 VO 中，找到自身函数的指针后调用自身 return num * factorial(num-1);&#125;var anotherFactorial = factorial;factorial = null;// 报错！因为修改了全局 VO 中 factorial 指针的指向（null）alert(anotherFactorial(4)); 这么写主要问题就是递归函数与自身的函数名耦合，一旦修改了原本的函数名，则会导致错误。 这时可以利用 arguments.callee 指针来成功寻找到正在执行的函数。 接下来又有一个坑：arguments 在严格模式下无法使用。 不过我们可以使用命名函数表达式来完美解决： 123456789var factorial = function f(num) &#123; // 递归结束条件 if (num &lt;= 1) return 1; // 函数名 f 只在内部作用域里有效 return num * f(num-1);&#125;;typeof f; // undefined 7.2. 闭包 先下定义：闭包是指【有权】访问（另一个函数作用域）中的「变量」的「函数」。 闭包首先是一个函数 能力就是有权访问变量 范围在另一个函数作用域内 我们日常在使用 JavaScript 中，在外部函数中定义的内部函数能够访问外部函数中的变量。 所以，最常见的闭包方式就是在一个函数内部创建并返回另一个函数。 12345678910function foo(arg0, arg1) &#123; return function bar() &#123; // 内部的 bar 函数能够访问外部函数 foo 的 arg0 和 arg1 变量。 return arg0 + arg1; &#125;&#125;var test = foo('a', 'b'); // test 是一个指针，指向返回的 bar 函数test(); // ab，调用闭包后，得到 arg0 + arg1 的值typeof bar; // undefined，当然返回的是一个匿名函数 那么内部的 bar 函数是怎么保存外部 foo 函数的两个参数的呢？ 首先在浏览器端的 JavaScript 代码，有一个全局的执行环境（Execution Context）即 window 对象。 每个执行环境都有一个对应的变量对象（Variable Object）：定义的所有变量和函数都保存其中。 当某个函数被调用时，会创建一个执行环境（EC）及相应的作用域链（Scope Chain）（其实是被推入一个环境栈中，执行之后栈将之弹出）。 作用域链（SC）就是一个指向各个变量对象的指针列表（全局 VO 是其中的最后一个对象）。 一般来说某个执行环境（EC）的所有代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。 如果执行环境是一个函数，那么它的变量对象（VO）又叫做活动对象（Activation Object）。 因此在一个函数中解析标识符的过程，类似于上一篇中提到的原型链查找。也是沿着 SC 一级一级地往上找。如果直到全局 VO 还没找到，就会报错。 所以接下来举几个栗子： 1. 普通函数12345678function compare(value1, value2) &#123; if (value1 &lt; value2) return -1; if (value1 &gt; value2) return 1; return 0;&#125;var result = compare(5, 10); 1234567891011121314 ______________________________________________________________ | | V _____________________ | _____________________ _________________ |--&gt; | global VO | | |---&gt;| compare AO || compare EC | | |---------------------| | | |---------------------||-------—---------| _______ | | compare | *----|--| | | arguments | [5, 10] || Scope Chain | *-|----&gt; | SC | | |---------------------| | |---------------------||-----------------| |-------| | | result | undefined | | | value1 | 5 | | 1 | *-|----| |---------------------| | |---------------------| |-------| | | value2 | 10 | | 0 | *-|----------------------------------------| |---------------------| |-------| by 灵魂画师...(累死我了) 在创建 compare 函数时，就已经创建一个预先包含全局 VO 的作用域链（保存在内部的 [[Scope]] 属性中）。 在执行 compare 函数时，就创建 EC，然后复制并构建 [[Scope]] 属性中的作用域链 SC 此时创建 compare AO，并将其放入 SC 的顶端。 所以在函数中访问一个变量时，会从作用域顶端（就是 compare AO）开始找起。 所以一般一个函数执行完毕后，因为 AO 被销毁，所以在函数外部无法访问到函数内部的变量。 2. 闭包示例123456789101112131415161718192021function createCompFunc(propName) &#123; return function(obj1, obj2) &#123; var value1 = obj1[propName]; var value2 = obj2[propName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;var compare = createCompFunc(\"name\"); // 创建函数var result = compare(&#123;name: \"steve\"&#125;, &#123;name: \"young\"&#125;); // 调用函数compare = null; // 解除对匿名函数的引用（释放内存） 1234567891011121314151617181920212223242526 __________________________________________________________________ | _____________________ | | |-----&gt; | global VO | | | | |---------------------| | | | | createCompFunc | *--|--| | | |---------------------| V | | result | undefined | ___________________ _______ | |---------------------|| createCompFunc EC | |---&gt; | SC1 | | ______________________|-------—-----------| | |-------| | |---&gt; | createCompFunc AO || Scope Chain | *--|------| | 1 | *-|-| | |----------------------||-------------------| |-------| | | | arguments | [&quot;name&quot;] | | 0 | *-|-(-| |----------------------| ________________________ |-------| | | | propName | &quot;name&quot; || anoymous function EC | | | |----------------------||-------—----------------| _______ | | _______________________________| Scope Chain | *-----|-----&gt; | SC2 | | | |-&gt; | anoymous function AO ||------------------------| |-------| | | | |-------------------------------| | 2 | *-|-| | | | arguments | [&#123;name: &quot;steve&quot;&#125;, | |-------| | | | | &#123;name: &quot;young&quot;&#125;] | | 1 | *-|---| | |-------------------------------| |-------| | | obj1 | &#123;name: &quot;steve&quot;&#125; | | 0 | *-|-----| |-------------------------------| |-------| | obj2 | &#123;name: &quot;young&quot;&#125; | |-------------------------------| by 灵魂画师...(累死我了) 如图所示，首先看全局变量对象（global VO），其中有一个指针指向 createCompFunc 函数，还有一个声明提升后还未计算完毕的 result 等变量。 首先执行外部的 createCompFunc 函数，创建了它的 EC，其中有一个作用域链指针指向它的作用域链 SC1。 那么显然 SC1 中会有两个指针，分别指向 createCompFunc AO 和 global VO（这就是在函数内部能够访问到全局变量的原因）。 在 createCompFunc AO 中存放的就是函数内部定义的变量。 最后来看 createCompFunc 函数内部返回的匿名函数，当然它也有自己的执行环境 EC，也有自己的作用域链 SC2。 只不过由于它是 createCompFunc 函数内部的函数，当然它也能访问外部 createCompFunc 函数定义的变量，这正是因为 SC2 中位于第二的指针指向 createCompFunc AO（这就是闭包的原理）。 更为重要的是，在 createCompFunc 函数执行完毕后，因为匿名函数仍然引用着 createCompFunc AO，所以其活动对象不会被销毁（这涉及到内存回收机制）。 从上述讨论我们可以清晰地看出：闭包的原理就是内部的函数仍然引用着外部函数的 AO，使得外部函数的 AO 仍然保存在内存中。所以我们可以通过将闭包设置为 null 来解除对该函数的引用，回收其占用的内存。 7.2.1. 闭包与变量下面我们来简单讨论下作用域链机制的副作用（坑）：闭包只能取得外部函数中任何变量的最后一个值。 先来看一个栗子： 1234567891011121314function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; // 希望保存不同的 i，但是最后 i 都是 10 &#125;; &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 10 其实很好理解，因为闭包在 SC 中保存的是一个指针而已，外部函数执行完毕后 AO 中的变量自然更新为最后一个值啦╮(╯▽╰)╭。 但是我们可以创建另一个立即执行的匿名函数强制让闭包的行为符合预期： 12345678910111213141516function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 0 在这里我们相当于有3层函数。 中间那层的匿名函数有一个参数 num，我们将 i 传入立即执行。 因为简单类型是按值传递的，所以中间那层的匿名函数的 AO 中 num 保存的是不同的 i。 而最内层的匿名函数读取的正是中间层匿名函数的 AO。 7.2.2. 关于 this 对象我们知道，this 是在运行时根据函数的执行环境动态绑定的： 在全局函数中，this 等于 window。 而函数被作为某个对象的方法调用时，this 又指向那个对象。 使用 call() 和 apply() 方法时，this 又会指向传入的那个对象（还有 bind()）。 不过，匿名函数的执行环境具有全局性，因此内部的 this 通常指向 window，见下例： 12345678910111213var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window (非严格模式下)，此处有两个括号，因为 object.getNameFunc() 是一个匿名函数，后一个括号是匿名函数调用。 为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？ 前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。而内部函数在搜索这两个变量时，只会搜索到其 AO 为止，所以永远不能直接访问到外部函数中的 this 和 arguments。 不过若是我们将外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问到该对象了： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; var that = this; // 使用 that 保存外部函数的 this（防止被内部函数的 this 屏蔽） return function() &#123; return that.name; // 由于访问的是内部 AO 中没有的变量 that，所以在 SC 中外部的 AO 上搜索，得到外部函数的 this。 &#125;; &#125;&#125;;alert(object.getNameFunc()()); // My Object 接下来再看几个特殊的栗子： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getName: function() &#123; return this.name; &#125;&#125;;object.getName(); // My Object，很好理解 this 就是指向 object(object.getName)(); // My Object，将函数包了起来，但还是通过 object.getName 调用，this 还是指向 object(object.getName = object.getName)(); // The Window(非严格模式下)，看起来很奇怪，将函数 getName 赋值为 getName，再调用赋值后的结果// 因为赋值表达式操作的是 getName 函数本身，所以 this 的值没有得到维持，调用时指向了 widnow。 7.2.3. 内存泄漏因为 IE9 之前对于 JScript 对象和 COM 对象使用不同的垃圾收集机制。所以如果闭包的作用域中保存一个 HTML 元素，那么该元素将无法被销毁╮(╯▽╰)╭。 7.3. 模仿块级作用域我们都知道在 ES6 之前是木有块级作用域的╮(╯▽╰)╭，在块语句中定义的变量实际上是定义在函数 AO 上的。 如果实在需要块级作用域，可以通过立即执行函数进行模拟。 1234// 这只是其中一种写法...重点是不要使用函数声明，这样由于声明提升会报错。(function() &#123; // 这里是块级作用域&#125;)(); 在一个大型程序中过多的全局变量和函数很容易造成命名冲突，这样可以有效减少在全局作用域中添加变量和函数。也可以说是模块化的基础。ps jQuery 源码中最外层函数就是这样的一个立即执行函数… 7.4. 私有变量严格来说，JavaScript 中没有私有成员的概念…╮(╯▽╰)╭，不过在任何函数中定义的变量，外部都无法访问到，可以认为是私有变量。 私有变量包括： 函数的参数 局部变量 内部定义的其他函数 那么如果我们需要访问这些私有变量该怎么办呢？在此就要引入一个概念：特权方法（privileged method）有权访问私有变量和私有函数的公有方法。 这个概念是不是和闭包炒鸡像！？ 其实有两种在对象上创建特权方法的方式，第一种就是利用闭包在构造函数中定义特权方法。基本模式如下： 123456789101112131415function MyObject() &#123; // 私有变量和函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125; 但是，这样定义特权方法有一个问题：必须使用构造函数模式。而之前已经讨论过了构造函数会为每个实例都创建一组新方法，浪费内存，而接下来介绍的第二种方法，使用静态私有变量就可以避免这个问题。 7.4.1. 静态私有变量基本思想就是：在私有作用域（立即执行函数）中定义私有变量或函数，并在内部通过函数表达式定义构造函数和它的公有方法。基本模式如下： 12345678910111213141516171819(function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 构造函数 MyObject = function() &#123;&#125;; // 没有使用 var，所以是在 window 上创建（所以是非严格模式下）。 // 公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125;)(); 显然，通过上一篇对于对象继承的讨论我们知道：定义在原型对象上的属性和方法是所有实例共享的，而这些方法（如 publicMethod）所操作的对象，即私有变量和函数也是同一个。所以通过 MyObject 构造函数创造的实例都有权访问私有变量（而且是同一个），这就是静态私有变量。 7.4.2. 模块模式模块模式（module pattern）是为「单例」创建私有变量和特权方法。 那么问题来了，单例是啥？ 单例（singleton）指的就是只有一个实例的对象。比如 JavaScript 中就是以对象字面量来创建单例对象的。 123456var singleton = &#123; name : value, method: function() &#123; // 方法的代码 &#125;&#125;; 模块模式通过为单例添加私有变量和特权方法使其得到增强： 1234567891011121314151617181920var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 公有/特权方法 return &#123; publicProperty: true, publicMethod: function() &#123; privateVar++; return privateFunc(); &#125;; &#125;;&#125;(); 如上面代码所示，模块模式就是使用了一个返回对象的匿名函数： 在函数内部定义了私有变量和函数 然后将对象字面量返回。 因为对象是函数内部定义的，所以它的方法是一个闭包。 模块模式的应用场景主要是在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。 7.4.3. 增强的模块模式应用场景：单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其进行加强的情况。 12345678910111213141516171819202122var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 创建对象 var object = new CustomType(); // 添加公有/特权属性和方法 object.publicProperty = true; object.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;; return object;&#125;(); 7.5. 小结1. 在 JavaScript 中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点： 函数声明必须要有名字，还会声明提升，而函数表达式不需要，没有名字的函数表达式又叫匿名函数 在递归函数中使用函数名调用自身可能会出现问题，如函数名发生了变化。 在递归函数中要掌握调用函数自身的技巧，如 arguments.callee 等。 2. 闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下： 在 JavaScript 引擎执行时，闭包的 SC 包含了自己的 AO、外部函数的 AO 还有全局 VO。 通常，函数的作用域和所有变量会在函数执行后被销毁。 但是，当函数返回了一个闭包时，外部函数的 AO 会一直保存在内存中，直到解除闭包的引用，如设为 null。 3. 使用闭包可以模仿块级作用域： 立即执行函数既可以执行其中的代码，又不会在内存中留下对该函数的引用。 所以函数内部的所有变量都会被立即销毁，除非将某些变量赋值给外部作用域中的变量。 4. 闭包还可以用于在对象中创建私有变量： 函数内部的变量、方法，外部无法访问。 但通过闭包可以实现公有方法，即访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法。 也可以使用模块模式、增强模块模式来实现单例的特权方法。 综上：JavaScript 中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「5」JavaScript 面向对象深入理解","date":"2016-03-17T08:27:58.000Z","path":"2016/03/17/5.js-oo-chapter6/","text":"零、前言最近为了找暑假实习，正在恶补基础，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。 同样按照书本的顺序分为如下三部分 理解对象属性 理解并创建对象 理解继承 一、第6章 面向对象的程序设计6.1. 理解对象ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”简单来说，对象就是一些名值对（Key-Value），而对象的名字就是一个指针。 6.1.1. 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 6.1.2. 数据属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Writable]]：表示能否修改属性的值，默认为 true。 [[Value]]：包含这个属性的数据值，默认为 undefined。 要修改以上属性，必须使用 ES5 中的 Object.defineProperty()。 12345678910111213141516171819202122232425// 例1var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value : \"steve\"&#125;);alert(person.name); // steveperson.name = \"abc\";alert(person.name); // steve// 例2var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, value : \"steve\"&#125;);// 抛出错误Object.defineProperty(person, \"name\", &#123; configurable: true, value : \"steve\"&#125;); ps 在调用 Object.defineProperty() 方法时，默认值为 false(就是说其他没写的属性都是 false)。 6.1.3. 访问器属性访问器属性不包括数据值(Value)，取而代之的是一对儿 getter 和 setter 函数(非必须)。 [[Configurable]]：表能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Get]]：在读取属性时调用的函数，默认为 true。 [[Set]]：在写入属性时调用的函数，默认为 undefined。 访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。 1234567891011121314151617181920var book = &#123; _year : 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 ps 如果只定义了两个方法的其中之一，那么另一种方式则无法使用，例如只定义了 getter，则属性不可写。 6.1.4. 定义多个属性12345678910111213141516171819202122var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; &#125; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 6.1.5. 读取属性的特性12345var desc = Object.getOwnPropertyDescriptor(book, \"_year\");alert(desc.value); // 2004alert(desc.configurable); // falsealert(typeof desc.get); // undefined 6.2. 创建对象使用 Object 构造函数和字面量创建对象，会产生大量重复代码，所以以下代码重用机制应运而生。 6.2.1. 工厂模式特点：使用函数封装特定接口创建对象的细节。 简单来说就是在函数的内部创建对象，为其添加属性和方法后，用 return 返回，在实例化时不使用 new 操作符。 12345678910111213141516function createPerson(name, age, job) &#123; var o = &#123; name: name, age : age, job : job, sayName: function() &#123; alert(this.name); &#125; &#125;; return o;&#125;var person1 = createPerson(\"steve\", 24, \"fe\");var person2 = createPerson(\"young\", 25, \"fs\"); 问题：没有解决对象识别的问题（即怎样知道一个对象的类型），重复构造相同的方法造成内存浪费，也无法进行继承复用。 6.2.2. 构造函数模式特点：在构造函数中使用 this 对象在运行时基于函数的执行环境动态绑定，使用 new 操作符实例化。 ps 通过 new 关键字方式调用的函数都被认为是构造函数。 123456789101112131415function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"steve\", 24, \"fe\");var person2 = new Person(\"young\", 25, \"fs\");alert(person1.constructor === Person); // truealert(person2.constructor === Person); // true 1. 与工厂模式的不同之处 没有显式地创建对象 直接将属性和方法赋值给了 this 对象 没有 return 语句 2. 必须使用 new 操作符创建新实例这个过程经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（this 指向新对象） 执行构造函数中的代码（为之添加属性） 返回新对象 这种方式胜过工厂模式的地方就在于：可以将实例标识为一种特定的类型。 3. 构造函数当作普通函数既然实例化需要使用 new 操作符，万一不使用又会怎么样的？ 123456789101112// 当作构造函数使用var person = new Person(\"steve\", 24, \"fe\");person.sayName(); // steve// 当作普通函数使用Person(\"young\", 24, \"fe\"); // 添加到 window 对象中window.sayName(); // young// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"sasuke\", 24, \"fe\");o.sayName(); // sasuke 4. 构造函数的问题每个方法有独立的内存，造成浪费。 1234567891011121314alert(person1.sayName == person2.sayName); // false// 虽然可以把函数定义转移到构造函数外function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.Name);&#125; 虽然这样将其设置成了全局函数，但是新问题就是：全局函数却只能被某个对象调用，并且如果需要定义很多方法，就需要定义很多全局函数，也就是说毫无封装性可言。 6.2.3. 原型模式首先我们要知道每一个函数都有一个属性叫做 prototype，这个属性是一个指针，指向函数的原型对象。 原型对象的用途：包含可以由特定类型的「所有实例」[共享]的属性和方法。 换句话来说就是：所有对象实例可以一起通过这个 prototype 来共享属性和方法～。 12345678910111213141516171819function Person() &#123;&#125;// 属性Person.prototype.name = \"steve\";Person.prototype.age = 24;Person.prototype.job = \"Web Developer\";// 方法Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // stevevar person2 = new Person();person2.sayName(); // stevealert(person1.sayName === person2.sayName); // true 共享同一个方法 1. 深入理解原型对象 只要是函数，都有一个 prototype 指针，指向原型对象。 而原型对象默认会自动获得一个 constructor 指针，指向上一条中的函数。（你指我？我也指你→_→） 调用构造函数创建一个新实例后，实例内部也会获得一个 [[prototype]] 指针（ES5 中这么叫），指向原型对象（不是创造它的构造函数！）。 下面进行详细说明： 第一条很好理解，当作大自然的规律来记就好啦，你否认也没用… 第二条就是说原型对象与一般的对象最大的不同就是这个 constructor 指针，所以在重写构造函数的 prototype 时，要想与之前的原型对象保持一致，最好也加上这个 constructor 指针（显得专业嘛～）。 第三条，其实在 Firefox、Safari 和 Chrome 中，[[prototype]] 就是 __proto__ 指针。 ps 无论有没有 __proto__ 指针，我们都可以通过 isPrototypeOf() 方法来确定对象之间是否存在原型关系。（Person.prototype.isPrototypeOf(person1) // true） pps ES5 中增加了一个新方法 Object.getPrototypeOf() （Object.getPrototypeOf(person1) === Person.prototype // true） 总结一下就是：构造函数有指向原型对象的指针(prototype)，原型对象也有指向构造函数的指针(constructor)，实例同样也有指向原型对象的指针([[prototype]]) 那么这玩意儿搞这么复杂有啥用咧…? 简单举个栗子，上文中 6.2.3.原型模式一节中的两个实例(person1,person2)并不包含任何属性和方法，但是我们仍然可以调用 person1.sayName() 方法，这就是通过查找对象属性的过程实现的。 还有我们经常使用的各种数组方法(slice,splice,sort…)，同样也是定义在 Array.prototype 这个对象上的。 其实每当读取某个对象的某个属性时，都会执行一次搜索，目标就是给定的属性名。首先当然先搜索对象实例自身，如果没找到再继续搜索 [[prototype]] 指针指向的原型对象，如果找不到再向上查找… 所以实例的属性可以“屏蔽“原型链上的同名属性。（通过 delete 可以删除实力属性，消除屏蔽） a. 如何判断属性属于实例还是原型链？很简单，使用 hasOwnProperty() 犯法。 b. 如果原型链上也没有咋办？还记得 JavaScript 中的数据类型么，不平凡的那个引用类型 Object。我们使用的 Array、Function、Date、RegExp… 都是由 Object 派生而成。换句话说他们的原型对象都指向了 Object.prototype。最后 Object.prototype 又指向了 null。 所以如果寻找属性直到 Object.prototype 中都没有，从而找到 null。那么 JS 引擎就会抛出 undefined。 2. 原型与 in 操作符in 操作符用来判断对象能否访问给定属性（前提是 enumerable 为 true），有两种方法使用 in 操作符： 单独使用 在 for-in 循环中使用 但由于 in 操作符不区分实例和原型链，所以日常使用中需要结合 hasOwnProperty() 方法 1234function hasPrototypeProperty(object, name) &#123; // 判断是否是原型链上的属性 return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 此外要取得对象上所有可枚举的实例属性，可以用 ES5 中的 Object.keys() 方法（返回数组）。 当然如果要取得所有实例属性，无论是否可枚举，可以用 Object.getOwnPropertyNames() 方法。 3. 更简单的原型方法日常使用中，每当要为原型对象添加一个属性或方法，都要敲一遍 Person.prototype，这样太不优雅了… 所以一般采用对象字面量将属性和方法都包起来。 12345678910111213function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 别忘了之前说过的 constructor 指针。 name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;; 但是，如果你是个完美主义者，还有一点要注意：原生 constructor 属性是不可枚举的，所以可以用 Object.defineProperty() 将其改写回来。 123456789101112131415161718function Person() &#123;&#125;Person.prototype = &#123; name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;;Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, value : Person&#125;); 4. 原型的动态性略，只要你了概（解）了指针是咩（什么）就大丈夫（没问题）。 5. 原型对象的原型略，大概内容就是说了下俺们原生的对象和乃们“野生”对象一样也是有原型的╮(╯▽╰)╭。 6. 原型对象的问题问题其实是来自于自身共享的本性。 例如，包含引用类型的属性。由于引用类型实际上就是指针，所以所有实例操作的都是同一个引用对象，见下例： 1234567891011121314151617181920212223function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name : \"steve\", age : 24, job : \"Web Developer\", friends: [\"shirley\", \"jame\"], sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\",\"van\"]alert(person1.friends === person2.friends); // true 6.2.4. 组合使用构造函数模式和原型模式经过上文的讨论我们知道： 构造函数模式可以为每个实例生成单独的属性，但无法共享。 原型模式可以共享，但无法为实例生成单独的属性。 既然构造函数模式和原型模式的优缺点正好互补，那么为何不将两者结合，发挥各自的长处？ 组合模式就是基于这一朴素的思想： 构造函数用于定义实例属性 原型模式用于定义共享的属性和方法 这样一来，每个实例都有自己的实例属性副本，但同时又共享着原型对象中的方法和属性，最大限度地节省了内存，还支持向构造函数中传递参数，可谓博采众长也～=￣ω￣=～。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.5. 动态原型模式本质其实还是组合模式，只不过把原型对象中共享的属性和方法，也封装在构造函数里… 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"]; if (typeof this.sayName != \"function\") &#123; // 不能使用对象字面量 Person.prototype = &#123;...&#125;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.6. 寄生构造函数模式首先一般来说，组合模式已经足够应付日常需求，所以这个模式是为了应对特殊需求：例如我们需要创建一个具有额外方法的特殊数组，但是不能直接修改 Array 的构造函数（见下例）。 具体形式上除了使用 new 操作符创建实例以外，和工厂模式一毛（模）一样（同样的问题）。 1234567891011121314151617function SpecialArray() &#123; // 内部创建一个新数组 var values = new Array(); // 添加值 values.push.apply(values, arguments); // 添加方法 values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\"); // 注意：使用 new 创建实例alert(colors.toPipedString()); // red|blue|green 这个模式其实利用了构造函数的特性： 如果被调用的函数没有显式的 return 表达式，则隐式地会返回 this 对象 - 也就是新创建的隐式对象。 显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。 1234567891011121314151617function Foo() &#123; return 2;&#125;function Bar() &#123; return new Number(2);&#125;new Foo().constructor === Number // false，返回新创建的隐式对象new Bar().constructor === Number // true，返回 Number 对象function Test() &#123; this.value = 2; return &#123; foo: 1 &#125;;&#125;console.log(new Test()); // &#123;foo: 1&#125;，返回的对象，this 对象被销毁了，value 丢失了 6.2.7. 稳妥构造函数模式首先要介绍 Douglas Crockford 发明的「稳妥对象」(durable objects) 这个概念：没有公共属性，而且方法也不引用 this 的对象。 主要用在需要安全的环境（禁止 this 和 new），或者在防止数据被其他程序（如 Mashup）改动时使用。 1234567891011121314151617function Person(name, age, job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); // 注意：这里没有使用 this，因此我的理解是相当于闭包，保存住了外部 Person 的 AO（活动对象） &#125;; //返回对象 return o;&#125;var person = Person(\"steve\", 24, \"web developer\");person.sayName(); //\"steve\" 这里变量 person 中保存的就是一个稳妥对象，因为除了调用 sayName() 方法以外，没有别的方法可以访问内部的数据。 即使有其他代码会给这个对象添加方法或数据，也无法访问传入到构造函数中的原始数据。 6.3. 继承许多面向对象的编程语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 在 ECMAScript 中由于函数没有签名，所以无法实现接口继承，只支持实现继承，而这正是依靠「原型链」来实现的。 6.3.1. 原型链既然这继承的关键在于「原型链」，我们就先来了概（解）下原型链的概念究竟是神马… 基本思想：利用 prototype（原型对象），让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下之前讨论过的关于，构造函数、原型对象和实例的关系： 每个构造函数都有一个指向自己原型对象的 prototype 指针。 原型对象又都包含一个指向构造函数的 constructor 指针。 实例都包含一个指向原型对象的 [[prototype]] 内部指针（__proto__）。 假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？ 123456function foo() &#123;&#125;function bar() &#123;&#125;var a = new foo(); // a 是父类 foo 的实例bar.prototype = a; // 「原型对象 bar.prototype」等于另一个类型的「实例 a」var b = new bar(); // b 是子类 bar 的实例 简单分析一下以上代码： 「1」a 作为 foo 的实例，a 的内部指针 [[prototype]] 指向原型对象 foo.prototype。 「2」bar.prototype 被赋值为 a，所以相当于 bar.prototype 有内部指针 [[prototype]] 指向原型对象 foo.prototype。 「3」b 作为 bar 的实例，b 的内部指针 [[prototype]] 指向原型对象 bar.prototype。 「4」综上，这样便形成了一条：b -&gt; bar.prototype -&gt; foo.prototype 的原型链。 「5」假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，可以生成更长的原型链。 以上就是原型链的基本概念… 下面再来看看一种实现原型链的基本模式 12345678910111213141516171819202122function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); // true，成功继承父类原型对象上的方法alert(instance.constructor); // SuperType，因为访问的是 Super.prototype 中的 constructor 1. 别忘记默认的原型其实，所有的引用类型都默认继承自 Object，而这个继承也是通过原型链实现的。所以所有自定义类型都能够使用 toString()、valueOf() 等方法。 2. 确定原型和实例的关系有两种方法确定原型和实例的关系： instanceof 操作符 isPrototypeof() 方法 1234567alert(instance instanceof Object); // truealert(instance instanceof SuperType); // truealert(instance instanceof SubType); // truealert(Object.prototype.isPrototypeof(instance)); // truealert(SuperType.prototype.isPrototypeof(instance)); // truealert(SubType.prototype.isPrototypeof(instance)); // true 3. 谨慎地定义方法子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，这点很好理解。 还要注意以下这种使用对象字面量创建原型方法的情况。 1234567891011121314// blabla...SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 隐式地创建了一个新对象，改写了 SubType.prototype 的指针指向SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;; 4. 原型链的问题 引用类型属性的问题：相当于将父类属性添加到子类原型对象上形成共享。 创建子类实例时，不能向超类型的构造函数中传递参数：准确的说是无法在不影响所有对象实例的情况下，给父类的构造函数传递参数。 6.3.2. 借用构造函数在解决原型链以上问题的过程中，产生了一种叫做「借用构造函数（伪造对象、经典继承）」的技术。 基本思想是：在子类构造函数内部调用父类构造函数，主要通过 call() 和 apply() 方法实现。 1. 传递参数相对于原型链而言，借用构造函数最大的优势就是解决了传递参数的问题。 12345678910111213function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, 'steve'); this.age = 24;&#125;var instance = new SubType();alert(instance.name); // stevealert(instance.age); // 24 2. 借用构造函数的问题源自于构造函数的问题：方法都在构造函数中定义，无法函数复用，子类方法也无法使用父类原型对象中的方法。 6.3.3. 组合继承顾名思义，就是将原型链和借用构造函数结合。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; return this.name;&#125;;function SubType(name, age) &#123; // 借用构造函数继承属性 SuperType.call(this, name); this.age = age;&#125;// 使用原型链继承了方法SubType.prototype = new SuperType(); 虽然看起来结合了两者的优点，既能够传递参数，又能实现原型链继承，但是应该注意到 SubType.prototype = new SuperType(); 一句。 我们的预期只是子类 SubType 拥有父类的属性，即 SuperType.call(this, name); 的工作。 但是 SubType.prototype 上也拥有了一个值为 undefined 的 name 属性和 colors 数组。这不是我们的本意，这就是直接使用 new 操作符将父类实例赋值给子类原型对象的副作用╮(╯▽╰)╭。 要解决组合模式存在的问题，首先来看几个其他方式的继承。 6.3.4. 原型式继承由 Douglas Crockford（又是你→_→）在2006年的一篇文章中介绍，基本思想是：基于已有对象，借助原型创建新对象。 1234567function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 即先创建一个临时性的构造函数 F，然后将传入的对象 o 作为这个构造函数的原型 F.prototype，最后返回这个临时类型的一个新实例 new F()。从本质上将就是对于传入的对象 o 进行了一次浅复制。 1234567891011121314var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = object(person);anotherPerson.name = \"young\";anotherPerson.friends.push(\"sasuke\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"nicholas\";yetAnotherPerson.friends.push(\"jobs\");alert(person.friends); // shirley,jame,sasuke,jobs，friends 被共享了 ES5 中新增了 Object.create() 方法规范化了原型式继承。可以接收两个参数，第一个参数就是要继承的对象，第二个对象是可选的一个为新对象定义额外属性的对象。其实只传一个参数时，两个方法行为相同。 第二个参数与 Object.defineProperties() 方法的第二个参数格式相同（覆盖同名属性），见下例。 12345678910111213var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = Object.create(person, &#123; name: &#123; value: \"greg\", configurable: false &#125;&#125;);alert(anotherPerson.name); // greg 6.3.5. 寄生式继承基本思路类似用工厂模式包装原型式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回该对象。 123456789101112131415161718var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;function createAnother(original) &#123; var clone = object(original); // 原型式继承对象 original // 增强对象 clone.sayHi = function() &#123; alert(\"Hi\"); &#125;; return clone; // 返回对象&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // Hi 6.3.6. 寄生组合式继承首先实力吹一波：作为压轴出场的终极继承方式，几乎是最理想的继承范式。 前面在介绍组合继承的时候说到了主要问题出在 SubType.prototype = new SuperType(); 这句。它将父类构造函数中的属性也添加到了子类原型对象中，而这不符合我们的期望。 其实让我们回到需求本身：我们希望子类的原型对象能够指向父类的原型对象，实现原型链继承。 那么想一想 6.3.4. 原型式继承，我们让子类原型式继承父类的原型对象不就完美了么？ 12345678910111213141516171819202122232425262728function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数，继承父类属性（解决了传参） this.age = age;&#125;SubType.prototype = Object.create(SuperType.prototype, &#123; constructor: &#123; value : SubType, // 指回子类构造函数 enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, &#125;&#125;);// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; 6.4. 小结创建对象 工厂模式：简单地在函数内部创建对象，添加属性和方法，然后返回对象。 构造函数模式：在函数内部使用 this 添加属性和方法，可以创建自定义引用类型，可以使用 new 操作符创建实例。但是无法实现函数复用，造成内存浪费等问题。 原型模式：使用构造函数的 prototype 属性来指定共享的属性和方法，本质上就是为了共享而生。 组合模式：结合构造函数和原型模式的优点。 对象继承 原型链：将父类的实例赋值给子类构造函数的原型对象。但这样会有两个问题：传参和子类原型上有多余的父类构造函数中的属性。 借用构造函数：为了解决传参问题，采用在子类中调用父类构造函数的方法。 原型式：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。 寄生组合式：巧妙利用原型式继承解决原型链中的第二个问题，是基于类型继承的最好方式。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「4」Byrs-News 建站笔记（一）","date":"2016-03-16T03:27:58.000Z","path":"2016/03/16/4.byrs-news notes 1/","text":"零、前言差不多结束了在移动研究院快一年的实习，加上马上到来的寒假，想着闲着也是闲着不然做个网站练练手吧╮(╯▽╰)╭ 于是在寒假里就捣鼓了这么个网站 Byrs-News | 开源地址，主要内容是通过爬虫 Byr-Crawler 对于北邮人论坛帖子进行定时爬取，在收集整理之后希望大家能够更加“优雅地”浏览论坛～=￣ω￣=～。 一、技术栈 网站采用了 Meteor.js 全栈式开发 数据库选择了 MongoDB 进行存储 内容获取来自自己编写的 Node.js 爬虫 那么首先问题来了… 1.1. Meteor 是个什么玩意儿？Meteor 是一个只使用 JavaScript 就可以开发 Web 和移动端应用的全栈框架。主要特点有： 一种语言(One Language)：JavaScript（就可以搞定服务器、浏览器、移动设备）。 传递数据(Data on the wire)：服务器和客户端之间传递的是数据（而不是 html），由客户端进行数据的渲染。 无处不在的数据库(Database everywhere)：从客户机或服务器上使用相同、透明的 API 访问数据库。（在浏览器端实现了 Minimongo） 延迟补偿(Latency Compensation)：使用预读和模式模拟技术，使之看起来与数据库的连接是零延迟的。 全栈响应式(Full Stack Reactivity)：代码所依赖的数据发生变化时，结果 会自动重新计算。（并不是指响应式） 拥抱生态(Embrace the Ecosystem)：开源、与现有工具和框架整合，而不是取代。 简单等于生产力(Simplicity Equals Productivity)：让一件事看起来简单的最佳方式就是「真正」让它变得简单。 我的感受是使用 Meteor.js 可以在只用一种语言（JavaScript）的情况下，「超快速」地开发出一个功能完善的现代网站。 还有疑问？Take it easy.且看我后文慢慢道来… 1.2. 为什么选择 MongoDB？ 首先当然是因为它是 Meteor 的默认数据库呀╮(╯▽╰)╭ 其次作为一个 NoSQL 数据库比传统关系型数据库更加灵活，更加适用于互联网应用场景 我可以在爬虫运行过程中可以更加方便地修改文档结构 … 1.3. 为什么是 Node.js 爬虫？因为正好最近在学习 Node.js，还有保持项目只有一种语言。 二、项目规范2.1. 命名规范 文件夹和文件采用小写字母，用下划线 _ 连接。 JavaScript 文件中的内容采用驼峰命名法（因为毕竟它自己就是用的驼峰╮(╯▽╰)╭）。 CSS 文件中的内容采用连字符 - 连接（因为本来 CSS 语法就是用连字符，如 font-family 等）。 2.2. 文件夹规范由于是一个全栈式框架（代码写一块儿╮(╯▽╰)╭），所以文件夹的名字十分地重要。因为会影响 Meteor 对其加载的顺序（见下文）。 一般来说有在顶级项目目录下有以下规范的命名： client/ : 放置所有的客户端代码，Meteor 也不会将其在服务端加载。 server/ : 放置所有的服务端代码，Meteor 也不会将其在客户端加载。 public/ : 放置静态资源，例如 favicon.ico, robots.txt 等。 node_modules/ : Node.js 模块代码。（比如 cz-conventional-changelog） tests/ : 本地测试代码。 private/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） client/compatibility/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） lib/ : 放置服务端和客户端共用的代码，比如 config.js、数据库文件夹 collections/。 加载顺序（了解即可） 应用根目录内 lib 文件夹下的文件首先加载。 符合 main.* 这个格式的文件最后加载。 子目录中的文件在母目录中的文件之前加载，即最深层子目录中的文件首先加载（在 lib 之后），根目录的文件最后加载（在 main.* 之前）。 同目录下的文件，按文件名的字母顺序来加载。 三、重要参考资料 官网 官方快速入门教程: 学习点这 StackOverflow: 碰到问题点这 官方论坛 Github","tags":[{"name":"meteor","slug":"meteor","permalink":"https://buptsteve.github.io/blog/tags/meteor/"}]},{"title":"「3」前端开发利器 webpack","date":"2015-12-29T07:12:58.000Z","path":"2015/12/29/3.js-webpack/","text":"零、前言在编写构建前端项目时，以下这些需求想必十分常见： html/css/js 代码的预编译： Jade, Ejs… Sass, Less, Stylus… Dart, CoffeeScript, TypeScript, ES6/7… 拯救你的 F5 或者 Command/Ctrl + R（即自动监听、编译并刷新浏览器） 发布时的代码压缩、混淆，图片的压缩和 base64 嵌入 以上这些「体力♂活儿」显然不能自己浪费时间手动完成，所以优雅的解决方式就是：自动化构建工具～！ 话说我最早了解到前端自动化构建工具，是通过慕课网学习的时候看到的 grunt 教程，随意浏览了点儿发现上手有点儿难 _(:зゝ∠)_ 同时也没有什么需求就没有学下去。 然后学习了 less/sass/stylus 等预编译语言，先是使用了 koala 进行 less 文件的编译。之后又有了「拯救 F5」的需求，觉得再使用 livereload 这样不够绅士(´･ω･`)。于是开始学习 gulp， gulp 是基于 Unix 的哲♂学，即 Do one thing and do it well. 类似于 Unix 的管道命令（pipe：| ），gulp 基于 Node.js 中的 stream 机制。Gulp 的每个插件从 stream 中读取输入，做一些处理，再输出到 stream 中。同时使用 browser-sync 插件能够解决我的重复刷新的繁重劳动。 无奈前端变化太快_(:зゝ∠)_，使用 gulp 没多久。通过 vue.js 一个 MVVM 框架，知道了 webpack 这一新的前端自动化构建工具。使用 webpack 可以方便地将 *.vue文件编译打包到工程中，并且 react 的大部分项目也使用 webpack 进行构建。那么问题来了，webpack 究竟靠什么火起来了呢？ 一、webpack1.1. 为什么选择 webpack ? 参考链接a. 模块化首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？ 答案只有一个：模块化开发！ 然而浏览器本身并不提供模块管理的机制（ES6 终于引入 Module），为了调用各个模块，有时不得不在网页中，加入一大堆script标签。这样就使得网页体积臃肿，难以维护，还产生大量的HTTP请求，拖慢显示速度，影响用户体验。 在此对于模块化就不继续展开了…Require.js/Sea.js/Common.js/AMD/CMD/ES6…etc. b. 代码传输明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？ 有两种「极端」的方式： 每一个请求传送一个模块（类似于一堆的 &lt;srcipt&gt; 标签…） 一个请求传送所有模块（例如 browserify 的打包方式） 这两种方式方式各有优缺点： 一个请求一个模块 优点：只加载需要的模块； 缺点：大量请求会使得启动缓慢… 一个请求所有模块 优点：请求数少，等待时间少； 缺点：不需要的模块同样被传送了… 因此，在大多数的情况下最佳实践应该是一个折中的方案： 在编译所有模块时，将模块细分成为多个小的 batches(chunks)，于是我们分解得到了许多请求。模块的 chunks 初始状态时并没有全部加载，只在需要的时候发起请求。因此初始请求不会包含所有的代码，显然加载的代码量更小，速度更快。 其中关键的「分割点」即 chunks 的划分边界，是取决于开发者并且是可选的。 c. 模块热替换（HMR）此外还有一个重要原因：webpack 支持模块热替换（HMR）（例如 react-hot-loader） 针对浏览器自动刷新，LiveReload 和 Browser-sync 是两款常用的工具，然而 HMR 更进了一步。我们知道 React 出现的原因之一就是积累用户在浏览器中的状态，而 HMR 能够在修改代码保存之后仍然保存之前的状态，就是俗称的「热替换」。 1.2. 怎么使用 webpack？了解了为什么（why）之后，接着学习怎么做（how）。 a. webpack 的安装 首先使用 npm 全局安装 webpack： 1$ npm i(nstall) -g webpack 接着局部安装 webpack： 1$ npm i(nstall) --save-dev webpack b. webpack 的配置 官方文档 Pete Hunt webpack 配置的本质就是：一个配置的 Object。 因此有两种使用方法配置 webpack: 一种是 Cli（即 Command Line Interface）方法：读取 webpack.config.js 文件； 另一种是 Node.js API 的方法：传递配置对象作为参数。 前端一般使用第一种，即配置 webpack.config.js 文件，简单例子如下： 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 就是设置入口、出口文件，炒鸡简单有木有~ 接着我们需要进行一些预编译工作，例如把 CoffeeScript 或 ES6 的代码编译为 ES5 的 JavaScript，例子如下： 12345678910111213141516// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader' &#125;] &#125;&#125;; 只需要加入 loader，loader 中的 test 表示哪些文件需要经过 loader 进行处理。 对于 css 和 图片资源同样也有 loader，这样就可以像引用 js 一样在代码中引用，例如： 12345require('./bootstrap.css');require('./myapp.less');var img = document.createElement('img');img.src = require('./glyph.png'); loader 的编写类似于之前的例子：（!用于链式操作，且从右往左执行） 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; path: './build', // This is where images AND js will go publicPath: 'http://mycdn.com/', // This is used to generate URLs to e.g. images filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' &#125;, // use ! to chain loaders &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; // inline base64 URLs for &lt;=8k images, direct URLs for the rest ] &#125;&#125;; last but not the least: 添加 webpack-dev-server 作为实时代码更新安装完成后只需添加两行代码到 webpack.config.js 中： 123456789module.exports = &#123; ... entry: [ 'webpack-dev-server/client?http://0.0.0.0:8080', 'webpack/hot/only-dev-server', './app/main.js' ], ...&#125;; 并且在 package.json 中的 scripts 添加一行代码： 12345&#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval --progress --colors --hot --content-base build\" &#125;,&#125; 这样在日常开发中只需要执行： 1$ npm run dev 在浏览器中访问 http://localhost:8080 即可看到编译结果，并且更改代码后能够自动刷新。","tags":[{"name":"效率","slug":"效率","permalink":"https://buptsteve.github.io/blog/tags/效率/"},{"name":"webpack","slug":"webpack","permalink":"https://buptsteve.github.io/blog/tags/webpack/"}]},{"title":"「2」如何搭建自己的服务器？","date":"2015-11-03T05:04:58.000Z","path":"2015/11/03/2.centos-server/","text":"零、问题的由来？平时逛 北邮人论坛 看到各种大神做的各种作品，技痒难耐，也想自己捣鼓捣鼓、学习服务器。正好实验室有空闲电脑，就自己搭一个玩儿啦～。在纠结半天，看了好多资(si)料(bi)后，决定选用 CentOS 作为操作系统， 主要开发环境为 Python 和 Node.js。 一、系统安装（怎么获取镜像就不赘述了～） 利用 ultraISO 将镜像文件拷入 u 盘内 设置 BIOS，优先从 u 盘启动 按照步骤安装… 二、网关问题由于北邮校内使用 ipv4 流量需要登录网关，下面介绍两种方法： 2.1. VNCCentOS 可以使用 tigervnc，使用 yum 即可安装： 12$ yum install tigervnc$ yum install tigervnc-server 安装完成后，使用命令vncserver :n 打开相应端口n（这里的n是sessionnumber，不指定默认为1，也可以是2、3等等。第一次会提示输入密码，以后可以使用vncpasswd命令修改密码。） 当然别忘了设置 iptables…小白就 iptables -F 吧 之后就可以从本地 vncviewer 连接啦… 2.2. 命令行（推荐）网关登录还可以使用 curl 命令： 登录： 1$ curl -d 'DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey=' 10.3.8.211 注销： 1$ curl 10.3.8.211/F.htm 还可以写入命令行的 alias 中 12345$ vi ~/.bashrc (这里看你具体用的啥)# 添加以下 aliasalias ibu='curl -d \"DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey=\" 10.3.8.211 &amp;&amp; clear'alias obu='curl 10.3.8.211/F.htm &amp;&amp; clear' 这样要登录网关只需要输入 ibu，同理退出就是 obu。 三、Python 3 环境由于 CentOS 自带 Python 为 2.7.5 版本（最好不要卸载，因为会被 yum 使用），而我日常使用 3.0+ 所以需要更新 Python 版本。下面介绍一种两个环境共存的方法（以 3.5 版本为例）： 1$ wget https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz 下载 Python 3.5.0 ，之后解压，安装… C Complier问题：在上一步安装 Python3 的过程中执行 ./configure 时报错，原来是没有 C Complier… 1$ yum install gcc 继续安装 Python3 123$ ./configure --prefix=/opt/python3$ make$ sudo make install 验证是否安装成功 1$ /opt/python3/bin/python3 -V 重要事项！ 由于此种方法仍保留了原系统中的 Python2 ，因此别忘了在自己编写的 Python3 脚本中加入 1#!/opt/python3/bin/python3 即，选择 python3 进行解析。 四、Node.js 环境4.1. 安装推荐使用 nvm 进行安装和版本切换。 4.2. 仓库问题由于 GFW 的原因，可能使用自带 registry 会太慢或者失败，因此可以试试以下解决方案 推荐一个切换仓库的 npm 包 nrm 1$ npm i(nstall) -g nrm nrm 使用介绍12345678910111213141516// 列出可用仓库$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - http://registry.npm.taobao.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ pt ----- http://registry.npmjs.pt/// 切换仓库到 cnpm$ nrm use cnpm Registry has been set to: http://r.cnpmjs.org/ 当然嫌麻烦可以直接用 淘宝 npm 镜像 3. 切换 Node.js 版本直接使用 nvm 或者 tj 的作品 n 1$ npm i(nstall) -g n 使用介绍12345678910111213// 安装 0.8.14/0.8.17/0.9.6 三个版本的 nodejs$ n 0.8.14$ n 0.8.17$ n 0.9.6// 选择版本（移动上下箭头，回车或右键头选择，Ctrl+C 取消）$ n 0.8.14ο 0.8.17 0.9.6// 删除 0.9.4 版本$ n - 0.9.4","tags":[{"name":"Linux","slug":"Linux","permalink":"https://buptsteve.github.io/blog/tags/Linux/"},{"name":"Server","slug":"Server","permalink":"https://buptsteve.github.io/blog/tags/Server/"},{"name":"Python","slug":"Python","permalink":"https://buptsteve.github.io/blog/tags/Python/"},{"name":"Node.js","slug":"Node-js","permalink":"https://buptsteve.github.io/blog/tags/Node-js/"}]},{"title":"「1」优雅地打开软件是怎样的体验？","date":"2015-11-01T11:04:58.000Z","path":"2015/11/01/1.the-way-to-open-software/","text":"零、问题的由来不知道大家平时是怎么打开常用软件的： 1. windows 用户 从桌面上一堆杂乱的文件中找到快捷方式双击打开？ 从桌面上分类整理好的文件夹中找到快捷方式双击打开？ 或是更进一步地利用 Fences 从桌面选择？ 利用 Everything 进行文件名搜索？ win8下的 Metro，win10下的 blablabla… 2. OS X 用户 通过在 Dock 中寻找后，单击打开？ 通过拇指与其他三个手指合拢进入 Launchpad 后，单击打开？ 利用自带的 spotlight 或者 alfred 等工具输入软件名打开？ 通过终端… 3. linux 用户 通过终端… 要啥自行车…╮(╯▽╰)╭… (才不会告诉你是因为我不造呢…) 一、我的选择 (私のchoice)1.1. OS X 下通过 ctrl + space 唤起 alfred ，之后输入软件缩写，点击回车或 cmd + n打开软件。(btw 可以将 Application 中的各个 app 的名字重新命名缩写过，比如将 网易云音乐 缩写成 wyy) 1.2. windows 下1.2.1. 自带的运行就是那个 win + r ，不过为了保持与 OS X 操作的一致性利用了AutoHotkey 将其统一修改为 ctrl + space。 具体的配置文件是 点我 中的 autohotkey/steve.ahk 1.2.2. 然后呢？还需要2步设置：(居然比把大象放冰箱还少一步啊喂！) 将 (桌面上或者其他地方的) 软件快捷方式改名缩写成2~3个字母 把该快捷方式 duang～ 地一声剪切到 C:\\Windows 下，搞定收工～=￣ω￣=～ 不过有的软件比如 Github.appref-ms 这种格式的就没办法通过以上方法快速打开了。这时候就又要推荐一个好用软件啦：Rolan，将快捷方式或其他的文件/文件夹拖进去就ok。要使用的时候就通过快捷键呼叫出 Rolan 后即可打开。 二、综上无论何时，无论当前层叠了多少窗口…只需要: 按下 Ctrl + Space 输入缩写过的 2~3 个字母的软件名称 按下 Enter 确认 Duang～一下就优雅地把软件打开了~\\(≧▽≦)/~","tags":[{"name":"效率","slug":"效率","permalink":"https://buptsteve.github.io/blog/tags/效率/"}]},{"title":"「0」Hello World","date":"2015-10-29T11:04:58.000Z","path":"2015/10/29/0.hello-world/","text":"零、Blog的由来作为一个学计算机的，一直想整个自己的 Blog，尤其是最近在搞前端。先是看到 jekyll 感觉不错，折腾了半天感觉还是不够给力。最后还是选择了 hexo3。 主要是这几个优点吧： 免费╮(╯▽╰)╭ 基于 Node.js 速度快、操作更简单、命令少，专注于写作本身 由于 deploy 命令，发布到 github 上生成静态站点也很简单 所以整个 Blog 就是采用 hexo3 + github pages,主题基于 indigo 进行修改，下面就详细说说怎么搭起来吧… 一、hexo的安装首先由于 hexo 是基于 Node.js 开发的，所以我们先要安装 Node.js 环境，进入Node.js官网，一般会发现有两个版本：LTS 和 Stable。 这两个版本的区别在于一个是 LTS 长期支持版（也是推荐选项），另一个是拥有最新功能的稳定版（适合有新功能需求的尝鲜用户）。 安装完成后，在命令行运行以下命令（其中括号的意思是 install 可以缩写为 i）： 1$ npm i(nstall) -g hexo npm 安装方式中 -g 的意思是全局安装。 二、初体验~2.1. 生成项目找到一个合适的位置，创建我们的项目文件夹： 一般的用户：自己图形界面新建了一个,然后点进去 命令行用户：mkdir &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; hexo的用户：hexo init &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; 2.2. 安装依赖1$ npm i(nstall) npm 就会自动根据 package.json 中的配置自动进行安装 2.3. 运行预览12$ hexo g(enerate)$ hexo s(erver) 如果这步报错一般是因为没装 hexo-server，运行以下命令安装即可： 1$ npm i(nstall) --save hexo-server npm 安装方式中 –save 的意思是作为项目依赖(dependencies)进行安装，可以缩写为 -S (注意大写)此外还有 –save-dev 的意思是作为项目的「开发」依赖(devDependencies)进行安装，可以缩写为 -D (注意大写)这两种安装方式都会将这个包的名称和版本写进 package.json 配置文件中 最后打开浏览器输入http://localhost:4000就可以看到页面啦～ 三、换主题（theme）然而只是使用默认的主题（theme）怎么会有逼格→_→，果断要整一个吊炸天的主题呀~，下面以 indigo 为例作为说明。 3.1. 下载主题首先在项目目录下（就是说有个 themes 的文件夹），执行以下命令，将主题下载到 themes 文件夹下的 indigo 文件夹中。 1$ git clone https://github.com/yscoder/hexo-theme-indigo themes/indigo 3.2. 配置使用主题接着修改 _config.yml（项目的配置文件，不是主题的） 将 theme 改为 indigo 四、部署到 github pages4.1. 安装 hexo-deployer-git1$ npm i(nstall) hexo-deployer-git --save 4.2. 关于 github pages4.2.1. 分类1. 项目站点（Project Pages）github 会根据 gh-pages 分支下文件生成静态页面，地址是 [yourName].github.io/[projectName]。（[yourName] 是你的账户名，[projectName] 是你的项目名） 2. 个人或公司站点（User/Organization Pages）首先要创建一个叫做 [yourName].github.io 的项目，接着 github 会根据 master 分支下文件生成静态页面，地址是 [yourName].github.io/。 4.2.2. 一些坑… 有的主题中各种静态文件路径是写死的，比如好多主题中的文件引入是针对第二类页面写死的。 有些主题中的 CDN 资源被墙，那就需要找到这些文件手动修改地址╮(╯▽╰)╭。 4.3. 修改 _config.yml 文件官方文档中是这么介绍的 1234567891011121314# You can use this:deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message]# or this:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 123* repo: Repository URL* branch: Git branch to deploy the static site to* message: Commit message. The default commit message is Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;. 根据 4.2. 所述，部署部分的填写也分为两种情况： 1. 个人或公司站点 repo：填写项目地址，例如 git@github.com:BuptStEve/BuptStEve.github.io.git branch：填写 master 2. 项目站点 repo：填写项目地址，例如 git@github.com:BuptStEve/blog.git branch：填写 gh-pages url：https://buptsteve.github.io/blog/ （注意最后的 /） root：/blog/ （注意最后的 /） 4.4. 开始部署首先生成站点文件 1$ hexo g 接着发布 1$ hexo d(eploy) 最后打开对应地址就可以看到自己的博客啦～=￣ω￣=～。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://buptsteve.github.io/blog/tags/hexo/"}]}]