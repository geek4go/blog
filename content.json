[{"title":"「6」JavaScript 函数表达式学习笔记","date":"2016-03-23T07:27:58.000Z","path":"2016/03/23/6. js-function-chapter7/","text":"零、前言《JavaScript 高级程序设计（第三版）》第7章 函数表达式，学习笔记整理。 主要内容有如下三部分 函数表达式的特征 使用函数实现递归 使用闭包定义私有变量 一、第7章 函数表达式7.0. 函数定义在 JavaScript 中定义函数有两种方法： 函数声明 函数表达式 7.0.1. 函数声明123456function functionName(arg0, arg1, arg2) &#123; // 函数体&#125;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // functionName，函数名称 函数声明一个重要特征就是：函数声明提升（function declaration hoisting），简单来说就是 JS 引擎会在执行阶段之前读取函数声明，这就是我们才能够在函数声明之前就调用它的原因。 7.0.2. 函数表达式1234567// 有多种形式，以下为最常见的一种，即创建一个匿名函数并将其赋值给变量 functionNamevar functionName = function(arg0, arg1, arg2) &#123; // 函数体&#125;;// 只在 Firefox、Safari、Chrome 和 Opera 有效alert(functionName.name); // 空字符串 当然函数表达式就没有声明提升这种特征了╮(╯▽╰)╭。以下是一个比较常见的坑… 123456789101112131415161718192021222324252627// 千万别这样做！// 因为有的浏览器会返回 first 的这个 function，而有的浏览器返回的却是第二个if (true) &#123; function foo() &#123; return 'first'; &#125;&#125;else &#123; function foo() &#123; return 'second'; &#125;&#125;foo();// 相反，这样情况，我们要用函数表达式var foo;if (true) &#123; foo = function() &#123; return 'first'; &#125;;&#125; else &#123; foo = function() &#123; return 'second'; &#125;;&#125;foo(); 7.1. 递归 先说个段子：要想理解递归，首先要理解…递归。 说正经的，递归就是函数自己调用自己。 123456789101112function factorial(num) &#123; if (num &lt;= 1) &#123; // 递归结束条件 return 1; &#125; else &#123; return num * factorial(num-1); // 通过在全局 VO 中，找到自身函数的指针后调用自身 &#125;&#125;var anotherFactorial = factorial;factorial = null;alert(anotherFactorial(4)); // 报错！因为修改了全局 VO 中 factorial 指针的指向（null） 这么写主要问题就是递归函数与自身的函数名耦合，一旦修改了原本的函数名，则会导致错误。这时可以利用 arguments.callee 指针来成功寻找到正在执行的函数。 但是，接下来又有一个坑：arguments 在严格模式下无法使用。 不过，可以使用命名函数表达式来解决： 12345678910var factorial = function f(num) &#123; if (num &lt;= 1) &#123; // 递归结束条件 return 1; &#125; else &#123; return num * f(num-1); // 函数名 f 只在内部作用域里有效 &#125;&#125;;typeof f; // undefined 7.2. 闭包 先下定义：闭包是指【有权】访问（另一个函数作用域）中的「变量」的「函数」。 闭包首先是一个函数 能力就是有权访问变量 范围在另一个函数作用域内 我们日常在使用 JavaScript 中，在外部函数中定义的内部函数能够访问外部函数中的变量。所以，最常见的闭包方式就是在一个函数内部创建并返回另一个函数。 123456789function foo(arg0, arg1) &#123; return function bar() &#123; return arg0 + arg1; // 内部的 bar 函数能够访问外部函数 foo 的 arg0 和 arg1 变量。 &#125;&#125;var test = foo('a', 'b'); // test 是一个指针，指向返回的 bar 函数test(); // ab，调用闭包后，得到 arg0 + arg1 的值typeof bar; // undefined，当然返回的是一个匿名函数 那么内部的 bar 函数是怎么保存外部 foo 函数的两个参数的呢？ 首先在浏览器端的 JavaScript 代码，有一个全局的执行环境（Execution Context）即 window 对象。 每个执行环境都有一个对应的变量对象（Variable Object）：定义的所有变量和函数都保存其中。 当某个函数被调用时，会创建一个执行环境（EC）及相应的作用域链（Scope Chain）（其实是被推入一个环境栈中，执行之后栈将之弹出）。 作用域链（SC）就是一个指向各个变量对象的指针列表（全局 VO 是其中的最后一个对象）。 一般来说某个执行环境（EC）的所有代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。 如果执行环境是一个函数，那么它的变量对象（VO）又叫做活动对象（Activation Object）。 因此在一个函数中解析标识符的过程，类似于上一篇中提到的原型链查找。也是沿着 SC 一级一级地往上找。如果直到全局 VO 还没找到，就会报错。 所以接下来举几个栗子： 1. 普通函数1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var result = compare(5, 10); 1234567891011121314 ______________________________________________________________ | | V _____________________ | _____________________ _________________ |--&gt; | global VO | | |---&gt;| compare AO || compare EC | | |---------------------| | | |---------------------||-------—---------| _______ | | compare | *----|--| | | arguments | [5, 10] || Scope Chain | *-|----&gt; | SC | | |---------------------| | |---------------------||-----------------| |-------| | | result | undefined | | | value1 | 5 | | 1 | *-|----| |---------------------| | |---------------------| |-------| | | value2 | 10 | | 0 | *-|----------------------------------------| |---------------------| |-------| by 灵魂画师...(累死我了) 在创建 compare 函数时，就已经创建一个预先包含全局 VO 的作用域链（保存在内部的 [[Scope]] 属性中）。 在执行 compare 函数时，就创建 EC，然后复制并构建 [[Scope]] 属性中的作用域链 SC 此时创建 compare AO，并将其放入 SC 的顶端。 所以在函数中访问一个变量时，会从作用域顶端（就是 compare AO）开始找起。 所以一般一个函数执行完毕后，因为 AO 被销毁，所以在函数外部无法访问到函数内部的变量。 2. 闭包示例123456789101112131415161718192021function createCompFunc(propName) &#123; return function(obj1, obj2) &#123; var value1 = obj1[propName]; var value2 = obj2[propName]; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;var compare = createCompFunc(\"name\"); // 创建函数var result = compare(&#123;name: \"steve\"&#125;, &#123;name: \"young\"&#125;); // 调用函数compare = null; // 解除对匿名函数的引用（释放内存） 1234567891011121314151617181920212223242526 __________________________________________________________________ | _____________________ | | |-----&gt; | global VO | | | | |---------------------| | | | | createCompFunc | *--|--| | | |---------------------| V | | result | undefined | ___________________ _______ | |---------------------|| createCompFunc EC | |---&gt; | SC1 | | ______________________|-------—-----------| | |-------| | |---&gt; | createCompFunc AO || Scope Chain | *--|------| | 1 | *-|-| | |----------------------||-------------------| |-------| | | | arguments | [\"name\"] | | 0 | *-|-(-| |----------------------| ________________________ |-------| | | | propName | \"name\" || anoymous function EC | | | |----------------------||-------—----------------| _______ | | _______________________________| Scope Chain | *-----|-----&gt; | SC2 | | | |-&gt; | anoymous function AO ||------------------------| |-------| | | | |-------------------------------| | 2 | *-|-| | | | arguments | [&#123;name: \"steve\"&#125;, | |-------| | | | | &#123;name: \"young\"&#125;] | | 1 | *-|---| | |-------------------------------| |-------| | | obj1 | &#123;name: \"steve\"&#125; | | 0 | *-|-----| |-------------------------------| |-------| | obj2 | &#123;name: \"young\"&#125; | |-------------------------------| by 灵魂画师...(累死我了) 如图所示，首先看全局变量对象（global VO），其中有一个指针指向 createCompFunc 函数，还有一个声明提升后还未计算完毕的 result 等变量。 首先执行外部的 createCompFunc 函数，创建了它的 EC，其中有一个作用域链指针指向它的作用域链 SC1。 那么显然 SC1 中会有两个指针，分别指向 createCompFunc AO 和 global VO（这就是在函数内部能够访问到全局变量的原因）。 在 createCompFunc AO 中存放的就是函数内部定义的变量。 最后来看 createCompFunc 函数内部返回的匿名函数，当然它也有自己的执行环境 EC，也有自己的作用域链 SC2。 只不过由于它是 createCompFunc 函数内部的函数，当然它也能访问外部 createCompFunc 函数定义的变量，这正是因为 SC2 中位于第二的指针指向 createCompFunc AO（这就是闭包的原理）。 更为重要的是，在 createCompFunc 函数执行完毕后，因为匿名函数仍然引用着 createCompFunc AO，所以其活动对象不会被销毁（这涉及到内存回收机制）。 从上述讨论我们可以清晰地看出：闭包的原理就是内部的函数仍然引用着外部函数的 AO，使得外部函数的 AO 仍然保存在内存中。所以我们可以通过将闭包设置为 null 来解除对该函数的引用，回收其占用的内存。 7.2.1. 闭包与变量下面我们来简单讨论下作用域链机制的副作用（坑）：闭包只能取得外部函数中任何变量的最后一个值。 先来看一个栗子： 1234567891011121314function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function() &#123; return i; // 希望保存不同的 i，但是最后 i 都是 10 &#125;; &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 10 其实很好理解，因为闭包在 SC 中保存的是一个指针而已，外部函数执行完毕后 AO 中的变量自然更新为最后一个值啦╮(╯▽╰)╭。 但是我们可以创建另一个立即执行的匿名函数强制让闭包的行为符合预期： 12345678910111213141516function createFunc() &#123; var result = []; for (var i = 0; i &lt; 10; i++) &#123; result[i] = function(num) &#123; return function() &#123; return num; &#125; &#125;(i); &#125; return result;&#125;var test = createFunc();alert(test[0]()); // 0 在这里我们相当于有3层函数。 中间那层的匿名函数有一个参数 num，我们将 i 传入立即执行。 因为简单类型是按值传递的，所以中间那层的匿名函数的 AO 中 num 保存的是不同的 i。 而最内层的匿名函数读取的正是中间层匿名函数的 AO。 7.2.2. 关于 this 对象我们知道，this 是在运行时根据函数的执行环境动态绑定的： 在全局函数中，this 等于 window。 而函数被作为某个对象的方法调用时，this 又指向那个对象。 使用 call() 和 apply() 方法时，this 又会指向传入的那个对象（还有 bind()）。 不过，匿名函数的执行环境具有全局性，因此内部的 this 通常指向 window，见下例： 12345678910111213var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); // The Window (非严格模式下)，此处有两个括号，因为 object.getNameFunc() 是一个匿名函数，后一个括号是匿名函数调用。 为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？ 前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。而内部函数在搜索这两个变量时，只会搜索到其 AO 为止，所以永远不能直接访问到外部函数中的 this 和 arguments。 不过若是我们将外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问到该对象了： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function() &#123; var that = this; // 使用 that 保存外部函数的 this（防止被内部函数的 this 屏蔽） return function() &#123; return that.name; // 由于访问的是内部 AO 中没有的变量 that，所以在 SC 中外部的 AO 上搜索，得到外部函数的 this。 &#125;; &#125;&#125;;alert(object.getNameFunc()()); // My Object 接下来再看几个特殊的栗子： 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getName: function() &#123; return this.name; &#125;&#125;;object.getName(); // My Object，很好理解 this 就是指向 object(object.getName)(); // My Object，将函数包了起来，但还是通过 object.getName 调用，this 还是指向 object(object.getName = object.getName)(); // The Window(非严格模式下)，看起来很奇怪，将函数 getName 赋值为 getName，再调用赋值后的结果// 因为赋值表达式操作的是 getName 函数本身，所以 this 的值没有得到维持，调用时指向了 widnow。 7.2.3. 内存泄漏因为 IE9 之前对于 JScript 对象和 COM 对象使用不同的垃圾收集机制。所以如果闭包的作用域中保存一个 HTML 元素，那么该元素将无法被销毁╮(╯▽╰)╭。 7.3. 模仿块级作用域我们都知道在 ES6 之前是木有块级作用域的╮(╯▽╰)╭，在块语句中定义的变量实际上是定义在函数 AO 上的。 如果实在需要块级作用域，可以通过立即执行函数进行模拟。 1234// 这只是其中一种写法...重点是不要使用函数声明，这样由于声明提升会报错。(function() &#123; // 这里是块级作用域&#125;)(); 在一个大型程序中过多的全局变量和函数很容易造成命名冲突，这样可以有效减少在全局作用域中添加变量和函数。也可以说是模块化的基础。ps jQuery 源码中最外层函数就是这样的一个立即执行函数… 7.4. 私有变量严格来说，JavaScript 中没有私有成员的概念…╮(╯▽╰)╭，不过在任何函数中定义的变量，外部都无法访问到，可以认为是私有变量。 私有变量包括： 函数的参数 局部变量 内部定义的其他函数 那么如果我们需要访问这些私有变量该怎么办呢？在此就要引入一个概念：特权方法（privileged method）有权访问私有变量和私有函数的公有方法。 这个概念是不是和闭包炒鸡像！？ 其实有两种在对象上创建特权方法的方式，第一种就是利用闭包在构造函数中定义特权方法。基本模式如下： 123456789101112131415function MyObject() &#123; // 私有变量和函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 特权方法 this.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125; 但是，这样定义特权方法有一个问题：必须使用构造函数模式。而之前已经讨论过了构造函数会为每个实例都创建一组新方法，浪费内存，而接下来介绍的第二种方法，使用静态私有变量就可以避免这个问题。 7.4.1. 静态私有变量基本思想就是：在私有作用域（立即执行函数）中定义私有变量或函数，并在内部通过函数表达式定义构造函数和它的公有方法。基本模式如下： 12345678910111213141516171819(function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 构造函数 MyObject = function() &#123;&#125;; // 没有使用 var，所以是在 window 上创建（所以是非严格模式下）。 // 公有/特权方法 MyObject.prototype.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;;&#125;)(); 显然，通过上一篇对于对象继承的讨论我们知道：定义在原型对象上的属性和方法是所有实例共享的，而这些方法（如 publicMethod）所操作的对象，即私有变量和函数也是同一个。所以通过 MyObject 构造函数创造的实例都有权访问私有变量（而且是同一个），这就是静态私有变量。 7.4.2. 模块模式模块模式（module pattern）是为「单例」创建私有变量和特权方法。 那么问题来了，单例是啥？ 单例（singleton）指的就是只有一个实例的对象。比如 JavaScript 中就是以对象字面量来创建单例对象的。 123456var singleton = &#123; name : value, method: function() &#123; // 方法的代码 &#125;&#125;; 模块模式通过为单例添加私有变量和特权方法使其得到增强： 1234567891011121314151617181920var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 公有/特权方法 return &#123; publicProperty: true, publicMethod: function() &#123; privateVar++; return privateFunc(); &#125;; &#125;;&#125;(); 如上面代码所示，模块模式就是使用了一个返回对象的匿名函数： 在函数内部定义了私有变量和函数 然后将对象字面量返回。 因为对象是函数内部定义的，所以它的方法是一个闭包。 模块模式的应用场景主要是在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。 7.4.3. 增强的模块模式应用场景：单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其进行加强的情况。 12345678910111213141516171819202122var singleton = function() &#123; // 私有变量和私有函数 var privateVar = 10; function privateFunc() &#123; return false; &#125; // 创建对象 var object = new CustomType(); // 添加公有/特权属性和方法 object.publicProperty = true; object.publicMethod = function() &#123; privateVar++; return privateFunc(); &#125;; return object;&#125;(); 7.5. 小结1. 在 JavaScript 中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点： 函数声明必须要有名字，还会声明提升，而函数表达式不需要，没有名字的函数表达式又叫匿名函数 在递归函数中使用函数名调用自身可能会出现问题，如函数名发生了变化。 在递归函数中要掌握调用函数自身的技巧，如 arguments.callee 等。 2. 闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下： 在 JavaScript 引擎执行时，闭包的 SC 包含了自己的 AO、外部函数的 AO 还有全局 VO。 通常，函数的作用域和所有变量会在函数执行后被销毁。 但是，当函数返回了一个闭包时，外部函数的 AO 会一直保存在内存中，直到解除闭包的引用，如设为 null。 3. 使用闭包可以模仿块级作用域： 立即执行函数既可以执行其中的代码，又不会在内存中留下对该函数的引用。 所以函数内部的所有变量都会被立即销毁，除非将某些变量赋值给外部作用域中的变量。 4. 闭包还可以用于在对象中创建私有变量： 函数内部的变量、方法，外部无法访问。 但通过闭包可以实现公有方法，即访问在包含作用域中定义的变量。 有权访问私有变量的公有方法叫做特权方法。 可以使用构造函数模式、原型模式来实现自定义类型的特权方法。 也可以使用模块模式、增强模块模式来实现单例的特权方法。 综上：JavaScript 中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「5」JavaScript 面向对象深入理解","date":"2016-03-17T08:27:58.000Z","path":"2016/03/17/5. js-oo-chapter6/","text":"零、前言最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。 同样按照书本的顺序分为如下三部分 理解对象属性 理解并创建对象 理解继承 一、第6章 面向对象的程序设计6.1. 理解对象ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”简单来说，对象就是一些名值对（Key-Value），而对象的名字就是一个指针。 6.1.1. 属性类型ECMAScript 中有两种属性：数据属性和访问器属性。 6.1.2. 数据属性 [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表示能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Writable]]：表示能否修改属性的值，默认为 true。 [[Value]]：包含这个属性的数据值，默认为 undefined。 要修改以上属性，必须使用 ES5 中的 Object.defineProperty()。 12345678910111213141516171819202122232425// 例1var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; writable: false, value : \"steve\"&#125;);alert(person.name); // steveperson.name = \"abc\";alert(person.name); // steve// 例2var person = &#123;&#125;;Object.defineProperty(person, \"name\", &#123; configurable: false, value : \"steve\"&#125;);// 抛出错误Object.defineProperty(person, \"name\", &#123; configurable: true, value : \"steve\"&#125;); ps 在调用 Object.defineProperty() 方法时，默认值为 false(就是说其他没写的属性是 false)。 6.1.3. 访问器属性访问器属性不包括数据值(Value)，取而代之的是一对儿 getter 和 setter 函数(非必须)。 [[Configurable]]：表能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。 [[Enumerable]]：表能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。 [[Get]]：在读取属性时调用的函数，默认为 true。 [[Set]]：在写入属性时调用的函数，默认为 undefined。 访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。 12345678910111213141516171819var book = &#123; _year : 2004, edition: 1&#125;;Object.defineProperty(book, \"year\", &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; this.edition += newValue - 2004; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 ps 如果只定义了两个方法的其中之一，那么另一种方式则无法使用，例如只定义了 getter，则属性不可写。 6.1.4. 定义多个属性123456789101112131415161718192021var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2004 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(newValue) &#123; if (newValue &gt; 2004) &#123; this._year = newValue; &#125; &#125; &#125;&#125;);book.year = 2005;alert(book.edition); // 2 6.1.5. 读取属性的特性12345var desc = Object.getOwnPropertyDescriptor(book, \"_year\");alert(desc.value); // 2004alert(desc.configurable); // falsealert(typeof desc.get); // undefined 6.2. 创建对象使用 Object 构造函数和字面量创建对象，会产生大量重复代码，所以以下代码重用机制应运而生。 6.2.1. 工厂模式特点：使用函数封装特定接口创建对象的细节。简单来说就是在函数的内部创建对象，为其添加属性和方法后，将其用 return 返回，在实例化时不使用 new 操作符。 12345678910111213141516function createPerson(name, age, job) &#123; var o = &#123; name: name, age : age, job : job, sayName: function() &#123; alert(this.name); &#125; &#125;; return o;&#125;var person1 = createPerson(\"steve\", 24, \"fe\");var person2 = createPerson(\"young\", 25, \"fs\"); 问题：没有解决对象识别的问题（即怎样知道一个对象的类型），重复构造相同的方法造成内存浪费，也无法进行继承复用。 6.2.2. 构造函数模式特点：在构造函数中使用 this 对象在运行时基于函数的执行环境动态绑定，使用 new 操作符实例化。 ps 通过 new 关键字方式调用的函数都被认为是构造函数。 123456789101112131415function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;;&#125;var person1 = new Person(\"steve\", 24, \"fe\");var person2 = new Person(\"young\", 25, \"fs\");alert(person1.constructor === Person); // truealert(person2.constructor === Person); // true 与工厂模式的不同之处 没有显式地创建对象 直接将属性和方法赋值给了 this 对象 没有 return 语句 要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（this 指向新对象） 执行构造函数中的代码（为之添加属性） 返回新对象 这种方式胜过工厂模式的地方就在于：可以将实例标识为一种特定的类型。 1. 构造函数当作普通函数既然实例化需要使用 new 操作符，万一不使用又会怎么样的？ 123456789101112// 当作构造函数使用var person = new Person(\"steve\", 24, \"fe\");person.sayName(); // steve// 当作普通函数使用Person(\"young\", 24, \"fe\"); // 添加到 window 对象中window.sayName(); // young// 在另一个对象的作用域中调用var o = new Object();Person.call(o, \"sasuke\", 24, \"fe\");o.sayName(); // sasuke 2. 构造函数的问题2.1. 每个方法有独立的内存，造成浪费。1234567891011121314alert(person1.sayName == person2.sayName); // false// 虽然可以把函数定义转移到构造函数外function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.Name);&#125; 虽然这样将其设置成了全局函数，但是新问题就是：全局函数却只能被某个对象调用，并且如果需要定义很多方法，就需要定义很多全局函数，也就是说毫无封装性可言。 6.2.3. 原型模式首先我们要知道每一个函数都有一个属性叫做 prototype，这个属性是一个指针，指向函数的原型对象。 原型对象的用途：包含可以由特定类型的「所有实例」[共享]的属性和方法。 换句话来说就是：所有对象实例可以一起通过这个 prototype 来共享属性和方法～=￣ω￣=～。 12345678910111213141516171819function Person() &#123;&#125;// 属性Person.prototype.name = \"steve\";Person.prototype.age = 24;Person.prototype.job = \"Web Developer\";// 方法Person.prototype.sayName = function() &#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); // stevevar person2 = new Person();person2.sayName(); // stevealert(person1.sayName === person2.sayName); // true 共享同一个方法 1. 深入理解原型对象 只要是函数，都有一个 prototype 指针，指向原型对象。 而原型对象默认会自动获得一个 constructor 指针，指向上一条中的函数。（你指我？我也指你→_→） 调用构造函数创建一个新实例后，实例内部也会获得一个 [[prototype]] 指针（ES5 中这么叫），指向原型对象（不是创造它的构造函数！）。 下面进行详细说明： 第一条很好理解，当作大自然的规律来记就好啦，你否认也没用╮(╯▽╰)╭ 第二条就是说原型对象与一般的对象最大的不同就是这个 constructor 指针，所以在重写构造函数的 prototype 时，要想与之前的原型对象保持一致，最好也加上这个 constructor 指针（显得专业嘛～=￣ω￣=～）。 第三条，其实在 Firefox、Safari 和 Chrome 中，[[prototype]] 就是 __proto__ 指针。 ps 无论有没有 __proto__ 指针，我们都可以通过 isPrototypeOf() 方法来确定对象之间是否存在原型关系。（Person.prototype.isPrototypeOf(person1) // true） pps ES5 中增加了一个新方法 Object.getPrototypeOf() （Object.getPrototypeOf(person1) === Person.prototype // true） 总结一下就是：构造函数有指向原型对象的指针(prototype)，原型对象也有指向构造函数的指针(constructor)，实例同样也有指向原型对象的指针([[prototype]]) 那么这玩意儿这么复杂有啥用咧…?简单举个栗子，上文中 6.2.3.原型模式一节中的两个实例(person1,person2)并不包含任何属性和方法，但是我们仍然可以调用 person1.sayName() 方法，这就是通过查找对象属性的过程实现的。 还有我们经常使用的各种数组方法(slice,splice,sort…)，同样也是定义在 Array.prototype 这个对象上的。 其实每当读取某个对象的某个属性时，都会执行一次搜索，目标就是给定的属性名。首先当然先搜索对象实例自身，如果没找到再继续搜索 [[prototype]] 指针指向的原型对象，如果找不到再向上查找… 所以实例的属性可以“屏蔽“原型链上的同名属性。（通过 delete 可以删除实力属性，消除屏蔽） a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？很简单，使用 hasOwnProperty() 犯法。 b. 那么问题又来了，如果就是没有咋办？还记得 JavaScript 中的数据类型么，不平凡的那个引用类型 Object。我们使用的 Array、Function、Date、RegExp… 都是由 Object 派生而成。换句话说他们的原型对象都指向了 Object.prototype。最后 Object.prototype 又指向了 null。 所以如果寻找属性直到 Object.prototype 中都没有，从而找到 null。那么 JS 引擎就会抛出 undefined。 2. 原型与 in 操作符in 操作符用来判断对象能否访问给定属性（前提是 enumerable 为 true），有两种方法使用 in 操作符： 单独使用 在 for-in 循环中使用 但由于 in 操作符不区分实例和原型链，所以日常使用中需要结合 hasOwnProperty() 方法 1234function hasPrototypeProperty(object, name) &#123; // 判断是否是原型链上的属性 return !object.hasOwnProperty(name) &amp;&amp; (name in object);&#125; 此外要取得对象上所有可枚举的实例属性，可以用 ES5 中的 Object.keys() 方法（返回数组）。 当然如果要取得所有实例属性，无论是否可枚举，可以用 Object.getOwnPropertyNames() 方法。 3. 更简单的原型方法日常使用中，每当要为原型对象添加一个属性或方法，都要敲一遍 Person.prototype，这样太不优雅了… 所以一般采用对象字面量将属性和方法都包起来。 12345678910111213function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, // 别忘了之前说过的 constructor 指针。 name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;; 但是，如果你是个完美主义者，还有一点要注意：原生 constructor 属性是不可枚举的，所以可以用 Object.defineProperty() 将其改写回来。 123456789101112131415161718function Person() &#123;&#125;Person.prototype = &#123; name: \"steve\", age : 24, job : \"Web Developer\", sayName: function() &#123; alert(this.name); &#125;&#125;;Object.defineProperty(Person.prototype, \"constructor\", &#123; enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, value : Person&#125;); 4. 原型的动态性略，只要你了概（解）了指针是咩（什么）就大丈夫（没问题）。 5. 原型对象的原型略，大概内容就是说了下俺们原生的对象和乃们“野生”对象一样也是有原型的╮(╯▽╰)╭。 6. 原型对象的问题问题其实是来自于自身共享的本性。 例如，包含引用类型的属性。由于引用类型实际上就是指针，所以所有实例操作的都是同一个引用对象，见下例： 1234567891011121314151617181920212223function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name : \"steve\", age : 24, job : \"Web Developer\", friends: [\"shirley\", \"jame\"], sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\",\"van\"]alert(person1.friends === person2.friends); // true 6.2.4. 组合使用构造函数模式和原型模式经过上文的讨论我们知道： 构造函数模式可以为每个实例生成单独的属性，但无法共享。 原型模式可以共享，但无法为实例生成单独的属性。 既然构造函数模式和原型模式的优缺点正好互补，那么为何不将两者结合，发挥各自的长处？ 组合模式就是基于这一朴素的思想： 构造函数用于定义实例属性 原型模式用于定义共享的属性和方法 这样一来，每个实例都有自己的实例属性副本，但同时又共享着原型对象中的方法和属性，最大限度地节省了内存，还支持向构造函数中传递参数，可谓博采众长也～=￣ω￣=～。 123456789101112131415161718192021222324function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"];&#125;Person.prototype = &#123; constructor: Person, sayName: function() &#123; alert(this.name); &#125;&#125;;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.5. 动态原型模式本质其实还是组合模式，只不过把原型对象中共享的属性和方法，也封装在构造函数里… 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [\"shirley\", \"jame\"]; if (typeof this.sayName != \"function\") &#123; // 不能使用对象字面量 Person.prototype = &#123;...&#125;; Person.prototype.sayName = function() &#123; alert(this.name); &#125;; &#125;&#125;var person1 = new Person(\"steve\", 24, \"Web Developer\");var person2 = new Person(\"nicholas\", 29, \"Soft Engineer\");person1.friends.push(\"van\");alert(person1.friends); // [\"shirley\", \"jame\",\"van\"]alert(person2.friends); // [\"shirley\", \"jame\"]alert(person1.friends === person2.friends); // falsealert(person1.sayName === person2.sayName); // true 6.2.6. 寄生构造函数模式首先一般来说，组合模式已经足够应付日常需求，所以这个模式是为了应对特殊需求：例如我们需要创建一个具有额外方法的特殊数组，但是不能直接修改 Array 的构造函数（见下例）。 具体形式上除了使用 new 操作符创建实例以外，和工厂模式一毛（模）一样（同样的问题）。 1234567891011121314151617function SpecialArray() &#123; // 内部创建一个新数组 var values = new Array(); // 添加值 values.push.apply(values, arguments); // 添加方法 values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\"); // 注意：使用 new 创建实例alert(colors.toPipedString()); // red|blue|green 这个模式其实利用了构造函数的特性： 如果被调用的函数没有显式的 return 表达式，则隐式地会返回 this 对象 - 也就是新创建的隐式对象。 显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。 1234567891011121314151617function Foo() &#123; return 2;&#125;function Bar() &#123; return new Number(2);&#125;new Foo().constructor === Number // false，返回新创建的隐式对象new Bar().constructor === Number // true，返回 Number 对象function Test() &#123; this.value = 2; return &#123; foo: 1 &#125;;&#125;console.log(new Test()); // &#123;foo: 1&#125;，返回的对象，this 对象被销毁了，value 丢失了 6.2.7. 稳妥构造函数模式首先要介绍 Douglas Crockford 发明的「稳妥对象」(durable objects) 这个概念：没有公共属性，而且方法也不引用 this 的对象。 主要用在需要安全的环境（禁止 this 和 new），或者在防止数据被其他程序（如 Mashup）改动时使用。 1234567891011121314151617function Person(name, age, job) &#123; //创建要返回的对象 var o = new Object(); //可以在这里定义私有变量和函数 //添加方法 o.sayName = function() &#123; alert(name); // 注意：这里没有使用 this，因此我的理解是相当于闭包，保存住了外部 Person 的 AO（活动对象） &#125;; //返回对象 return o;&#125;var person = Person(\"steve\", 24, \"web developer\");person.sayName(); //\"steve\" 这里变量 person 中保存的就是一个稳妥对象，因为除了调用 sayName() 方法以外，没有别的方法可以访问内部的数据。 即使有其他代码会给这个对象添加方法或数据，也无法访问传入到构造函数中的原始数据。 6.3. 继承许多面向对象的编程语言都支持两种继承方式： 接口继承：只继承方法签名 实现继承：继承实际的方法 在 ECMAScript 中由于函数没有签名，所以无法实现接口继承，只支持实现继承，而这正是依靠「原型链」来实现的。 6.3.1. 原型链既然这继承的关键在于「原型链」，我们就先来了概（解）下原型链的概念究竟是神马… 基本思想：利用 prototype（原型对象），让一个引用类型继承另一个引用类型的属性和方法。 简单回顾一下之前讨论过的关于，构造函数、原型对象和实例的关系： 每个构造函数都有一个指向自己原型对象的 prototype 指针。 原型对象又都包含一个指向构造函数的 constructor 指针。 实例都包含一个指向原型对象的 [[prototype]] 内部指针（__proto__）。 假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？123456function foo() &#123;&#125;function bar() &#123;&#125;var a = new foo(); // a 是父类 foo 的实例bar.prototype = a; // 「原型对象 bar.prototype」等于另一个类型的「实例 a」var b = new bar(); // b 是子类 bar 的实例 简单分析一下以上代码： 「1」a 作为 foo 的实例，a 的内部指针 [[prototype]] 指向原型对象 foo.prototype。 「2」bar.prototype 被赋值为 a，所以相当于 bar.prototype 有内部指针 [[prototype]] 指向原型对象 foo.prototype。 「3」b 作为 bar 的实例，b 的内部指针 [[prototype]] 指向原型对象 bar.prototype。 「4」综上，这样便形成了一条：b -&gt; bar.prototype -&gt; foo.prototype 的原型链。 「5」假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，可以生成更长的原型链。 以上就是原型链的基本概念…╮(╯_╰)╭ 下面再来看看一种实现原型链的基本模式12345678910111213141516171819202122function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); // true，成功继承父类原型对象上的方法alert(instance.constructor); // SuperType，因为访问的是 Super.prototype 中的 constructor 1. 别忘记默认的原型其实，所有的引用类型都默认继承自 Object，而这个继承也是通过原型链实现的。所以所有自定义类型都能够使用 toString()、valueOf() 等方法。 2. 确定原型和实例的关系有两种方法确定原型和实例的关系： instanceof 操作符 isPrototypeof() 方法 1234567alert(instance instanceof Object); // truealert(instance instanceof SuperType); // truealert(instance instanceof SubType); // truealert(Object.prototype.isPrototypeof(instance)); // truealert(SuperType.prototype.isPrototypeof(instance)); // truealert(SubType.prototype.isPrototypeof(instance)); // true 3. 谨慎地定义方法子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，这点很好理解。 还要注意以下这种使用对象字面量创建原型方法的情况。 1234567891011121314// blabla...SubType.prototype = new SuperType(); // 注意：使用 new 生成父类实例，重写了原型对象// 隐式地创建了一个新对象，改写了 SubType.prototype 的指针指向SubType.prototype = &#123; getSubValue: function() &#123; return this.subproperty; &#125;, someOtherMethod: function() &#123; return false; &#125;&#125;; 4. 原型链的问题 引用类型属性的问题：相当于将父类属性添加到子类原型对象上形成共享。 创建子类实例时，不能向超类型的构造函数中传递参数：准确的说是无法在不影响所有对象实例的情况下，给父类的构造函数传递参数。 6.3.2. 借用构造函数在解决原型链以上问题的过程中，产生了一种叫做「借用构造函数（伪造对象、经典继承）」的技术。 基本思想是：在子类构造函数内部调用父类构造函数，主要通过 call() 和 apply() 方法实现。 1. 传递参数相对于原型链而言，借用构造函数最大的优势就是解决了传递参数的问题。 12345678910111213function SuperType(name) &#123; this.name = name;&#125;function SubType() &#123; SuperType.call(this, 'steve'); this.age = 24;&#125;var instance = new SubType();alert(instance.name); // stevealert(instance.age); // 24 2. 借用构造函数的问题源自于构造函数的问题：方法都在构造函数中定义，无法函数复用，子类方法也无法使用父类原型对象中的方法。 6.3.3. 组合继承顾名思义，就是将原型链和借用构造函数结合。 12345678910111213141516171819function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function() &#123; return this.name;&#125;;function SubType(name, age) &#123; // 借用构造函数继承属性 SuperType.call(this, name); this.age = age;&#125;// 使用原型链继承了方法SubType.prototype = new SuperType(); 虽然看起来结合了两者的优点，既能够传递参数，又能实现原型链继承，但是应该注意到 SubType.prototype = new SuperType(); 一句。 我们的预期只是子类 SubType 拥有父类的属性，即 SuperType.call(this, name); 的工作。 但是 SubType.prototype 上也拥有了一个值为 undefined 的 name 属性和 colors 数组。这不是我们的本意，这就是直接使用 new 操作符将父类实例赋值给子类原型对象的副作用╮(╯▽╰)╭。 要解决组合模式存在的问题，首先来看几个其他方式的继承。6.3.4. 原型式继承由 Douglas Crockford（又是你→_→）在2006年的一篇文章中介绍，基本思想是：基于已有对象，借助原型创建新对象。 1234567function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; 即先创建一个临时性的构造函数 F，然后将传入的对象 o 作为这个构造函数的原型 F.prototype，最后返回这个临时类型的一个新实例 new F()。从本质上将就是对于传入的对象 o 进行了一次浅复制。 1234567891011121314var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = object(person);anotherPerson.name = \"young\";anotherPerson.friends.push(\"sasuke\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"nicholas\";yetAnotherPerson.friends.push(\"jobs\");alert(person.friends); // shirley,jame,sasuke,jobs，friends 被共享了 ES5 中新增了 Object.create() 方法规范化了原型式继承。可以接收两个参数，第一个参数就是要继承的对象，第二个对象是可选的一个为新对象定义额外属性的对象。其实只传一个参数时，两个方法行为相同。 第二个参数与 Object.defineProperties() 方法的第二个参数格式相同（覆盖同名属性），见下例。 12345678910111213var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;var anotherPerson = Object.create(person, &#123; name: &#123; value: \"greg\", configurable: false &#125;&#125;);alert(anotherPerson.name); // greg 6.3.5. 寄生式继承基本思路类似用工厂模式包装原型式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回该对象。 123456789101112131415161718var person = &#123; name: \"steve\", friends: [\"shirley\", \"jame\"]&#125;;function createAnother(original) &#123; var clone = object(original); // 原型式继承对象 original // 增强对象 clone.sayHi = function() &#123; alert(\"Hi\"); &#125;; return clone; // 返回对象&#125;var anotherPerson = createAnother(person);anotherPerson.sayHi(); // Hi 6.3.6. 寄生组合式继承首先实力吹一波：作为压轴出场的终极继承方式，几乎是最理想的继承范式。 前面在介绍组合继承的时候说到了主要问题出在 SubType.prototype = new SuperType(); 这句。它将父类构造函数中的属性也添加到了子类原型对象中，而这不符合我们的期望。 其实让我们回到需求本身：我们希望子类的原型对象能够指向父类的原型对象，实现原型链继承。 那么想一想 6.3.4. 原型式继承，我们让子类原型式继承父类的原型对象不就完美了么？ 12345678910111213141516171819202122232425262728function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\"];&#125;SuperType.prototype.sayName = function() &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); // 借用构造函数，继承父类属性（解决了传参） this.age = age;&#125;SubType.prototype = Object.create(SuperType.prototype, &#123; constructor: &#123; value : SubType, // 指回子类构造函数 enumerable : false, // 默认值，其实可以不写 writable : true, configurable: true, &#125;&#125;);// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）SubType.prototype.sayAge = function() &#123; alert(this.age);&#125;; 6.4. 小结创建对象 工厂模式：简单地在函数内部创建对象，添加属性和方法，然后返回对象。 构造函数模式：在函数内部使用 this 添加属性和方法，可以创建自定义引用类型，可以使用 new 操作符创建实例。但是无法实现函数复用，造成内存浪费等问题。 原型模式：使用构造函数的 prototype 属性来指定共享的属性和方法，本质上就是为了共享而生。 组合模式：结合构造函数和原型模式的优点。 对象继承 原型链：将父类的实例赋值给子类构造函数的原型对象。但这样会有两个问题：传参和子类原型上有多余的父类构造函数中的属性。 借用构造函数：为了解决传参问题，采用在子类中调用父类构造函数的方法。 原型式：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。 寄生组合式：巧妙利用原型式继承解决原型链中的第二个问题，是基于类型继承的最好方式。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://buptsteve.github.io/blog/tags/JavaScript/"}]},{"title":"「4」Byrs-News 建站笔记（一）","date":"2016-03-16T03:27:58.000Z","path":"2016/03/16/4. byrs-news notes 1/","text":"零、前言差不多结束了在移动研究院快一年的实习，加上马上到来的寒假，想着闲着也是闲着不然做个网站练练手吧╮(╯▽╰)╭ 于是在寒假里就捣鼓了这么个网站 Byrs-News | 开源地址，主要内容是通过爬虫 Byr-Crawler 对于北邮人论坛帖子进行定时爬取，在收集整理之后希望大家能够更加“优雅地”浏览论坛～=￣ω￣=～。 一、技术栈 网站采用了 Meteor.js 全栈式开发 数据库选择了 MongoDB 进行存储 内容获取来自自己编写的 Node.js 爬虫 那么首先问题来了… 1.1. Meteor 是个什么玩意儿？Meteor 是一个只使用 JavaScript 就可以开发 Web 和移动端应用的全栈框架。主要特点有： 一种语言(One Language)：JavaScript（就可以搞定服务器、浏览器、移动设备）。 传递数据(Data on the wire)：服务器和客户端之间传递的是数据（而不是 html），由客户端进行数据的渲染。 无处不在的数据库(Database everywhere)：从客户机或服务器上使用相同、透明的 API 访问数据库。（在浏览器端实现了 Minimongo） 延迟补偿(Latency Compensation)：使用预读和模式模拟技术，使之看起来与数据库的连接是零延迟的。 全栈响应式(Full Stack Reactivity)：代码所依赖的数据发生变化时，结果 会自动重新计算。（并不是指响应式） 拥抱生态(Embrace the Ecosystem)：开源、与现有工具和框架整合，而不是取代。 简单等于生产力(Simplicity Equals Productivity)：让一件事看起来简单的最佳方式就是「真正」让它变得简单。 我的感受是使用 Meteor.js 可以在只用一种语言（JavaScript）的情况下，「超快速」地开发出一个功能完善的现代网站。 还有疑问？Take it easy.且看我后文慢慢道来… 1.2. 为什么选择 MongoDB？ 首先当然是因为它是 Meteor 的默认数据库呀╮(╯▽╰)╭ 其次作为一个 NoSQL 数据库比传统关系型数据库更加灵活，更加适用于互联网应用场景 我可以在爬虫运行过程中可以更加方便地修改文档结构 … 1.3. 为什么是 Node.js 爬虫？因为正好最近在学习 Node.js，还有保持项目只有一种语言。 二、项目规范2.1. 命名规范 文件夹和文件采用小写字母，用下划线 _ 连接。 JavaScript 文件中的内容采用驼峰命名法（因为毕竟它自己就是用的驼峰╮(╯▽╰)╭）。 CSS 文件中的内容采用连字符 - 连接（因为本来 CSS 语法就是用连字符，如 font-family 等）。 2.2. 文件夹规范由于是一个全栈式框架（代码写一块儿╮(╯▽╰)╭），所以文件夹的名字十分地重要。因为会影响 Meteor 对其加载的顺序（见下文）。 一般来说有在顶级项目目录下有以下规范的命名： client/ : 放置所有的客户端代码，Meteor 也不会将其在服务端加载。 server/ : 放置所有的服务端代码，Meteor 也不会将其在客户端加载。 public/ : 放置静态资源，例如 favicon.ico, robots.txt 等。 node_modules/ : Node.js 模块代码。（比如 cz-conventional-changelog） tests/ : 本地测试代码。 private/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） client/compatibility/ : 只能被服务器端代码获取，可以通过 Assets API 读取。（不常用） lib/ : 放置服务端和客户端共用的代码，比如 config.js、数据库文件夹 collections/。 加载顺序（了解即可） 应用根目录内 lib 文件夹下的文件首先加载。 符合 main.* 这个格式的文件最后加载。 子目录中的文件在母目录中的文件之前加载，即最深层子目录中的文件首先加载（在 lib 之后），根目录的文件最后加载（在 main.* 之前）。 同目录下的文件，按文件名的字母顺序来加载。 三、重要参考资料 官网 官方快速入门教程: 学习点这 StackOverflow: 碰到问题点这 官方论坛 Github","tags":[{"name":"meteor","slug":"meteor","permalink":"http://buptsteve.github.io/blog/tags/meteor/"}]},{"title":"「3」前端开发利器 webpack","date":"2015-12-29T07:12:58.000Z","path":"2015/12/29/3. js-webpack/","text":"零、前言在编写构建前端项目时，以下这些需求想必十分常见： html/css/js 代码的预编译： Jade, Ejs… Sass, Less, Stylus… Dart, CoffeeScript, TypeScript, ES6/7… 拯救你的 F5 或者 Command/Ctrl + R（即自动监听、编译并刷新浏览器） 发布时的代码压缩、混淆，图片的压缩和 base64 嵌入 以上这些「体力♂活儿」显然不能自己浪费时间手动完成，so 优雅的解决方式就是：自动化构建工具咯～=￣ω￣=～！ 话说我最早了解到前端自动化构建工具，是通过慕课网学习的时候看到的 grunt 教程，随意浏览了点儿发现上手有点儿难 _(:зゝ∠)_ 同时也没有什么需求就没有学下去。 然后学习了 less/sass/stylus 等预编译语言，先是使用了 koala 进行 less 文件的编译。之后又有了「拯救 F5」的需求，觉得再使用 livereload 这样不够绅士(´･ω･`)。于是开始学习 gulp， gulp 是基于 Unix 的哲♂学，即 Do one thing and do it well. 类似于 Unix 的管道命令（pipe：| ），gulp 基于 Node.js 中的 stream 机制。Gulp 的每个插件从 stream 中读取输入，做一些处理，再输出到stream中。同时使用 browser-sync 插件能够解决我的重复刷新的繁重劳动。 无奈前端变化太快_(:зゝ∠)_，使用 gulp 没多久。通过 vue.js 一个 MVVM 框架，知道了 webpack 这一新的前端自动化构建工具。使用 webpack 可以方便地将 *.vue文件编译打包到工程中，并且 react 的大部分项目也使用 webpack 进行构建。那么问题来了，webpack 究竟靠什么火起来了呢？ 一、webpack1.1. 为什么选择 webpack ? 参考链接a. 首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？答案只有一个： 模块化开发！ 然而浏览器本身并不提供模块管理的机制（ES6 终于引入 Module），为了调用各个模块，有时不得不在网页中，加入一大堆script标签。这样就使得网页体积臃肿，难以维护，还产生大量的HTTP请求，拖慢显示速度，影响用户体验。 在此对于模块化就不继续展开了…Require.js/Sea.js/Common.js/AMD/CMD/ES6…etc. b. 明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？有两种「极端」的方式： 每一个请求传送一个模块（类似于一堆的 标签…） 一个请求传送所有模块（例如 browserify 的打包方式） 这两种方式方式各有优缺点： 优点：只加载需要的模块；缺点：大量请求会使得启动缓慢… 优点：请求数少，等待时间少；缺点：不需要的模块同样被传送了… 因此，在大多数的情况下最佳实践应该是一个折中的方案： 在编译所有模块时，将模块细分成为多个小的 batches(chunks)，于是我们分解得到了许多请求。模块的 chunks 初始状态时并没有全部加载，只在需要的时候发起请求。因此初始请求不会包含所有的代码，显然加载的代码量更小，速度更快。 其中关键的「分割点」即 chunks 的划分边界，是取决于开发者并且是可选的。 c. 此外还有一个重要原因：webpack 支持模块热替换（HMR）（例如 react-hot-loader）针对浏览器自动刷新，LiveReload 和 Browser-sync 是两款常用的工具，然而 HMR 更进了一步。我们知道 React 出现的原因之一就是积累用户在浏览器中的状态，而 HMR 能够在修改代码保存之后仍然保存之前的状态，就是俗称的「热替换」。 1.2. 怎么使用 webpack？了解了为什么（why）之后，接着学习怎么做（how）。 a. webpack 的安装： 首先使用 npm 全局安装 webpack： 1$ npm i(nstall) -g webpack 接着局部安装 webpack： 1$ npm i(nstall) --save-dev webpack b. webpack 的配置：官方文档、Pete Huntwebpack 配置的本质就是：一个配置的 Object。 因此有两种使用方法配置 webpack: 一种是 Cli（即 Command Line Interface）方法：读取 webpack.config.js 文件； 另一种是 Node.js API 的方法：传递配置对象作为参数。 前端一般使用第一种，即配置 webpack.config.js 文件，简单例子如下： 1234567// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;&#125;; 就是设置入口、出口文件，炒鸡简单有木有~ 接着我们需要进行一些预编译工作，例如把 CoffeeScript 或 ES6 的代码编译为 ES5 的 JavaScript，例子如下： 12345678910111213141516// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.coffee$/, loader: 'coffee-loader' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader' &#125;] &#125;&#125;; 只需要加入 loader，loader 中的 test 表示哪些文件需要经过 loader 进行处理。 对于 css 和 图片资源同样也有 loader，这样就可以像引用 js 一样在代码中引用，例如： 12345require('./bootstrap.css');require('./myapp.less');var img = document.createElement('img');img.src = require('./glyph.png'); loader 的编写类似于之前的例子：（!用于链式操作） 1234567891011121314151617181920212223// webpack.config.jsmodule.exports = &#123; entry: './main.js', output: &#123; path: './build', // This is where images AND js will go publicPath: 'http://mycdn.com/', // This is used to generate URLs to e.g. images filename: 'bundle.js' &#125;, module: &#123; loaders: [&#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' &#125;, // use ! to chain loaders &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125;, &#123; test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192' &#125; // inline base64 URLs for &lt;=8k images, direct URLs for the rest ] &#125;&#125;; last but not the least: 添加 webpack-dev-server 作为实时代码更新安装完成后只需添加两行代码到 webpack.config.js 中： 123456789module.exports = &#123; ... entry: [ 'webpack-dev-server/client?http://0.0.0.0:8080', 'webpack/hot/only-dev-server', './app/main.js' ], ...&#125;; 并且在 package.json 中的 scripts 添加一行代码： 12345&#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --devtool eval --progress --colors --hot --content-base build\" &#125;,&#125; 这样在日常开发中只需要执行： 1npm run dev 在浏览器中访问 http://localhost:8080 即可看到编译结果，并且更改代码后能够自动刷新。","tags":[{"name":"效率","slug":"效率","permalink":"http://buptsteve.github.io/blog/tags/效率/"},{"name":"webpack","slug":"webpack","permalink":"http://buptsteve.github.io/blog/tags/webpack/"}]},{"title":"「2」如何搭建自己的服务器？","date":"2015-11-03T05:04:58.000Z","path":"2015/11/03/2. centos-server/","text":"零、问题的由来？平时逛北邮人论坛看到各种大神做的各种作品，技痒难耐，也想自己捣鼓捣鼓、学习服务器。正好实验室有空闲电脑，就自己搭一个玩儿啦～=￣ω￣=～。在纠结半天，看了好多资(si)料(bi)后，决定选用 CentOS 作为操作系统， 主要开发环境为 Python 和 Node.js。 一、系统安装（怎么获取镜像就不赘述了～=￣ω￣=～） 利用 ultraISO 将镜像文件拷入 u 盘内 设置 BIOS，优先从 u 盘启动 按照步骤安装… 二、网关问题由于北邮校内使用 ipv4 流量需要登录网关╮(╯_╰)╭，下面介绍两种方法： 2.1. VNCCentOS 可以使用 tigervnc，使用 yum 即可安装： 12$ yum install tigervnc$ yum install tigervnc-server 安装完成后，使用命令vncserver :n 打开相应端口n（这里的n是sessionnumber，不指定默认为1，也可以是2、3等等。第一次会提示输入密码，以后可以使用vncpasswd命令修改密码。） 当然别忘了设置 iptables…小白就 iptables -F 吧╮(╯▽╰)╭ 之后就可以从本地 vncviewer 连接啦… 2.2. 命令行（推荐）网关登录还可以使用 curl 命令： 登录： 1$ curl -d 'DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey=' 10.3.8.211 注销： 1$ curl 10.3.8.211/F.htm 三、Python 3 环境由于 CentOS 自带 Python 为 2.7.5 版本（最好不要卸载，因为会被 yum 使用╮(╯_╰)╭），而我日常使用 3.0+ 所以需要更新 Python 版本。下面介绍一种两个环境共存的方法（以 3.5 版本为例）： 1$ wget https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz 下载 Python 3.5.0 ，之后解压，安装… C Complier问题：在上一步安装 Python3 的过程中执行 ./configure 时报错，原来是没有 C Complier… 1$ yum install gcc 继续安装 Python3 123$ ./configure --prefix=/opt/python3$ make$ sudo make install 验证是否安装成功 1$ /opt/python3/bin/python3 -V 重要事项！ 由于此种方法仍保留了原系统中的 Python2 ，因此别忘了在自己编写的 Python3 脚本中加入 1#!/opt/python3/bin/python3 即，选择 python3 进行解析。 四、Node.js 环境4.1. 选择通过 EPEL(Extra Packages for Enterprise Linux，企业版 Linux 的额外软件包)来安装 Node.js EPEL 是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。这个源兼容 RHEL 及像 CentOS 和 Scientific Linux 这样的衍生版本。 我们可以很容易地通过yum命令从EPEL源上获取上万个在CentOS自带源上没有的软件。EPEL提供的软件包大多基于其对应的Fedora软件包，不会与企业版Linux发行版本的软件发生冲突或替换其文件。 更多关于 EPEL 项目的细节可以 点击这里 12$ yum install epel-release$ yum install nodejs npm 4.2. 仓库问题由于 GFW 的原因，可能使用自带 registry 会太慢或者失败╮(╯_╰)╭ 推荐一个帮助切换仓库的 npm 包 Pana/nrm 1$ npm i(nstall) -g nrm 使用介绍12345678910111213141516// 列出可用仓库$ nrm ls* npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - http://registry.npm.taobao.org/ eu ----- http://registry.npmjs.eu/ au ----- http://registry.npmjs.org.au/ sl ----- http://npm.strongloop.com/ nj ----- https://registry.nodejitsu.com/ pt ----- http://registry.npmjs.pt/// 切换仓库到 cnpm$ nrm use cnpm Registry has been set to: http://r.cnpmjs.org/ 3. 切换 Node.js 版本推荐 tj 大神的神器 tj/n 1$ npm i(nstall) -g n 使用介绍12345678910111213// 安装 0.8.14/0.8.17/0.9.6 三个版本的 nodejs$ n 0.8.14$ n 0.8.17$ n 0.9.6// 选择版本（移动上下箭头，回车或右键头选择，Ctrl+C 取消）$ n 0.8.14ο 0.8.17 0.9.6// 删除 0.9.4 版本$ n - 0.9.4","tags":[{"name":"Linux","slug":"Linux","permalink":"http://buptsteve.github.io/blog/tags/Linux/"},{"name":"Server","slug":"Server","permalink":"http://buptsteve.github.io/blog/tags/Server/"},{"name":"Python","slug":"Python","permalink":"http://buptsteve.github.io/blog/tags/Python/"},{"name":"Node.js","slug":"Node-js","permalink":"http://buptsteve.github.io/blog/tags/Node-js/"}]},{"title":"「1」优雅地打开软件是怎样的体验？","date":"2015-11-01T11:04:58.000Z","path":"2015/11/01/1. the-way-to-open-software/","text":"零、问题的由来不知道大家平时是怎么打开常用软件的： 1. windows 用户： 从桌面上一堆杂乱的文件中找到快捷方式双击打开？ 从桌面上分类整理好的文件夹中找到快捷方式双击打开？ 同样利用 Fences 从桌面选择？ 利用 Everything 进行文件名搜索？ win8下，win10下 blablabla… 2. OS X 用户： 通过在 Dock 中寻找后，单击打开？ 通过拇指与其他三个手指合拢进入 Launchpad 后，单击打开？ 利用自带的 spotlight 或者 alfred 等工具输入软件名打开？ 通过终端… 3. linux 用户： 通过终端… 要啥自行车…╮(╯▽╰)╭… (才不会告诉你是因为我不造呢…) 一、我的选择～=￣ω￣=～ (私のchoice)1.1. OS X 下：通过 alfred 打开。(btw 可以将 Application 中的各个 app 的名字重新缩写过，比如将 网易云音乐 缩写成 wyy) 1.2. windows 下：1.2.1. 首先通过自带的运行打开。(就是 win + r 那个→_→，不过为了保持与 OS X 操作的一致性利用了 AutoHotkey 将其修改为 ctrl + space。配置文件是 点我 中的 steve.ahk ) 1.2.2. 那么接着问题来了，打开运行后应该输入啥？还需要2步设置：(居然比把大象放冰箱还少一步啊喂！) 将 (桌面上或者其他地方的) 软件快捷方式改名缩写成2~3个字母 把该快捷方式 duang～ 地一声剪切到 C:\\Windows 下，搞定收工～=￣ω￣=～ 不过有的软件比如 Github.appref-ms 这种格式的就没办法通过以上方法快速打开了。这时候就又要推荐一个好用软件啦：Rolan，将快捷方式或其他的文件/文件夹拖进去就ok。要使用的时候就通过快捷键呼叫出 Rolan 后即可打开。 二、综上无论何时，无论当前层叠了多少窗口…只需要: 按下 Ctrl + Space 输入缩写过的 2~3 个字母的软件名称 按下 Enter 确认 Duang～一下就优雅地把软件打开了~\\(≧▽≦)/~","tags":[{"name":"效率","slug":"效率","permalink":"http://buptsteve.github.io/blog/tags/效率/"}]},{"title":"「0」Hello World","date":"2015-10-29T11:04:58.000Z","path":"2015/10/29/0. hello-world/","text":"零、Blog的由来作为一个学计算机的，一直想整个自己的Blog =￣ω￣=，尤其是最近在搞前端。先是看到jekyll感觉不错，折腾了半天感觉还是不够给力。最后还是选择了hexo3。 主要是这几个优点吧： 免费╮(╯▽╰)╭ 基于 node.js 速度快、操作更简单、命令少，专注于写作本身 由于 deploy 命令，发布到 github 上生成静态站点也很简单 所以整个Blog就是采用hexo3 + github pages,对了，主题准备基于concise进行修改，下面就详细说说怎么搭起来吧… 一、hexo的安装首先由于 hexo 是基于 node.js 开发的，所以我们先要安装 node.js 环境，进入node.js官网，一般会发现有两个版本：LTS 和 Stable。 这两个版本的区别在于一个是 LTS 长期支持版（也是推荐选项），另一个是拥有最新功能的稳定版（适合有新功能需求的尝鲜用户）。 安装完成后，在命令行运行以下命令（其中括号的意思是 install 可以缩写为 i）： 1$ npm i(nstall) -g hexo npm 安装方式中 -g 的意思是全局安装。 二、初体验~\\(≧▽≦)/~2.1. 找到一个合适的位置，创建我们的项目文件夹： 一般的用户：自己图形界面新建了一个,然后点进去 命令行用户：mkdir &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; hexo的用户：hexo init &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; 2.2. 安装依赖1$ npm i(nstall) npm 就会自动根据 package.json 中的配置自动进行安装 2.3. 运行12$ hexo g(enerate)$ hexo s(erver) 如果这步报错一般是因为没装 hexo-server，运行以下命令安装即可： 1$ npm i(nstall) --save hexo-server npm 安装方式中 –save 的意思是作为项目依赖进行安装，可以缩写为 -S (注意大写)此外还有 –save-dev 的意思是作为项目的「开发」依赖进行安装，可以缩写为 -D (注意大写)这两种安装方式都会将这个包的名称和版本写进 package.json 配置文件中 2.4. 最后打开浏览器输入http://localhost:4000就可以看到页面啦～=￣ω￣=～三、换主题（theme）然而只是使用默认的主题（theme）怎么会有逼格→_→，果断要整一个吊炸天的主题呀~，我初步选了concise。 3.1. 首先在项目目录下（就是说有个 themes 的文件夹），执行以下命令，将主题下载到 themes 文件夹下的 concise 文件夹中。1$ git clone https://github.com/huangjunhui/concise themes/concise 3.2. 接着修改 _config.yml（项目的配置文件，不是主题的） 将 theme 改为 concise（主题的文件夹名称）四、部署到 github4.1. 安装 hexo-deployer-git1$ npm i(nstall) hexo-deployer-git --save 4.2. 关于 github pages1. 首先分为两类 项目站点（Project Pages）：github 会根据 gh-pages 分支下文件生成静态页面，地址是 .github.io/。（ 是你的账户名， 是你的项目名） 个人或公司站点（User/Organization Pages）：首先要创建一个叫做 .github.io 的项目，接着 github 会根据 master 分支下文件生成静态页面，地址是 .github.io/。 2. 一些坑… 有的主题中各种静态文件路径是写死的，比如好多主题中的文件引入是针对第二类页面写死的。 有些主题中的 CDN 资源被墙，那就需要找到这些文件手动修改地址╮(╯▽╰)╭。 4.3. 修改 _config.yml 文件官方文档中是这么介绍的 1234567891011121314# You can use this:deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message]# or this:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 123* repo: Repository URL* branch: Git branch to deploy the static site to* message: Commit message. The default commit message is Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;. 根据 4.2. 所述，部署部分的填写也分为两种情况： 1. 个人或公司站点 repo：填写项目地址，例如 git@github.com:BuptStEve/BuptStEve.github.io.git branch：填写 master 2. 项目站点 repo：填写项目地址，例如 git@github.com:BuptStEve/blog.git branch：填写 gh-pages url：http://buptsteve.github.io/blog/ （注意最后的 /） root：/blog/ （注意最后的 /） 4.4. 开始部署首先生成站点文件 1$ hexo g 接着发布 1$ hexo d(eploy) 最后打开对应地址就可以看到自己的博客啦～=￣ω￣=～。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://buptsteve.github.io/blog/tags/hexo/"}]}]