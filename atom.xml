<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BuptStEve&#39;s Blog</title>
  <subtitle>Talk is cheap show me the offer!</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://buptsteve.github.io/blog/"/>
  <updated>2016-10-14T02:56:45.394Z</updated>
  <id>https://buptsteve.github.io/blog/</id>
  
  <author>
    <name>Steve Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「6」JavaScript 函数表达式学习笔记</title>
    <link href="https://buptsteve.github.io/blog/2016/03/23/6.%20js-function-chapter7/"/>
    <id>https://buptsteve.github.io/blog/2016/03/23/6. js-function-chapter7/</id>
    <published>2016-03-23T07:27:58.000Z</published>
    <updated>2016-10-14T02:56:45.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>《JavaScript 高级程序设计（第三版）》第7章 函数表达式，学习笔记整理。</p>
<h3 id="主要内容有如下三部分"><a href="#主要内容有如下三部分" class="headerlink" title="主要内容有如下三部分"></a>主要内容有如下三部分</h3><ul>
<li>函数表达式的特征</li>
<li>使用函数实现递归</li>
<li>使用闭包定义私有变量</li>
</ul>
<a id="more"></a>
<h1 id="一、第7章-函数表达式"><a href="#一、第7章-函数表达式" class="headerlink" title="一、第7章 函数表达式"></a>一、第7章 函数表达式</h1><h2 id="7-0-函数定义"><a href="#7-0-函数定义" class="headerlink" title="7.0. 函数定义"></a>7.0. 函数定义</h2><p>在 JavaScript 中定义函数有两种方法：</p>
<ul>
<li>函数声明</li>
<li>函数表达式</li>
</ul>
<h3 id="7-0-1-函数声明"><a href="#7-0-1-函数声明" class="headerlink" title="7.0.1. 函数声明"></a>7.0.1. 函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</div><div class="line">  <span class="comment">// 函数体</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 只在 Firefox、Safari、Chrome 和 Opera 有效</span></div><div class="line">alert(functionName.name); <span class="comment">// functionName，函数名称</span></div></pre></td></tr></table></figure>
<blockquote>
<p>函数声明一个重要特征就是：函数声明提升（function declaration hoisting），简单来说就是 JS 引擎会在执行阶段之前读取函数声明，这就是我们才能够在函数声明之前就调用它的原因。</p>
</blockquote>
<h3 id="7-0-2-函数表达式"><a href="#7-0-2-函数表达式" class="headerlink" title="7.0.2. 函数表达式"></a>7.0.2. 函数表达式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有多种形式，以下为最常见的一种，即创建一个匿名函数并将其赋值给变量 functionName</span></div><div class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</div><div class="line">  <span class="comment">// 函数体</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 只在 Firefox、Safari、Chrome 和 Opera 有效</span></div><div class="line">alert(functionName.name); <span class="comment">// 空字符串</span></div></pre></td></tr></table></figure>
<p>当然函数表达式就没有声明提升这种特征了╮(╯▽╰)╭。以下是一个比较常见的坑…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 千万别这样做！</span></div><div class="line"><span class="comment">// 因为有的浏览器会返回 first 的这个 function，而有的浏览器返回的却是第二个</span></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">// 相反，这样情况，我们要用函数表达式</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</div><div class="line">  &#125;;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<h2 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1. 递归"></a>7.1. 递归</h2><blockquote>
<p>先说个段子：要想理解递归，首先要理解…递归。</p>
</blockquote>
<p>说正经的，递归就是函数自己调用自己。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// 递归结束条件</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>); <span class="comment">// 通过在全局 VO 中，找到自身函数的指针后调用自身</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 报错！因为修改了全局 VO 中 factorial 指针的指向（null）</span></div></pre></td></tr></table></figure>
<p>这么写主要问题就是递归函数与自身的函数名耦合，一旦修改了原本的函数名，则会导致错误。这时可以利用 <code>arguments.callee</code> 指针来成功寻找到正在执行的函数。</p>
<p>但是，接下来又有一个坑：arguments 在严格模式下无法使用。</p>
<p>不过，可以使用命名函数表达式来解决：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">// 递归结束条件</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * f(num<span class="number">-1</span>); <span class="comment">// 函数名 f 只在内部作用域里有效</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> f; <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h2 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2. 闭包"></a>7.2. 闭包</h2><blockquote>
<p>先下定义：闭包是指【有权】访问（另一个函数作用域）中的「变量」的「函数」。</p>
</blockquote>
<ul>
<li>闭包首先是一个函数</li>
<li>能力就是有权访问变量</li>
<li>范围在另一个函数作用域内</li>
</ul>
<p>我们日常在使用 JavaScript 中，在外部函数中定义的内部函数能够访问外部函数中的变量。所以，最常见的闭包方式就是在一个函数内部创建并返回另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">arg0, arg1</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> arg0 + arg1;   <span class="comment">// 内部的 bar 函数能够访问外部函数 foo 的 arg0 和 arg1 变量。</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = foo(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">// test 是一个指针，指向返回的 bar 函数</span></div><div class="line">test();                   <span class="comment">// ab，调用闭包后，得到 arg0 + arg1 的值</span></div><div class="line"><span class="keyword">typeof</span> bar;               <span class="comment">// undefined，当然返回的是一个匿名函数</span></div></pre></td></tr></table></figure>
<h4 id="那么内部的-bar-函数是怎么保存外部-foo-函数的两个参数的呢？"><a href="#那么内部的-bar-函数是怎么保存外部-foo-函数的两个参数的呢？" class="headerlink" title="那么内部的 bar 函数是怎么保存外部 foo 函数的两个参数的呢？"></a>那么内部的 bar 函数是怎么保存外部 foo 函数的两个参数的呢？</h4><ul>
<li>首先在浏览器端的 JavaScript 代码，有一个全局的执行环境（Execution Context）即 window 对象。</li>
<li>每个执行环境都有一个对应的变量对象（Variable Object）：定义的所有变量和函数都保存其中。</li>
<li>当某个函数被调用时，会创建一个执行环境（EC）及相应的作用域链（Scope Chain）（其实是被推入一个环境栈中，执行之后栈将之弹出）。</li>
<li>作用域链（SC）就是一个指向各个变量对象的指针列表（全局 VO 是其中的最后一个对象）。</li>
<li>一般来说某个执行环境（EC）的所有代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。</li>
<li>如果执行环境是一个函数，那么它的变量对象（VO）又叫做活动对象（Activation Object）。</li>
<li>因此在一个函数中解析标识符的过程，类似于上一篇中提到的原型链查找。也是沿着 SC 一级一级地往上找。如果直到全局 VO 还没找到，就会报错。</li>
</ul>
<p>所以接下来举几个栗子：</p>
<h5 id="1-普通函数"><a href="#1-普通函数" class="headerlink" title="1. 普通函数"></a>1. 普通函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</div></pre></td></tr></table></figure>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">      ______________________________________________________________</div><div class="line">      |<span class="string">                                                             </span>|</div><div class="line">      V                                     _____________________   |<span class="string">           _____________________</span></div><div class="line"> _________________                    |<span class="string">--&gt; </span>|<span class="string">       global VO     </span>|<span class="string">  </span>|<span class="string">     </span>|<span class="string">---&gt;</span>|<span class="string">     compare AO      </span>|</div><div class="line">|<span class="string">   compare EC    </span>|<span class="string">                   </span>|<span class="string">    </span>|<span class="string">---------------------</span>|<span class="string">  </span>|<span class="string">     </span>|<span class="string">    </span>|<span class="string">---------------------</span>|</div><div class="line">|<span class="string">-------—---------</span>|<span class="string">       _______     </span>|<span class="string">    </span>|<span class="string"> compare </span>|<span class="string">      *----</span>|<span class="string">--</span>|<span class="string">     </span>|<span class="string">    </span>|<span class="string"> arguments </span>|<span class="string"> [5, 10] </span>|</div><div class="line">|<span class="string"> Scope Chain </span>|<span class="string"> *-</span>|<span class="string">----&gt; </span>|<span class="string">  SC   </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">---------------------</span>|<span class="string">        </span>|<span class="string">    </span>|<span class="string">---------------------</span>|</div><div class="line">|<span class="string">-----------------</span>|<span class="string">      </span>|<span class="string">-------</span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string"> result  </span>|<span class="string"> undefined </span>|<span class="string">        </span>|<span class="string">    </span>|<span class="string"> value1    </span>|<span class="string">    5    </span>|</div><div class="line">                         |<span class="string"> 1 </span>|<span class="string"> *-</span>|<span class="string">----</span>|<span class="string">    </span>|<span class="string">---------------------</span>|<span class="string">        </span>|<span class="string">    </span>|<span class="string">---------------------</span>|</div><div class="line">                         |<span class="string">-------</span>|<span class="string">                                        </span>|<span class="string">    </span>|<span class="string"> value2    </span>|<span class="string">   10    </span>|</div><div class="line">                         |<span class="string"> 0 </span>|<span class="string"> *-</span>|<span class="string">----------------------------------------</span>|<span class="string">    </span>|<span class="string">---------------------</span>|</div><div class="line">                         |<span class="string">-------</span>|</div><div class="line"></div><div class="line">                                           by 灵魂画师...(累死我了)</div></pre></td></tr></table></figure>
<ul>
<li>在创建 compare 函数时，就已经创建一个预先包含全局 VO 的作用域链（保存在内部的 [[Scope]] 属性中）。</li>
<li>在执行 compare 函数时，就创建 EC，然后复制并构建 [[Scope]] 属性中的作用域链 SC</li>
<li>此时创建 compare AO，并将其放入 SC 的顶端。</li>
<li>所以在函数中访问一个变量时，会从作用域顶端（就是 compare AO）开始找起。</li>
<li>所以一般一个函数执行完毕后，因为 AO 被销毁，所以在函数外部无法访问到函数内部的变量。</li>
</ul>
<h5 id="2-闭包示例"><a href="#2-闭包示例" class="headerlink" title="2. 闭包示例"></a>2. 闭包示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCompFunc</span>(<span class="params">propName</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj1, obj2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value1 = obj1[propName];</div><div class="line">    <span class="keyword">var</span> value2 = obj2[propName];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> compare = createCompFunc(<span class="string">"name"</span>);                   <span class="comment">// 创建函数</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> result = compare(&#123;<span class="attr">name</span>: <span class="string">"steve"</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"young"</span>&#125;); <span class="comment">// 调用函数</span></div><div class="line"></div><div class="line">compare = <span class="literal">null</span>;                                         <span class="comment">// 解除对匿名函数的引用（释放内存）</span></div></pre></td></tr></table></figure>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">          __________________________________________________________________</div><div class="line">          |<span class="string">                                         _____________________   </span>|</div><div class="line">          |<span class="string">                                </span>|<span class="string">-----&gt; </span>|<span class="string">      global VO      </span>|<span class="string">  </span>|</div><div class="line">          |<span class="string">                                </span>|<span class="string">       </span>|<span class="string">---------------------</span>|<span class="string">  </span>|</div><div class="line">          |<span class="string">                                </span>|<span class="string">       </span>|<span class="string"> createCompFunc </span>|<span class="string"> *--</span>|<span class="string">--</span>|</div><div class="line">          |<span class="string">                                </span>|<span class="string">       </span>|<span class="string">---------------------</span>|</div><div class="line">          V                                |<span class="string">       </span>|<span class="string"> result  </span>|<span class="string"> undefined </span>|</div><div class="line"> ___________________              _______  |<span class="string">       </span>|<span class="string">---------------------</span>|</div><div class="line">|<span class="string"> createCompFunc EC </span>|<span class="string">      </span>|<span class="string">---&gt; </span>|<span class="string">  SC1  </span>|<span class="string"> </span>|<span class="string">        ______________________</span></div><div class="line">|<span class="string">-------—-----------</span>|<span class="string">      </span>|<span class="string">     </span>|<span class="string">-------</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">---&gt; </span>|<span class="string">  createCompFunc AO   </span>|</div><div class="line">|<span class="string"> Scope Chain </span>|<span class="string">  *--</span>|<span class="string">------</span>|<span class="string">     </span>|<span class="string"> 1 </span>|<span class="string"> *-</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string">----------------------</span>|</div><div class="line">|<span class="string">-------------------</span>|<span class="string">            </span>|<span class="string">-------</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> arguments </span>|<span class="string"> ["name"] </span>|</div><div class="line">                                 |<span class="string"> 0 </span>|<span class="string"> *-</span>|<span class="string">-(-</span>|<span class="string">     </span>|<span class="string">----------------------</span>|</div><div class="line"> ________________________        |<span class="string">-------</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string"> propName  </span>|<span class="string">  "name"  </span>|</div><div class="line">|<span class="string">  anoymous function EC  </span>|<span class="string">                 </span>|<span class="string"> </span>|<span class="string">     </span>|<span class="string">----------------------</span>|</div><div class="line">|<span class="string">-------—----------------</span>|<span class="string">        _______  </span>|<span class="string"> </span>|<span class="string">      _______________________________</span></div><div class="line">|<span class="string"> Scope Chain </span>|<span class="string">    *-----</span>|<span class="string">-----&gt; </span>|<span class="string">  SC2  </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">-&gt; </span>|<span class="string">      anoymous function AO     </span>|</div><div class="line">|<span class="string">------------------------</span>|<span class="string">       </span>|<span class="string">-------</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">-------------------------------</span>|</div><div class="line">                                 |<span class="string"> 2 </span>|<span class="string"> *-</span>|<span class="string">-</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> arguments </span>|<span class="string"> [&#123;name: "steve"&#125;, </span>|</div><div class="line">                                 |<span class="string">-------</span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">           </span>|<span class="string">  &#123;name: "young"&#125;] </span>|</div><div class="line">                                 |<span class="string"> 1 </span>|<span class="string"> *-</span>|<span class="string">---</span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string">-------------------------------</span>|</div><div class="line">                                 |<span class="string">-------</span>|<span class="string">     </span>|<span class="string">   </span>|<span class="string">   obj1    </span>|<span class="string">  &#123;name: "steve"&#125;  </span>|</div><div class="line">                                 |<span class="string"> 0 </span>|<span class="string"> *-</span>|<span class="string">-----</span>|<span class="string">   </span>|<span class="string">-------------------------------</span>|</div><div class="line">                                 |<span class="string">-------</span>|<span class="string">         </span>|<span class="string">   obj2    </span>|<span class="string">  &#123;name: "young"&#125;  </span>|</div><div class="line">                                                   |<span class="string">-------------------------------</span>|</div><div class="line">                                 by 灵魂画师...(累死我了)</div></pre></td></tr></table></figure>
<ul>
<li>如图所示，首先看全局变量对象（global VO），其中有一个指针指向 createCompFunc 函数，还有一个声明提升后还未计算完毕的 result 等变量。</li>
<li>首先执行外部的 createCompFunc 函数，创建了它的 EC，其中有一个作用域链指针指向它的作用域链 SC1。</li>
<li>那么显然 SC1 中会有两个指针，分别指向 createCompFunc AO 和 global VO（这就是在函数内部能够访问到全局变量的原因）。</li>
<li>在 createCompFunc AO 中存放的就是函数内部定义的变量。</li>
<li>最后来看 createCompFunc 函数内部返回的匿名函数，当然它也有自己的执行环境 EC，也有自己的作用域链 SC2。</li>
<li>只不过由于它是 createCompFunc 函数内部的函数，当然它也能访问外部 createCompFunc 函数定义的变量，这正是因为 SC2 中位于第二的指针指向 createCompFunc AO（这就是闭包的原理）。</li>
<li>更为重要的是，在 createCompFunc 函数执行完毕后，因为匿名函数仍然引用着 createCompFunc AO，所以其活动对象不会被销毁（这涉及到内存回收机制）。</li>
</ul>
<p>从上述讨论我们可以清晰地看出：闭包的原理就是内部的函数仍然引用着外部函数的 AO，使得外部函数的 AO 仍然保存在内存中。所以我们可以通过将闭包设置为 null 来解除对该函数的引用，回收其占用的内存。</p>
<h3 id="7-2-1-闭包与变量"><a href="#7-2-1-闭包与变量" class="headerlink" title="7.2.1. 闭包与变量"></a>7.2.1. 闭包与变量</h3><p>下面我们来简单讨论下作用域链机制的副作用（坑）：闭包只能取得外部函数中任何变量的最后一个值。</p>
<p>先来看一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> i; <span class="comment">// 希望保存不同的 i，但是最后 i 都是 10</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = createFunc();</div><div class="line">alert(test[<span class="number">0</span>]()); <span class="comment">// 10</span></div></pre></td></tr></table></figure>
<p>其实很好理解，因为闭包在 SC 中保存的是一个指针而已，外部函数执行完毕后 AO 中的变量自然更新为最后一个值啦╮(╯▽╰)╭。</p>
<p>但是我们可以创建另一个立即执行的匿名函数强制让闭包的行为符合预期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = [];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">      &#125;</div><div class="line">    &#125;(i);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = createFunc();</div><div class="line">alert(test[<span class="number">0</span>]()); <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<ul>
<li>在这里我们相当于有3层函数。</li>
<li>中间那层的匿名函数有一个参数 num，我们将 i 传入立即执行。</li>
<li>因为简单类型是按值传递的，所以中间那层的匿名函数的 AO 中 num 保存的是不同的 i。</li>
<li>而最内层的匿名函数读取的正是中间层匿名函数的 AO。</li>
</ul>
<h3 id="7-2-2-关于-this-对象"><a href="#7-2-2-关于-this-对象" class="headerlink" title="7.2.2. 关于 this 对象"></a>7.2.2. 关于 this 对象</h3><p>我们知道，this 是在运行时根据函数的执行环境动态绑定的：</p>
<ul>
<li>在全局函数中，this 等于 window。</li>
<li>而函数被作为某个对象的方法调用时，this 又指向那个对象。</li>
<li>使用 call() 和 apply() 方法时，this 又会指向传入的那个对象（还有 bind()）。</li>
</ul>
<p>不过，匿名函数的执行环境具有全局性，因此内部的 this 通常指向 window，见下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// The Window (非严格模式下)，此处有两个括号，因为 object.getNameFunc() 是一个匿名函数，后一个括号是匿名函数调用。</span></div></pre></td></tr></table></figure>
<p>为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？</p>
<p>前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：this 和 arguments。而内部函数在搜索这两个变量时，只会搜索到其 AO 为止，所以永远不能直接访问到外部函数中的 this 和 arguments。</p>
<p>不过若是我们将外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问到该对象了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 使用 that 保存外部函数的 this（防止被内部函数的 this 屏蔽）</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> that.name; <span class="comment">// 由于访问的是内部 AO 中没有的变量 that，所以在 SC 中外部的 AO 上搜索，得到外部函数的 this。</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// My Object</span></div></pre></td></tr></table></figure>
<p>接下来再看几个特殊的栗子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">object.getName();   <span class="comment">// My Object，很好理解 this 就是指向 object</span></div><div class="line">(object.getName)(); <span class="comment">// My Object，将函数包了起来，但还是通过 object.getName 调用，this 还是指向 object</span></div><div class="line"></div><div class="line">(object.getName = object.getName)(); <span class="comment">// The Window(非严格模式下)，看起来很奇怪，将函数 getName 赋值为 getName，再调用赋值后的结果</span></div><div class="line"><span class="comment">// 因为赋值表达式操作的是 getName 函数本身，所以 this 的值没有得到维持，调用时指向了 widnow。</span></div></pre></td></tr></table></figure>
<h3 id="7-2-3-内存泄漏"><a href="#7-2-3-内存泄漏" class="headerlink" title="7.2.3. 内存泄漏"></a>7.2.3. 内存泄漏</h3><p>因为 IE9 之前对于 JScript 对象和 COM 对象使用不同的垃圾收集机制。所以如果闭包的作用域中保存一个 HTML 元素，那么该元素将无法被销毁╮(╯▽╰)╭。</p>
<h2 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3. 模仿块级作用域"></a>7.3. 模仿块级作用域</h2><p>我们都知道在 ES6 之前是木有块级作用域的╮(╯▽╰)╭，在块语句中定义的变量实际上是定义在函数 AO 上的。</p>
<p>如果实在需要块级作用域，可以通过立即执行函数进行模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这只是其中一种写法...重点是不要使用函数声明，这样由于声明提升会报错。</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 这里是块级作用域</span></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>在一个大型程序中过多的全局变量和函数很容易造成命名冲突，这样可以有效减少在全局作用域中添加变量和函数。也可以说是模块化的基础。ps jQuery 源码中最外层函数就是这样的一个立即执行函数…</p>
<h2 id="7-4-私有变量"><a href="#7-4-私有变量" class="headerlink" title="7.4. 私有变量"></a>7.4. 私有变量</h2><p>严格来说，JavaScript 中没有私有成员的概念…╮(╯▽╰)╭，不过在任何函数中定义的变量，外部都无法访问到，可以认为是私有变量。</p>
<p>私有变量包括：</p>
<ul>
<li>函数的参数</li>
<li>局部变量</li>
<li>内部定义的其他函数</li>
</ul>
<h4 id="那么如果我们需要访问这些私有变量该怎么办呢？"><a href="#那么如果我们需要访问这些私有变量该怎么办呢？" class="headerlink" title="那么如果我们需要访问这些私有变量该怎么办呢？"></a>那么如果我们需要访问这些私有变量该怎么办呢？</h4><p>在此就要引入一个概念：特权方法（privileged method）有权访问私有变量和私有函数的公有方法。</p>
<blockquote>
<p>这个概念是不是和闭包炒鸡像！？</p>
</blockquote>
<p>其实有两种在对象上创建特权方法的方式，第一种就是利用闭包在构造函数中定义特权方法。基本模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 私有变量和函数</span></div><div class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 特权方法</span></div><div class="line">  <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    privateVar++;</div><div class="line">    <span class="keyword">return</span> privateFunc();</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这样定义特权方法有一个问题：必须使用构造函数模式。而之前已经讨论过了构造函数会为每个实例都创建一组新方法，浪费内存，而接下来介绍的第二种方法，使用静态私有变量就可以避免这个问题。</p>
<h3 id="7-4-1-静态私有变量"><a href="#7-4-1-静态私有变量" class="headerlink" title="7.4.1. 静态私有变量"></a>7.4.1. 静态私有变量</h3><p>基本思想就是：在私有作用域（立即执行函数）中定义私有变量或函数，并在内部通过函数表达式定义构造函数和它的公有方法。基本模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">  MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 没有使用 var，所以是在 window 上创建（所以是非严格模式下）。</span></div><div class="line"></div><div class="line">  <span class="comment">// 公有/特权方法</span></div><div class="line">  MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    privateVar++;</div><div class="line">    <span class="keyword">return</span> privateFunc();</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>显然，通过上一篇对于对象继承的讨论我们知道：定义在原型对象上的属性和方法是所有实例共享的，而这些方法（如 publicMethod）所操作的对象，即私有变量和函数也是同一个。所以通过 MyObject 构造函数创造的实例都有权访问私有变量（而且是同一个），这就是静态私有变量。</p>
<h3 id="7-4-2-模块模式"><a href="#7-4-2-模块模式" class="headerlink" title="7.4.2. 模块模式"></a>7.4.2. 模块模式</h3><p>模块模式（module pattern）是为「单例」创建私有变量和特权方法。</p>
<blockquote>
<p>那么问题来了，单例是啥？</p>
</blockquote>
<p>单例（singleton）指的就是只有一个实例的对象。比如 JavaScript 中就是以对象字面量来创建单例对象的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = &#123;</div><div class="line">  <span class="attr">name</span> : value,</div><div class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 方法的代码</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法使其得到增强：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 公有/特权方法</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line"></div><div class="line">    <span class="attr">publicProperty</span>: <span class="literal">true</span>,</div><div class="line"></div><div class="line">    <span class="attr">publicMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      privateVar++;</div><div class="line">      <span class="keyword">return</span> privateFunc();</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>如上面代码所示，模块模式就是使用了一个返回对象的匿名函数：</p>
<ul>
<li>在函数内部定义了私有变量和函数</li>
<li>然后将对象字面量返回。</li>
<li>因为对象是函数内部定义的，所以它的方法是一个闭包。</li>
</ul>
<p>模块模式的应用场景主要是在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。</p>
<h3 id="7-4-3-增强的模块模式"><a href="#7-4-3-增强的模块模式" class="headerlink" title="7.4.3. 增强的模块模式"></a>7.4.3. 增强的模块模式</h3><p>应用场景：单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其进行加强的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 私有变量和私有函数</span></div><div class="line">  <span class="keyword">var</span> privateVar = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 创建对象</span></div><div class="line">  <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</div><div class="line"></div><div class="line">  <span class="comment">// 添加公有/特权属性和方法</span></div><div class="line">  object.publicProperty = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    privateVar++;</div><div class="line">    <span class="keyword">return</span> privateFunc();</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5. 小结"></a>7.5. 小结</h2><h4 id="1-在-JavaScript-中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点："><a href="#1-在-JavaScript-中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点：" class="headerlink" title="1. 在 JavaScript 中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点："></a>1. 在 JavaScript 中，使用函数表达式可以无须对函数命名，从而实现动态编程，还有强大的匿名函数，以下是函数表达式的特点：</h4><ul>
<li>函数声明必须要有名字，还会声明提升，而函数表达式不需要，没有名字的函数表达式又叫匿名函数</li>
<li>在递归函数中使用函数名调用自身可能会出现问题，如函数名发生了变化。</li>
<li>在递归函数中要掌握调用函数自身的技巧，如 arguments.callee 等。</li>
</ul>
<h4 id="2-闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下："><a href="#2-闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下：" class="headerlink" title="2. 闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下："></a>2. 闭包：在外部函数中又定义了一个内部函数，这个内部函数有权访问外部函数的所有变量，原理如下：</h4><ul>
<li>在 JavaScript 引擎执行时，闭包的 SC 包含了自己的 AO、外部函数的 AO 还有全局 VO。</li>
<li>通常，函数的作用域和所有变量会在函数执行后被销毁。</li>
<li>但是，当函数返回了一个闭包时，外部函数的 AO 会一直保存在内存中，直到解除闭包的引用，如设为 null。</li>
</ul>
<h4 id="3-使用闭包可以模仿块级作用域："><a href="#3-使用闭包可以模仿块级作用域：" class="headerlink" title="3. 使用闭包可以模仿块级作用域："></a>3. 使用闭包可以模仿块级作用域：</h4><ul>
<li>立即执行函数既可以执行其中的代码，又不会在内存中留下对该函数的引用。</li>
<li>所以函数内部的所有变量都会被立即销毁，除非将某些变量赋值给外部作用域中的变量。</li>
</ul>
<h4 id="4-闭包还可以用于在对象中创建私有变量："><a href="#4-闭包还可以用于在对象中创建私有变量：" class="headerlink" title="4. 闭包还可以用于在对象中创建私有变量："></a>4. 闭包还可以用于在对象中创建私有变量：</h4><ul>
<li>函数内部的变量、方法，外部无法访问。</li>
<li>但通过闭包可以实现公有方法，即访问在包含作用域中定义的变量。</li>
<li>有权访问私有变量的公有方法叫做特权方法。</li>
<li>可以使用构造函数模式、原型模式来实现自定义类型的特权方法。</li>
<li>也可以使用模块模式、增强模块模式来实现单例的特权方法。</li>
</ul>
<h4 id="综上：JavaScript-中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。"><a href="#综上：JavaScript-中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。" class="headerlink" title="综上：JavaScript 中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。"></a>综上：JavaScript 中函数表达式和闭包都是很给力的特性。不过，因为创建闭包必须维护额外的作用域，所以过度使用可能会占用大量内存。</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h2&gt;&lt;p&gt;《JavaScript 高级程序设计（第三版）》第7章 函数表达式，学习笔记整理。&lt;/p&gt;
&lt;h3 id=&quot;主要内容有如下三部分&quot;&gt;&lt;a href=&quot;#主要内容有如下三部分&quot; class=&quot;headerlink&quot; title=&quot;主要内容有如下三部分&quot;&gt;&lt;/a&gt;主要内容有如下三部分&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数表达式的特征&lt;/li&gt;
&lt;li&gt;使用函数实现递归&lt;/li&gt;
&lt;li&gt;使用闭包定义私有变量&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="全栈" scheme="https://buptsteve.github.io/blog/categories/%E5%85%A8%E6%A0%88/"/>
    
    
      <category term="JavaScript" scheme="https://buptsteve.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>「5」JavaScript 面向对象深入理解</title>
    <link href="https://buptsteve.github.io/blog/2016/03/17/5.%20js-oo-chapter6/"/>
    <id>https://buptsteve.github.io/blog/2016/03/17/5. js-oo-chapter6/</id>
    <published>2016-03-17T08:27:58.000Z</published>
    <updated>2016-10-14T02:56:45.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。</p>
<h3 id="同样按照书本的顺序分为如下三部分"><a href="#同样按照书本的顺序分为如下三部分" class="headerlink" title="同样按照书本的顺序分为如下三部分"></a>同样按照书本的顺序分为如下三部分</h3><ul>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li>理解继承</li>
</ul>
<a id="more"></a>
<h1 id="一、第6章-面向对象的程序设计"><a href="#一、第6章-面向对象的程序设计" class="headerlink" title="一、第6章 面向对象的程序设计"></a>一、第6章 面向对象的程序设计</h1><h2 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1. 理解对象"></a>6.1. 理解对象</h2><p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”简单来说，对象就是一些名值对（Key-Value），而对象的名字就是一个指针。</p>
<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1. 属性类型"></a>6.1.1. 属性类型</h3><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<h3 id="6-1-2-数据属性"><a href="#6-1-2-数据属性" class="headerlink" title="6.1.2. 数据属性"></a>6.1.2. 数据属性</h3><ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。</li>
<li>[[Writable]]：表示能否修改属性的值，默认为 true。</li>
<li>[[Value]]：包含这个属性的数据值，默认为 undefined。</li>
</ul>
<p>要修改以上属性，必须使用 ES5 中的 Object.defineProperty()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例1</span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span>   : <span class="string">"steve"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name); <span class="comment">// steve</span></div><div class="line">person.name = <span class="string">"abc"</span>;</div><div class="line">alert(person.name); <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="comment">// 例2</span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span>       : <span class="string">"steve"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">value</span>       : <span class="string">"steve"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ps 在调用 Object.defineProperty() 方法时，默认值为 false(就是说其他没写的属性是 false)。</p>
<h3 id="6-1-3-访问器属性"><a href="#6-1-3-访问器属性" class="headerlink" title="6.1.3. 访问器属性"></a>6.1.3. 访问器属性</h3><p>访问器属性不包括数据值(Value)，取而代之的是一对儿 getter 和 setter 函数(非必须)。</p>
<ul>
<li>[[Configurable]]：表能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。</li>
<li>[[Enumerable]]：表能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。</li>
<li>[[Get]]：在读取属性时调用的函数，默认为 true。</li>
<li>[[Set]]：在写入属性时调用的函数，默认为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">  <span class="attr">_year</span>  : <span class="number">2004</span>,</div><div class="line">  <span class="attr">edition</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">      <span class="keyword">this</span>._year = newValue;</div><div class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>ps 如果只定义了两个方法的其中之一，那么另一种方式则无法使用，例如只定义了 getter，则属性不可写。</p>
<h3 id="6-1-4-定义多个属性"><a href="#6-1-4-定义多个属性" class="headerlink" title="6.1.4. 定义多个属性"></a>6.1.4. 定义多个属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">  <span class="attr">_year</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2004</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">year</span>: &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._year = newValue;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h3 id="6-1-5-读取属性的特性"><a href="#6-1-5-读取属性的特性" class="headerlink" title="6.1.5. 读取属性的特性"></a>6.1.5. 读取属性的特性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</div><div class="line"></div><div class="line">alert(desc.value);        <span class="comment">// 2004</span></div><div class="line">alert(desc.configurable); <span class="comment">// false</span></div><div class="line">alert(<span class="keyword">typeof</span> desc.get);   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2. 创建对象"></a>6.2. 创建对象</h2><p>使用 Object 构造函数和字面量创建对象，会产生大量重复代码，所以以下代码重用机制应运而生。</p>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1. 工厂模式"></a>6.2.1. 工厂模式</h3><p>特点：使用函数封装特定接口创建对象的细节。简单来说就是在函数的内部创建对象，为其添加属性和方法后，将其用 return 返回，在实例化时不使用 new 操作符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: name,</div><div class="line">    <span class="attr">age</span> : age,</div><div class="line">    <span class="attr">job</span> : job,</div><div class="line"></div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"young"</span>, <span class="number">25</span>, <span class="string">"fs"</span>);</div></pre></td></tr></table></figure>
<p>问题：没有解决对象识别的问题（即怎样知道一个对象的类型），重复构造相同的方法造成内存浪费，也无法进行继承复用。</p>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2. 构造函数模式"></a>6.2.2. 构造函数模式</h3><p>特点：在构造函数中使用 this 对象在运行时基于函数的执行环境动态绑定，使用 new 操作符实例化。</p>
<p>ps 通过 new 关键字方式调用的函数都被认为是构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age  = age;</div><div class="line">  <span class="keyword">this</span>.job  = job;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"young"</span>, <span class="number">25</span>, <span class="string">"fs"</span>);</div><div class="line"></div><div class="line">alert(person1.constructor === Person); <span class="comment">// true</span></div><div class="line">alert(person2.constructor === Person); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="与工厂模式的不同之处"><a href="#与工厂模式的不同之处" class="headerlink" title="与工厂模式的不同之处"></a>与工厂模式的不同之处</h4><ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋值给了 this 对象</li>
<li>没有 return 语句</li>
</ul>
<h4 id="要创建新实例，必须使用-new-操作符。这个过程经历以下4个步骤："><a href="#要创建新实例，必须使用-new-操作符。这个过程经历以下4个步骤：" class="headerlink" title="要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤："></a>要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤：</h4><ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）</li>
<li>执行构造函数中的代码（为之添加属性）</li>
<li>返回新对象</li>
</ul>
<p>这种方式胜过工厂模式的地方就在于：可以将实例标识为一种特定的类型。</p>
<h4 id="1-构造函数当作普通函数"><a href="#1-构造函数当作普通函数" class="headerlink" title="1. 构造函数当作普通函数"></a>1. 构造函数当作普通函数</h4><p>既然实例化需要使用 new 操作符，万一不使用又会怎么样的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line">person.sayName();          <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="comment">// 当作普通函数使用</span></div><div class="line">Person(<span class="string">"young"</span>, <span class="number">24</span>, <span class="string">"fe"</span>); <span class="comment">// 添加到 window 对象中</span></div><div class="line"><span class="built_in">window</span>.sayName();          <span class="comment">// young</span></div><div class="line"></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"sasuke"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line">o.sayName();               <span class="comment">// sasuke</span></div></pre></td></tr></table></figure>
<h4 id="2-构造函数的问题"><a href="#2-构造函数的问题" class="headerlink" title="2. 构造函数的问题"></a>2. 构造函数的问题</h4><h5 id="2-1-每个方法有独立的内存，造成浪费。"><a href="#2-1-每个方法有独立的内存，造成浪费。" class="headerlink" title="2.1. 每个方法有独立的内存，造成浪费。"></a>2.1. 每个方法有独立的内存，造成浪费。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 虽然可以把函数定义转移到构造函数外</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age  = age;</div><div class="line">  <span class="keyword">this</span>.job  = job;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.Name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这样将其设置成了全局函数，但是新问题就是：全局函数却只能被某个对象调用，并且如果需要定义很多方法，就需要定义很多全局函数，也就是说毫无封装性可言。</p>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3. 原型模式"></a>6.2.3. 原型模式</h3><p>首先我们要知道每一个函数都有一个属性叫做 prototype，这个属性是一个指针，指向函数的原型对象。</p>
<blockquote>
<p>原型对象的用途：包含可以由特定类型的「所有实例」[共享]的属性和方法。</p>
</blockquote>
<p>换句话来说就是：所有对象实例可以一起通过这个 prototype 来共享属性和方法～=￣ω￣=～。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 属性</span></div><div class="line">Person.prototype.name = <span class="string">"steve"</span>;</div><div class="line">Person.prototype.age  = <span class="number">24</span>;</div><div class="line">Person.prototype.job  = <span class="string">"Web Developer"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 方法</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">// steve</span></div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true 共享同一个方法</span></div></pre></td></tr></table></figure>
<h4 id="1-深入理解原型对象"><a href="#1-深入理解原型对象" class="headerlink" title="1. 深入理解原型对象"></a>1. 深入理解原型对象</h4><ul>
<li>只要是函数，都有一个 prototype 指针，指向原型对象。</li>
<li>而原型对象默认会自动获得一个 constructor 指针，指向上一条中的函数。（你指我？我也指你→_→）</li>
<li>调用构造函数创建一个新实例后，实例内部也会获得一个 [[prototype]] 指针（ES5 中这么叫），指向原型对象（不是创造它的构造函数！）。</li>
</ul>
<h5 id="下面进行详细说明："><a href="#下面进行详细说明：" class="headerlink" title="下面进行详细说明："></a>下面进行详细说明：</h5><ul>
<li>第一条很好理解，当作大自然的规律来记就好啦，你否认也没用╮(╯▽╰)╭</li>
<li>第二条就是说原型对象与一般的对象最大的不同就是这个 constructor 指针，所以在重写构造函数的 prototype 时，要想与之前的原型对象保持一致，最好也加上这个 constructor 指针（显得专业嘛～=￣ω￣=～）。</li>
<li>第三条，其实在 Firefox、Safari 和 Chrome 中，[[prototype]] 就是 <code>__proto__</code> 指针。</li>
<li>ps 无论有没有 <code>__proto__</code> 指针，我们都可以通过 isPrototypeOf() 方法来确定对象之间是否存在原型关系。（<code>Person.prototype.isPrototypeOf(person1) // true</code>）</li>
<li>pps ES5 中增加了一个新方法 Object.getPrototypeOf() （<code>Object.getPrototypeOf(person1) === Person.prototype // true</code>）</li>
</ul>
<p>总结一下就是：构造函数有指向原型对象的指针(prototype)，原型对象也有指向构造函数的指针(constructor)，实例同样也有指向原型对象的指针([[prototype]])</p>
<hr>
<h5 id="那么这玩意儿这么复杂有啥用咧…"><a href="#那么这玩意儿这么复杂有啥用咧…" class="headerlink" title="那么这玩意儿这么复杂有啥用咧…?"></a>那么这玩意儿这么复杂有啥用咧…?</h5><p>简单举个栗子，上文中 6.2.3.原型模式一节中的两个实例(person1,person2)并不包含任何属性和方法，但是我们仍然可以调用 person1.sayName() 方法，这就是通过查找对象属性的过程实现的。</p>
<p>还有我们经常使用的各种数组方法(slice,splice,sort…)，同样也是定义在 Array.prototype 这个对象上的。</p>
<p>其实每当读取某个对象的某个属性时，都会执行一次搜索，目标就是给定的属性名。首先当然先搜索对象实例自身，如果没找到再继续搜索 [[prototype]] 指针指向的原型对象，如果找不到再向上查找…</p>
<p>所以实例的属性可以“屏蔽“原型链上的同名属性。（通过 delete 可以删除实力属性，消除屏蔽）</p>
<h6 id="a-那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？"><a href="#a-那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？" class="headerlink" title="a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？"></a>a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？</h6><p>很简单，使用 hasOwnProperty() 犯法。</p>
<h6 id="b-那么问题又来了，如果就是没有咋办？"><a href="#b-那么问题又来了，如果就是没有咋办？" class="headerlink" title="b. 那么问题又来了，如果就是没有咋办？"></a>b. 那么问题又来了，如果就是没有咋办？</h6><p>还记得 JavaScript 中的数据类型么，不平凡的那个引用类型 Object。我们使用的 Array、Function、Date、RegExp… 都是由 Object 派生而成。换句话说他们的原型对象都指向了 Object.prototype。最后 Object.prototype 又指向了 null。</p>
<p>所以如果寻找属性直到 Object.prototype 中都没有，从而找到 null。那么 JS 引擎就会抛出 undefined。</p>
<h4 id="2-原型与-in-操作符"><a href="#2-原型与-in-操作符" class="headerlink" title="2. 原型与 in 操作符"></a>2. 原型与 in 操作符</h4><p>in 操作符用来判断对象能否访问给定属性（前提是 enumerable 为 true），有两种方法使用 in 操作符：</p>
<ul>
<li>单独使用</li>
<li>在 for-in 循环中使用</li>
</ul>
<p>但由于 in 操作符不区分实例和原型链，所以日常使用中需要结合 hasOwnProperty() 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>) </span>&#123;</div><div class="line">  <span class="comment">// 判断是否是原型链上的属性</span></div><div class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外要取得对象上所有可枚举的实例属性，可以用 ES5 中的 Object.keys() 方法（返回数组）。</p>
<p>当然如果要取得所有实例属性，无论是否可枚举，可以用 Object.getOwnPropertyNames() 方法。</p>
<h4 id="3-更简单的原型方法"><a href="#3-更简单的原型方法" class="headerlink" title="3. 更简单的原型方法"></a>3. 更简单的原型方法</h4><p>日常使用中，每当要为原型对象添加一个属性或方法，都要敲一遍 Person.prototype，这样太不优雅了…</p>
<p>所以一般采用对象字面量将属性和方法都包起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person, <span class="comment">// 别忘了之前说过的 constructor 指针。</span></div><div class="line"></div><div class="line">  name: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span> : <span class="string">"Web Developer"</span>,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，如果你是个完美主义者，还有一点要注意：原生 constructor 属性是不可枚举的，所以可以用 Object.defineProperty() 将其改写回来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span> : <span class="string">"Web Developer"</span>,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">  <span class="attr">enumerable</span>  : <span class="literal">false</span>, <span class="comment">// 默认值，其实可以不写</span></div><div class="line">  writable    : <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">value</span>       : Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4. 原型的动态性"></a>4. 原型的动态性</h4><p>略，只要你了概（解）了指针是咩（什么）就大丈夫（没问题）。</p>
<h4 id="5-原型对象的原型"><a href="#5-原型对象的原型" class="headerlink" title="5. 原型对象的原型"></a>5. 原型对象的原型</h4><p>略，大概内容就是说了下俺们原生的对象和乃们“野生”对象一样也是有原型的╮(╯▽╰)╭。</p>
<h4 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6. 原型对象的问题"></a>6. 原型对象的问题</h4><p>问题其实是来自于自身共享的本性。</p>
<p>例如，包含引用类型的属性。由于引用类型实际上就是指针，所以所有实例操作的都是同一个引用对象，见下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line"></div><div class="line">  <span class="attr">name</span>   : <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span>    : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span>    : <span class="string">"Web Developer"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>],</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4. 组合使用构造函数模式和原型模式"></a>6.2.4. 组合使用构造函数模式和原型模式</h3><p>经过上文的讨论我们知道：</p>
<ul>
<li>构造函数模式可以为每个实例生成单独的属性，但无法共享。</li>
<li>原型模式可以共享，但无法为实例生成单独的属性。</li>
</ul>
<p>既然构造函数模式和原型模式的优缺点正好互补，那么为何不将两者结合，发挥各自的长处？</p>
<p>组合模式就是基于这一朴素的思想：</p>
<ul>
<li>构造函数用于定义实例属性</li>
<li>原型模式用于定义共享的属性和方法</li>
</ul>
<p>这样一来，每个实例都有自己的实例属性副本，但同时又共享着原型对象中的方法和属性，最大限度地节省了内存，还支持向构造函数中传递参数，可谓博采众长也～=￣ω￣=～。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name    = name;</div><div class="line">  <span class="keyword">this</span>.age     = age;</div><div class="line">  <span class="keyword">this</span>.job     = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"shirley"</span>, <span class="string">"jame"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"Web Developer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"nicholas"</span>, <span class="number">29</span>, <span class="string">"Soft Engineer"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5. 动态原型模式"></a>6.2.5. 动态原型模式</h3><p>本质其实还是组合模式，只不过把原型对象中共享的属性和方法，也封装在构造函数里…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name    = name;</div><div class="line">  <span class="keyword">this</span>.age     = age;</div><div class="line">  <span class="keyword">this</span>.job     = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"shirley"</span>, <span class="string">"jame"</span>];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="comment">// 不能使用对象字面量 Person.prototype = &#123;...&#125;;</span></div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"Web Developer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"nicholas"</span>, <span class="number">29</span>, <span class="string">"Soft Engineer"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6. 寄生构造函数模式"></a>6.2.6. 寄生构造函数模式</h3><p>首先一般来说，组合模式已经足够应付日常需求，所以这个模式是为了应对特殊需求：例如我们需要创建一个具有额外方法的特殊数组，但是不能直接修改 Array 的构造函数（见下例）。</p>
<p>具体形式上除了使用 new 操作符创建实例以外，和工厂模式一毛（模）一样（同样的问题）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 内部创建一个新数组</span></div><div class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">  <span class="comment">// 添加值</span></div><div class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 添加方法</span></div><div class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>); <span class="comment">// 注意：使用 new 创建实例</span></div><div class="line">alert(colors.toPipedString()); <span class="comment">// red|blue|green</span></div></pre></td></tr></table></figure>
<h4 id="这个模式其实利用了构造函数的特性："><a href="#这个模式其实利用了构造函数的特性：" class="headerlink" title="这个模式其实利用了构造函数的特性："></a>这个模式其实利用了构造函数的特性：</h4><ul>
<li>如果被调用的函数没有显式的 return 表达式，则隐式地会返回 this 对象 - 也就是新创建的隐式对象。</li>
<li>显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo().constructor === <span class="built_in">Number</span> <span class="comment">// false，返回新创建的隐式对象</span></div><div class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span> <span class="comment">// true，返回 Number 对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test()); <span class="comment">// &#123;foo: 1&#125;，返回的对象，this 对象被销毁了，value 丢失了</span></div></pre></td></tr></table></figure>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7. 稳妥构造函数模式"></a>6.2.7. 稳妥构造函数模式</h3><p>首先要介绍 Douglas Crockford 发明的「稳妥对象」(durable objects) 这个概念：没有公共属性，而且方法也不引用 this 的对象。</p>
<p>主要用在需要安全的环境（禁止 this 和 new），或者在防止数据被其他程序（如 Mashup）改动时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">//创建要返回的对象</span></div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">  <span class="comment">//可以在这里定义私有变量和函数</span></div><div class="line"></div><div class="line">  <span class="comment">//添加方法</span></div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); <span class="comment">// 注意：这里没有使用 this，因此我的理解是相当于闭包，保存住了外部 Person 的 AO（活动对象）</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//返回对象</span></div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"web developer"</span>);</div><div class="line">person.sayName(); <span class="comment">//"steve"</span></div></pre></td></tr></table></figure>
<p>这里变量 person 中保存的就是一个稳妥对象，因为除了调用 sayName() 方法以外，没有别的方法可以访问内部的数据。</p>
<p>即使有其他代码会给这个对象添加方法或数据，也无法访问传入到构造函数中的原始数据。</p>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3. 继承"></a>6.3. 继承</h2><p>许多面向对象的编程语言都支持两种继承方式：</p>
<ul>
<li>接口继承：只继承方法签名</li>
<li>实现继承：继承实际的方法</li>
</ul>
<p>在 ECMAScript 中由于函数没有签名，所以无法实现接口继承，只支持实现继承，而这正是依靠「原型链」来实现的。</p>
<h3 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1. 原型链"></a>6.3.1. 原型链</h3><p>既然这继承的关键在于「原型链」，我们就先来了概（解）下原型链的概念究竟是神马…</p>
<blockquote>
<p>基本思想：利用 prototype（原型对象），让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p>简单回顾一下之前讨论过的关于，构造函数、原型对象和实例的关系：</p>
<ul>
<li>每个构造函数都有一个指向自己原型对象的 prototype 指针。</li>
<li>原型对象又都包含一个指向构造函数的 constructor 指针。</li>
<li>实例都包含一个指向原型对象的 [[prototype]] 内部指针（<code>__proto__</code>）。</li>
</ul>
<h4 id="假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？"><a href="#假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？" class="headerlink" title="假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？"></a>假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> foo(); <span class="comment">// a 是父类 foo 的实例</span></div><div class="line">bar.prototype = a; <span class="comment">// 「原型对象 bar.prototype」等于另一个类型的「实例 a」</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> bar(); <span class="comment">// b 是子类 bar 的实例</span></div></pre></td></tr></table></figure>
<p>简单分析一下以上代码：</p>
<ul>
<li>「1」a 作为 foo 的实例，a 的内部指针 [[prototype]] 指向原型对象 foo.prototype。</li>
<li>「2」bar.prototype 被赋值为 a，所以相当于 bar.prototype 有内部指针 [[prototype]] 指向原型对象 foo.prototype。</li>
<li>「3」b 作为 bar 的实例，b 的内部指针 [[prototype]] 指向原型对象 bar.prototype。</li>
<li>「4」综上，这样便形成了一条：<code>b -&gt; bar.prototype -&gt; foo.prototype</code> 的原型链。</li>
<li>「5」假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，可以生成更长的原型链。</li>
</ul>
<p>以上就是原型链的基本概念…╮(╯_╰)╭</p>
<h4 id="下面再来看看一种实现原型链的基本模式"><a href="#下面再来看看一种实现原型链的基本模式" class="headerlink" title="下面再来看看一种实现原型链的基本模式"></a>下面再来看看一种实现原型链的基本模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 注意：使用 new 生成父类实例，重写了原型对象</span></div><div class="line"></div><div class="line"><span class="comment">// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）</span></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">// true，成功继承父类原型对象上的方法</span></div><div class="line">alert(instance.constructor);     <span class="comment">// SuperType，因为访问的是 Super.prototype 中的 constructor</span></div></pre></td></tr></table></figure>
<h4 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h4><p>其实，所有的引用类型都默认继承自 Object，而这个继承也是通过原型链实现的。所以所有自定义类型都能够使用 toString()、valueOf() 等方法。</p>
<h4 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h4><p>有两种方法确定原型和实例的关系：</p>
<ul>
<li>instanceof 操作符</li>
<li>isPrototypeof() 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">// true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">// true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SubType);   <span class="comment">// true</span></div><div class="line"></div><div class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeof(instance));    <span class="comment">// true</span></div><div class="line">alert(SuperType.prototype.isPrototypeof(instance)); <span class="comment">// true</span></div><div class="line">alert(SubType.prototype.isPrototypeof(instance));   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h4><p>子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，这点很好理解。</p>
<p>还要注意以下这种使用对象字面量创建原型方法的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// blabla...</span></div><div class="line"></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 注意：使用 new 生成父类实例，重写了原型对象</span></div><div class="line"></div><div class="line"><span class="comment">// 隐式地创建了一个新对象，改写了 SubType.prototype 的指针指向</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">  <span class="attr">getSubValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">someOtherMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h4><ul>
<li>引用类型属性的问题：相当于将父类属性添加到子类原型对象上形成共享。</li>
<li>创建子类实例时，不能向超类型的构造函数中传递参数：准确的说是无法在不影响所有对象实例的情况下，给父类的构造函数传递参数。</li>
</ul>
<h3 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2. 借用构造函数"></a>6.3.2. 借用构造函数</h3><p>在解决原型链以上问题的过程中，产生了一种叫做「借用构造函数（伪造对象、经典继承）」的技术。</p>
<p>基本思想是：在子类构造函数内部调用父类构造函数，主要通过 call() 和 apply() 方法实现。</p>
<h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p>相对于原型链而言，借用构造函数最大的优势就是解决了传递参数的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'steve'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">24</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name); <span class="comment">// steve</span></div><div class="line">alert(instance.age);  <span class="comment">// 24</span></div></pre></td></tr></table></figure>
<h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><p>源自于构造函数的问题：方法都在构造函数中定义，无法函数复用，子类方法也无法使用父类原型对象中的方法。</p>
<h3 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3. 组合继承"></a>6.3.3. 组合继承</h3><p>顾名思义，就是将原型链和借用构造函数结合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 借用构造函数继承属性</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用原型链继承了方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div></pre></td></tr></table></figure>
<p>虽然看起来结合了两者的优点，既能够传递参数，又能实现原型链继承，但是应该注意到 <code>SubType.prototype = new SuperType();</code> 一句。</p>
<p>我们的预期只是子类 SubType 拥有父类的属性，即 <code>SuperType.call(this, name);</code> 的工作。</p>
<p>但是 SubType.prototype 上也拥有了一个值为 undefined 的 name 属性和 colors 数组。这不是我们的本意，这就是直接使用 new 操作符将父类实例赋值给子类原型对象的副作用╮(╯▽╰)╭。</p>
<h4 id="要解决组合模式存在的问题，首先来看几个其他方式的继承。"><a href="#要解决组合模式存在的问题，首先来看几个其他方式的继承。" class="headerlink" title="要解决组合模式存在的问题，首先来看几个其他方式的继承。"></a>要解决组合模式存在的问题，首先来看几个其他方式的继承。</h4><h3 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4. 原型式继承"></a>6.3.4. 原型式继承</h3><p>由 Douglas Crockford（又是你→_→）在2006年的一篇文章中介绍，基本思想是：基于已有对象，借助原型创建新对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">  F.prototype = o;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即先创建一个临时性的构造函数 F，然后将传入的对象 o 作为这个构造函数的原型 <code>F.prototype</code>，最后返回这个临时类型的一个新实例 <code>new F()</code>。从本质上将就是对于传入的对象 o 进行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"young"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"sasuke"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"nicholas"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"jobs"</span>);</div><div class="line"></div><div class="line">alert(person.friends); <span class="comment">// shirley,jame,sasuke,jobs，friends 被共享了</span></div></pre></td></tr></table></figure>
<p>ES5 中新增了 Object.create() 方法规范化了原型式继承。可以接收两个参数，第一个参数就是要继承的对象，第二个对象是可选的一个为新对象定义额外属性的对象。其实只传一个参数时，两个方法行为相同。</p>
<p>第二个参数与 Object.defineProperties() 方法的第二个参数格式相同（覆盖同名属性），见下例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">  <span class="attr">name</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"greg"</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">// greg</span></div></pre></td></tr></table></figure>
<h3 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5. 寄生式继承"></a>6.3.5. 寄生式继承</h3><p>基本思路类似用工厂模式包装原型式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 原型式继承对象 original</span></div><div class="line"></div><div class="line">  <span class="comment">// 增强对象</span></div><div class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi"</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// Hi</span></div></pre></td></tr></table></figure>
<h3 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6. 寄生组合式继承"></a>6.3.6. 寄生组合式继承</h3><p>首先实力吹一波：作为压轴出场的终极继承方式，几乎是最理想的继承范式。</p>
<p>前面在介绍组合继承的时候说到了主要问题出在 <code>SubType.prototype = new SuperType();</code> 这句。它将父类构造函数中的属性也添加到了子类原型对象中，而这不符合我们的期望。</p>
<blockquote>
<p>其实让我们回到需求本身：我们希望子类的原型对象能够指向父类的原型对象，实现原型链继承。</p>
</blockquote>
<p>那么想一想 6.3.4. 原型式继承，我们让子类原型式继承父类的原型对象不就完美了么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 借用构造函数，继承父类属性（解决了传参）</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = <span class="built_in">Object</span>.create(SuperType.prototype, &#123;</div><div class="line">  <span class="attr">constructor</span>: &#123;</div><div class="line">    <span class="attr">value</span>       : SubType, <span class="comment">// 指回子类构造函数</span></div><div class="line">    enumerable  : <span class="literal">false</span>,   <span class="comment">// 默认值，其实可以不写</span></div><div class="line">    writable    : <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）</span></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4. 小结"></a>6.4. 小结</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li>工厂模式：简单地在函数内部创建对象，添加属性和方法，然后返回对象。</li>
<li>构造函数模式：在函数内部使用 this 添加属性和方法，可以创建自定义引用类型，可以使用 new 操作符创建实例。但是无法实现函数复用，造成内存浪费等问题。</li>
<li>原型模式：使用构造函数的 prototype 属性来指定共享的属性和方法，本质上就是为了共享而生。</li>
<li>组合模式：结合构造函数和原型模式的优点。</li>
</ul>
<h3 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h3><ul>
<li>原型链：将父类的实例赋值给子类构造函数的原型对象。但这样会有两个问题：传参和子类原型上有多余的父类构造函数中的属性。</li>
<li>借用构造函数：为了解决传参问题，采用在子类中调用父类构造函数的方法。</li>
<li>原型式：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。</li>
<li>寄生组合式：巧妙利用原型式继承解决原型链中的第二个问题，是基于类型继承的最好方式。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h2&gt;&lt;p&gt;最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。&lt;/p&gt;
&lt;h3 id=&quot;同样按照书本的顺序分为如下三部分&quot;&gt;&lt;a href=&quot;#同样按照书本的顺序分为如下三部分&quot; class=&quot;headerlink&quot; title=&quot;同样按照书本的顺序分为如下三部分&quot;&gt;&lt;/a&gt;同样按照书本的顺序分为如下三部分&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;理解对象属性&lt;/li&gt;
&lt;li&gt;理解并创建对象&lt;/li&gt;
&lt;li&gt;理解继承&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="全栈" scheme="https://buptsteve.github.io/blog/categories/%E5%85%A8%E6%A0%88/"/>
    
    
      <category term="JavaScript" scheme="https://buptsteve.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>「4」Byrs-News 建站笔记（一）</title>
    <link href="https://buptsteve.github.io/blog/2016/03/16/4.%20byrs-news%20notes%201/"/>
    <id>https://buptsteve.github.io/blog/2016/03/16/4. byrs-news notes 1/</id>
    <published>2016-03-16T03:27:58.000Z</published>
    <updated>2016-10-14T02:56:45.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>差不多结束了在移动研究院快一年的实习，加上马上到来的寒假，想着闲着也是闲着不然做个网站练练手吧╮(╯▽╰)╭</p>
<p>于是在寒假里就捣鼓了这么个网站 <a href="http://182.254.241.100" target="_blank" rel="external">Byrs-News</a> | <a href="https://github.com/BuptStEve/byrs-news" target="_blank" rel="external">开源地址</a>，主要内容是通过爬虫 <a href="https://github.com/BuptStEve/byr-crawler" target="_blank" rel="external">Byr-Crawler</a> 对于北邮人论坛帖子进行定时爬取，在收集整理之后希望大家能够更加“优雅地”浏览论坛～=￣ω￣=～。</p>
<a id="more"></a>
<h2 id="一、技术栈"><a href="#一、技术栈" class="headerlink" title="一、技术栈"></a>一、技术栈</h2><ul>
<li>网站采用了 Meteor.js 全栈式开发</li>
<li>数据库选择了 MongoDB 进行存储</li>
<li>内容获取来自自己编写的 Node.js 爬虫</li>
</ul>
<p>那么首先问题来了…</p>
<h3 id="1-1-Meteor-是个什么玩意儿？"><a href="#1-1-Meteor-是个什么玩意儿？" class="headerlink" title="1.1. Meteor 是个什么玩意儿？"></a>1.1. Meteor 是个什么玩意儿？</h3><p>Meteor 是一个只使用 JavaScript 就可以开发 Web 和移动端应用的全栈框架。主要特点有：</p>
<ul>
<li>一种语言(One Language)：JavaScript（就可以搞定服务器、浏览器、移动设备）。</li>
<li>传递数据(Data on the wire)：服务器和客户端之间传递的是数据（而不是 html），由客户端进行数据的渲染。</li>
<li>无处不在的数据库(Database everywhere)：从客户机或服务器上使用相同、透明的 API 访问数据库。（在浏览器端实现了 Minimongo）</li>
<li>延迟补偿(Latency Compensation)：使用预读和模式模拟技术，使之看起来与数据库的连接是零延迟的。</li>
<li>全栈响应式(Full Stack Reactivity)：代码所依赖的数据发生变化时，结果 会自动重新计算。（并不是指响应式）</li>
<li>拥抱生态(Embrace the Ecosystem)：开源、与现有工具和框架整合，而不是取代。</li>
<li>简单等于生产力(Simplicity Equals Productivity)：让一件事看起来简单的最佳方式就是「真正」让它变得简单。</li>
</ul>
<blockquote>
<p>我的感受是使用 Meteor.js 可以在只用一种语言（JavaScript）的情况下，「超快速」地开发出一个功能完善的现代网站。</p>
</blockquote>
<h4 id="还有疑问？"><a href="#还有疑问？" class="headerlink" title="还有疑问？"></a>还有疑问？</h4><p>Take it easy.且看我后文慢慢道来…</p>
<h3 id="1-2-为什么选择-MongoDB？"><a href="#1-2-为什么选择-MongoDB？" class="headerlink" title="1.2. 为什么选择 MongoDB？"></a>1.2. 为什么选择 MongoDB？</h3><ul>
<li>首先当然是因为它是 Meteor 的默认数据库呀╮(╯▽╰)╭</li>
<li>其次作为一个 NoSQL 数据库比传统关系型数据库更加灵活，更加适用于互联网应用场景</li>
<li>我可以在爬虫运行过程中可以更加方便地修改文档结构</li>
<li>…</li>
</ul>
<h3 id="1-3-为什么是-Node-js-爬虫？"><a href="#1-3-为什么是-Node-js-爬虫？" class="headerlink" title="1.3. 为什么是 Node.js 爬虫？"></a>1.3. 为什么是 Node.js 爬虫？</h3><p>因为正好最近在学习 Node.js，还有保持项目只有一种语言。</p>
<h2 id="二、项目规范"><a href="#二、项目规范" class="headerlink" title="二、项目规范"></a>二、项目规范</h2><h3 id="2-1-命名规范"><a href="#2-1-命名规范" class="headerlink" title="2.1. 命名规范"></a>2.1. 命名规范</h3><ul>
<li>文件夹和文件采用小写字母，用下划线 _ 连接。</li>
<li>JavaScript 文件中的内容采用驼峰命名法（因为毕竟它自己就是用的驼峰╮(╯▽╰)╭）。</li>
<li>CSS 文件中的内容采用连字符 - 连接（因为本来 CSS 语法就是用连字符，如 font-family 等）。</li>
</ul>
<h3 id="2-2-文件夹规范"><a href="#2-2-文件夹规范" class="headerlink" title="2.2. 文件夹规范"></a>2.2. <a href="http://docs.meteor.com/#/full/structuringyourapp" target="_blank" rel="external">文件夹规范</a></h3><p>由于是一个全栈式框架（代码写一块儿╮(╯▽╰)╭），所以文件夹的名字十分地重要。因为会影响 Meteor 对其加载的顺序（见下文）。</p>
<p>一般来说有在顶级项目目录下有以下规范的命名：</p>
<ul>
<li>client/ : 放置所有的客户端代码，Meteor 也不会将其在服务端加载。</li>
<li>server/ : 放置所有的服务端代码，Meteor 也不会将其在客户端加载。</li>
<li>public/ : 放置静态资源，例如 favicon.ico, robots.txt 等。</li>
<li>node_modules/ : Node.js 模块代码。（比如 cz-conventional-changelog）</li>
<li>tests/ : 本地测试代码。</li>
<li>private/ : 只能被服务器端代码获取，可以通过 <a href="http://docs.meteor.com/#/full/assets" target="_blank" rel="external">Assets</a> API 读取。（不常用）</li>
<li>client/compatibility/ : 只能被服务器端代码获取，可以通过 <a href="http://docs.meteor.com/#/full/assets" target="_blank" rel="external">Assets</a> API 读取。（不常用）</li>
<li>lib/ : 放置服务端和客户端共用的代码，比如 config.js、数据库文件夹 collections/。</li>
</ul>
<h4 id="加载顺序（了解即可）"><a href="#加载顺序（了解即可）" class="headerlink" title="加载顺序（了解即可）"></a>加载顺序（了解即可）</h4><ul>
<li>应用根目录内 lib 文件夹下的文件首先加载。</li>
<li>符合 main.* 这个格式的文件最后加载。</li>
<li>子目录中的文件在母目录中的文件之前加载，即最深层子目录中的文件首先加载（在 lib 之后），根目录的文件最后加载（在 main.* 之前）。</li>
<li>同目录下的文件，按文件名的字母顺序来加载。</li>
</ul>
<h2 id="三、重要参考资料"><a href="#三、重要参考资料" class="headerlink" title="三、重要参考资料"></a>三、重要参考资料</h2><ul>
<li><a href="https://www.meteor.com/" target="_blank" rel="external">官网</a></li>
<li><a href="https://www.meteor.com/install" target="_blank" rel="external">官方快速入门教程: 学习点这</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/meteor" target="_blank" rel="external">StackOverflow: 碰到问题点这</a></li>
<li><a href="https://forums.meteor.com/" target="_blank" rel="external">官方论坛</a></li>
<li><a href="https://github.com/meteor/meteor/" target="_blank" rel="external">Github</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h2&gt;&lt;p&gt;差不多结束了在移动研究院快一年的实习，加上马上到来的寒假，想着闲着也是闲着不然做个网站练练手吧╮(╯▽╰)╭&lt;/p&gt;
&lt;p&gt;于是在寒假里就捣鼓了这么个网站 &lt;a href=&quot;http://182.254.241.100&quot;&gt;Byrs-News&lt;/a&gt; | &lt;a href=&quot;https://github.com/BuptStEve/byrs-news&quot;&gt;开源地址&lt;/a&gt;，主要内容是通过爬虫 &lt;a href=&quot;https://github.com/BuptStEve/byr-crawler&quot;&gt;Byr-Crawler&lt;/a&gt; 对于北邮人论坛帖子进行定时爬取，在收集整理之后希望大家能够更加“优雅地”浏览论坛～=￣ω￣=～。&lt;/p&gt;
    
    </summary>
    
      <category term="全栈" scheme="https://buptsteve.github.io/blog/categories/%E5%85%A8%E6%A0%88/"/>
    
    
      <category term="meteor" scheme="https://buptsteve.github.io/blog/tags/meteor/"/>
    
  </entry>
  
  <entry>
    <title>「3」前端开发利器 webpack</title>
    <link href="https://buptsteve.github.io/blog/2015/12/29/3.%20js-webpack/"/>
    <id>https://buptsteve.github.io/blog/2015/12/29/3. js-webpack/</id>
    <published>2015-12-29T07:12:58.000Z</published>
    <updated>2016-10-14T02:56:45.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>在编写构建前端项目时，以下这些需求想必十分常见：</p>
<ol>
<li>html/css/js 代码的预编译：  <ul>
<li>Jade, Ejs…</li>
<li>Sass, Less, Stylus…</li>
<li>Dart, CoffeeScript, TypeScript, ES6/7… </li>
</ul>
</li>
<li>拯救你的 F5 或者 Command/Ctrl + R（即自动监听、编译并刷新浏览器）</li>
<li>发布时的代码压缩、混淆，图片的压缩和 base64 嵌入</li>
</ol>
<blockquote>
<p><strong>以上这些「体力♂活儿」显然不能自己浪费时间手动完成，so 优雅的解决方式就是：自动化构建工具咯～=￣ω￣=～！</strong></p>
</blockquote>
<a id="more"></a>
<p>话说我最早了解到前端自动化构建工具，是通过慕课网学习的时候看到的 grunt 教程，随意浏览了点儿发现上手有点儿难 _(:зゝ∠)_ 同时也没有什么需求就没有学下去。  </p>
<p>然后学习了 less/sass/stylus 等预编译语言，先是使用了 <a href="http://koala-app.com/index-zh.html" target="_blank" rel="external">koala</a> 进行 less 文件的编译。之后又有了「拯救 F5」的需求，觉得再使用 <a href="http://livereload.com/" target="_blank" rel="external">livereload</a> 这样不够绅士(´･ω･`)。于是开始学习 gulp， gulp 是基于 Unix 的哲♂学，即 </p>
<blockquote>
<p>Do one thing and do it well.  </p>
</blockquote>
<p>类似于 Unix 的管道命令（pipe：| ），gulp 基于 Node.js 中的 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">stream</a> 机制。Gulp 的每个插件从 stream 中读取输入，做一些处理，再输出到stream中。同时使用 <a href="https://www.npmjs.com/package/browser-sync" target="_blank" rel="external">browser-sync</a> 插件能够解决我的重复刷新的繁重劳动。</p>
<p>无奈前端变化太快_(:зゝ∠)_，使用 gulp 没多久。通过 <a href="http://cn.vuejs.org" target="_blank" rel="external">vue.js</a> 一个 MVVM 框架，知道了 webpack 这一新的前端自动化构建工具。使用 webpack 可以方便地将 <code>*.vue</code>文件编译打包到工程中，并且 react 的大部分项目也使用 webpack 进行构建。那么问题来了，webpack 究竟靠什么火起来了呢？</p>
<h2 id="一、webpack"><a href="#一、webpack" class="headerlink" title="一、webpack"></a>一、webpack</h2><h3 id="1-1-为什么选择-webpack-参考链接"><a href="#1-1-为什么选择-webpack-参考链接" class="headerlink" title="1.1. 为什么选择 webpack ? 参考链接"></a>1.1. 为什么选择 webpack ? <a href="http://webpack.github.io/docs/motivation.html" target="_blank" rel="external">参考链接</a></h3><h4 id="a-首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？"><a href="#a-首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？" class="headerlink" title="a. 首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？"></a>a. 首先要明确：随着前端越来越「重」，项目变得越来越大，团队人数增加、功能增加地越多，势必引起出错、依赖情况的出现。那么想想服务器端、桌面大型程序等是怎么做的呢？</h4><p>答案只有一个：</p>
<blockquote>
<p>模块化开发！</p>
<p>然而浏览器本身并不提供模块管理的机制（ES6 终于引入 Module），为了调用各个模块，有时不得不在网页中，加入一大堆script标签。这样就使得网页体积臃肿，难以维护，还产生大量的HTTP请求，拖慢显示速度，影响用户体验。  </p>
<p>在此对于模块化就不继续展开了…Require.js/Sea.js/Common.js/AMD/CMD/ES6…etc.</p>
</blockquote>
<h4 id="b-明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？"><a href="#b-明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？" class="headerlink" title="b. 明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？"></a>b. 明确了模块化开发这一前提之后，那么新的问题又来了…模块化之后的文件怎么从服务器传递到客户端（浏览器）？</h4><p><strong>有两种「极端」的方式</strong>：  </p>
<ul>
<li>每一个请求传送一个模块（类似于一堆的 <srcipt> 标签…）</srcipt></li>
<li>一个请求传送所有模块（例如 browserify 的打包方式）  </li>
</ul>
<p>这两种方式方式各有优缺点：  </p>
<ol>
<li>优点：只加载需要的模块；缺点：大量请求会使得启动缓慢…</li>
<li>优点：请求数少，等待时间少；缺点：不需要的模块同样被传送了…</li>
</ol>
<p>因此，在大多数的情况下最佳实践应该是一个折中的方案：  </p>
<blockquote>
<p>在编译所有模块时，将模块细分成为多个小的 batches(chunks)，于是我们分解得到了许多请求。模块的 chunks 初始状态时并没有全部加载，只在需要的时候发起请求。因此初始请求不会包含所有的代码，显然加载的代码量更小，速度更快。  </p>
</blockquote>
<p>其中关键的「分割点」即 chunks 的划分边界，是取决于开发者并且是可选的。</p>
<h4 id="c-此外还有一个重要原因：webpack-支持模块热替换（HMR）（例如-react-hot-loader）"><a href="#c-此外还有一个重要原因：webpack-支持模块热替换（HMR）（例如-react-hot-loader）" class="headerlink" title="c. 此外还有一个重要原因：webpack 支持模块热替换（HMR）（例如 react-hot-loader）"></a>c. 此外还有一个重要原因：webpack 支持<strong>模块热替换（HMR）</strong>（例如 <a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="external">react-hot-loader</a>）</h4><p>针对浏览器自动刷新，LiveReload 和 Browser-sync 是两款常用的工具，然而 HMR 更进了一步。我们知道 React 出现的原因之一就是<strong>积累用户在浏览器中的状态</strong>，而 HMR 能够在修改代码保存之后仍然保存之前的状态，就是俗称的「热替换」。</p>
<h3 id="1-2-怎么使用-webpack？"><a href="#1-2-怎么使用-webpack？" class="headerlink" title="1.2. 怎么使用 webpack？"></a>1.2. 怎么使用 webpack？</h3><p>了解了为什么（why）之后，接着学习怎么做（how）。</p>
<h4 id="a-webpack-的安装："><a href="#a-webpack-的安装：" class="headerlink" title="a. webpack 的安装："></a>a. webpack 的安装：</h4><ul>
<li>首先使用 npm 全局安装 webpack：  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) -g webpack</div></pre></td></tr></table></figure>
<ul>
<li>接着局部安装 webpack：  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) --save-dev webpack</div></pre></td></tr></table></figure>
<h4 id="b-webpack-的配置：官方文档、Pete-Hunt"><a href="#b-webpack-的配置：官方文档、Pete-Hunt" class="headerlink" title="b. webpack 的配置：官方文档、Pete Hunt"></a>b. webpack 的配置：<a href="http://webpack.github.io/docs/configuration.html" target="_blank" rel="external">官方文档</a>、<a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="external">Pete Hunt</a></h4><p>webpack 配置的本质就是：一个配置的 Object。</p>
<p>因此有两种使用方法配置 webpack:</p>
<ul>
<li>一种是 Cli（即 Command Line Interface）方法：读取 webpack.config.js 文件；</li>
<li>另一种是 Node.js API 的方法：传递配置对象作为参数。</li>
</ul>
<p>前端一般使用第一种，即配置 webpack.config.js 文件，简单例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./main.js'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>就是设置入口、出口文件，炒鸡简单有木有~</p>
</blockquote>
<p>接着我们需要进行一些预编译工作，例如把 CoffeeScript 或 ES6 的代码编译为 ES5 的 JavaScript，例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./main.js'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">filename</span>: <span class="string">'bundle.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.coffee$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'coffee-loader'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel-loader'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>只需要加入 loader，loader 中的 test 表示哪些文件需要经过 loader 进行处理。</p>
</blockquote>
<p>对于 css 和 图片资源同样也有 loader，这样就可以像引用 js 一样在代码中引用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'./bootstrap.css'</span>);</div><div class="line"><span class="built_in">require</span>(<span class="string">'./myapp.less'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</div><div class="line">img.src = <span class="built_in">require</span>(<span class="string">'./glyph.png'</span>);</div></pre></td></tr></table></figure>
<p>loader 的编写类似于之前的例子：（!用于链式操作）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./main.js'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">path</span>: <span class="string">'./build'</span>, <span class="comment">// This is where images AND js will go</span></div><div class="line">        publicPath: <span class="string">'http://mycdn.com/'</span>, <span class="comment">// This is used to generate URLs to e.g. images</span></div><div class="line">        filename: <span class="string">'bundle.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">module</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>: [&#123;</div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</div><div class="line">                <span class="attr">loader</span>: <span class="string">'style-loader!css-loader!less-loader'</span></div><div class="line">            &#125;, <span class="comment">// use ! to chain loaders</span></div><div class="line">            &#123;</div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">                <span class="attr">loader</span>: <span class="string">'style-loader!css-loader'</span></div><div class="line">            &#125;, &#123;</div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png|jpg)$/</span>,</div><div class="line">                <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span></div><div class="line">            &#125; <span class="comment">// inline base64 URLs for &lt;=8k images, direct URLs for the rest</span></div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>last but not the least:  添加 webpack-dev-server 作为实时代码更新</strong><br>安装完成后只需添加两行代码到 webpack.config.js 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    ...</div><div class="line">    entry: [</div><div class="line">        <span class="string">'webpack-dev-server/client?http://0.0.0.0:8080'</span>,</div><div class="line">        <span class="string">'webpack/hot/only-dev-server'</span>,</div><div class="line">        <span class="string">'./app/main.js'</span></div><div class="line">    ],</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>并且在 package.json 中的 scripts 添加一行代码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"scripts"</span>: &#123;</div><div class="line">        <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --devtool eval --progress --colors --hot --content-base build"</span></div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在日常开发中只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run dev</div></pre></td></tr></table></figure>
<p>在浏览器中访问 <code>http://localhost:8080</code> 即可看到编译结果，并且更改代码后能够自动刷新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h2&gt;&lt;p&gt;在编写构建前端项目时，以下这些需求想必十分常见：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;html/css/js 代码的预编译：  &lt;ul&gt;
&lt;li&gt;Jade, Ejs…&lt;/li&gt;
&lt;li&gt;Sass, Less, Stylus…&lt;/li&gt;
&lt;li&gt;Dart, CoffeeScript, TypeScript, ES6/7… &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拯救你的 F5 或者 Command/Ctrl + R（即自动监听、编译并刷新浏览器）&lt;/li&gt;
&lt;li&gt;发布时的代码压缩、混淆，图片的压缩和 base64 嵌入&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;以上这些「体力♂活儿」显然不能自己浪费时间手动完成，so 优雅的解决方式就是：自动化构建工具咯～=￣ω￣=～！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="https://buptsteve.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="效率" scheme="https://buptsteve.github.io/blog/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="webpack" scheme="https://buptsteve.github.io/blog/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>「2」如何搭建自己的服务器？</title>
    <link href="https://buptsteve.github.io/blog/2015/11/03/2.%20centos-server/"/>
    <id>https://buptsteve.github.io/blog/2015/11/03/2. centos-server/</id>
    <published>2015-11-03T05:04:58.000Z</published>
    <updated>2015-12-29T02:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、问题的由来？"><a href="#零、问题的由来？" class="headerlink" title="零、问题的由来？"></a>零、问题的由来？</h2><p>平时逛<a href="http://bbs.byr.cn" target="_blank" rel="external">北邮人论坛</a>看到各种大神做的各种作品，技痒难耐，也想自己捣鼓捣鼓、学习服务器。<br>正好实验室有空闲电脑，就自己搭一个玩儿啦～=￣ω￣=～。<br>在纠结半天，看了好多资(si)料(bi)后，决定选用 CentOS 作为操作系统， 主要开发环境为 Python 和 Node.js。</p>
<a id="more"></a>
<h2 id="一、系统安装"><a href="#一、系统安装" class="headerlink" title="一、系统安装"></a>一、系统安装</h2><p>（怎么获取镜像就不赘述了～=￣ω￣=～）</p>
<ol>
<li>利用 <a href="http://cn.ultraiso.net" target="_blank" rel="external">ultraISO</a> 将镜像文件拷入 u 盘内</li>
<li>设置 BIOS，优先从 u 盘启动</li>
<li>按照步骤安装…</li>
</ol>
<h2 id="二、网关问题"><a href="#二、网关问题" class="headerlink" title="二、网关问题"></a>二、网关问题</h2><p>由于北邮校内使用 ipv4 流量需要登录网关╮(╯_╰)╭，下面介绍两种方法：</p>
<h3 id="2-1-VNC"><a href="#2-1-VNC" class="headerlink" title="2.1. VNC"></a>2.1. VNC</h3><p>CentOS 可以使用 tigervnc，使用 yum 即可安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum install tigervnc</div><div class="line">$ yum install tigervnc-server</div></pre></td></tr></table></figure>
<p>安装完成后，使用命令<code>vncserver :n</code> 打开相应端口n<br>（这里的n是sessionnumber，不指定默认为1，也可以是2、3等等。第一次会提示输入密码，以后可以使用vncpasswd命令修改密码。）</p>
<blockquote>
<p>当然别忘了设置 iptables…<br>小白就 <code>iptables -F</code> 吧╮(╯▽╰)╭</p>
</blockquote>
<p>之后就可以从本地 vncviewer 连接啦…</p>
<h3 id="2-2-命令行（推荐）"><a href="#2-2-命令行（推荐）" class="headerlink" title="2.2. 命令行（推荐）"></a>2.2. 命令行（推荐）</h3><p>网关登录还可以使用 curl 命令：</p>
<ul>
<li>登录：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl <span class="_">-d</span> <span class="string">'DDDDD=「你的帐号」&amp;upass=「你的密码」&amp;AMKKey='</span> 10.3.8.211</div></pre></td></tr></table></figure>
<ul>
<li>注销：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl 10.3.8.211/F.htm</div></pre></td></tr></table></figure>
<h2 id="三、Python-3-环境"><a href="#三、Python-3-环境" class="headerlink" title="三、Python 3 环境"></a>三、Python 3 环境</h2><p>由于 CentOS 自带 Python 为 2.7.5 版本（最好不要卸载，因为会被 yum 使用╮(╯_╰)╭），<br>而我日常使用 3.0+ 所以需要更新 Python 版本。下面介绍一种两个环境共存的方法（以 3.5 版本为例）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz</div></pre></td></tr></table></figure>
<ul>
<li>下载 Python 3.5.0 ，之后解压，安装…</li>
<li>C Complier问题：在上一步安装 Python3 的过程中执行 <code>./configure</code> 时报错，原来是没有 C Complier…</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install gcc</div></pre></td></tr></table></figure>
<ul>
<li>继续安装 Python3</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./configure --prefix=/opt/python3</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<ul>
<li>验证是否安装成功</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ /opt/python3/bin/python3 -V</div></pre></td></tr></table></figure>
<ul>
<li>重要事项！</li>
</ul>
<p>由于此种方法仍保留了原系统中的 Python2 ，因此别忘了在自己编写的 Python3 脚本中加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/opt/python3/bin/python3</span></div></pre></td></tr></table></figure>
<p>即，选择 python3 进行解析。</p>
<h2 id="四、Node-js-环境"><a href="#四、Node-js-环境" class="headerlink" title="四、Node.js 环境"></a>四、Node.js 环境</h2><h3 id="4-1-选择通过-EPEL-Extra-Packages-for-Enterprise-Linux，企业版-Linux-的额外软件包-来安装-Node-js"><a href="#4-1-选择通过-EPEL-Extra-Packages-for-Enterprise-Linux，企业版-Linux-的额外软件包-来安装-Node-js" class="headerlink" title="4.1. 选择通过 EPEL(Extra Packages for Enterprise Linux，企业版 Linux 的额外软件包)来安装 Node.js"></a>4.1. 选择通过 EPEL(Extra Packages for Enterprise Linux，企业版 Linux 的额外软件包)来安装 Node.js</h3><blockquote>
<p>EPEL 是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。这个源兼容 RHEL 及像 CentOS 和 Scientific Linux 这样的衍生版本。  </p>
<p>我们可以很容易地通过yum命令从EPEL源上获取上万个在CentOS自带源上没有的软件。EPEL提供的软件包大多基于其对应的Fedora软件包，不会与企业版Linux发行版本的软件发生冲突或替换其文件。  </p>
<p>更多关于 EPEL 项目的细节可以 <a href="https://fedoraproject.org/wiki/EPEL" target="_blank" rel="external">点击这里</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum install epel-release</div><div class="line">$ yum install nodejs npm</div></pre></td></tr></table></figure>
<h3 id="4-2-仓库问题"><a href="#4-2-仓库问题" class="headerlink" title="4.2. 仓库问题"></a>4.2. 仓库问题</h3><p>由于 GFW 的原因，可能使用自带 registry 会太慢或者失败╮(╯_╰)╭</p>
<p>推荐一个帮助切换仓库的 npm 包 <a href="https://github.com/Pana/nrm" target="_blank" rel="external">Pana/nrm</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) -g nrm</div></pre></td></tr></table></figure>
<h4 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 列出可用仓库</div><div class="line">$ nrm ls</div><div class="line"></div><div class="line">* npm ---- https://registry.npmjs.org/</div><div class="line">  cnpm --- http://r.cnpmjs.org/</div><div class="line">  taobao - http://registry.npm.taobao.org/</div><div class="line">  eu ----- http://registry.npmjs.eu/</div><div class="line">  au ----- http://registry.npmjs.org.au/</div><div class="line">  sl ----- http://npm.strongloop.com/</div><div class="line">  nj ----- https://registry.nodejitsu.com/</div><div class="line">  pt ----- http://registry.npmjs.pt/</div><div class="line"></div><div class="line">// 切换仓库到 cnpm</div><div class="line">$ nrm use cnpm  </div><div class="line"></div><div class="line">    Registry has been <span class="built_in">set</span> to: http://r.cnpmjs.org/</div></pre></td></tr></table></figure>
<h3 id="3-切换-Node-js-版本"><a href="#3-切换-Node-js-版本" class="headerlink" title="3. 切换 Node.js 版本"></a>3. 切换 Node.js 版本</h3><p>推荐 tj 大神的神器 <a href="https://github.com/tj/n" target="_blank" rel="external">tj/n</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) -g n</div></pre></td></tr></table></figure>
<h4 id="使用介绍-1"><a href="#使用介绍-1" class="headerlink" title="使用介绍"></a>使用介绍</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 安装 0.8.14/0.8.17/0.9.6 三个版本的 nodejs</div><div class="line">$ n 0.8.14</div><div class="line">$ n 0.8.17</div><div class="line">$ n 0.9.6</div><div class="line"></div><div class="line">// 选择版本（移动上下箭头，回车或右键头选择，Ctrl+C 取消）</div><div class="line">$ n</div><div class="line">  0.8.14</div><div class="line">ο 0.8.17</div><div class="line">  0.9.6</div><div class="line"></div><div class="line">// 删除 0.9.4 版本</div><div class="line">$ n - 0.9.4</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、问题的由来？&quot;&gt;&lt;a href=&quot;#零、问题的由来？&quot; class=&quot;headerlink&quot; title=&quot;零、问题的由来？&quot;&gt;&lt;/a&gt;零、问题的由来？&lt;/h2&gt;&lt;p&gt;平时逛&lt;a href=&quot;http://bbs.byr.cn&quot;&gt;北邮人论坛&lt;/a&gt;看到各种大神做的各种作品，技痒难耐，也想自己捣鼓捣鼓、学习服务器。&lt;br&gt;正好实验室有空闲电脑，就自己搭一个玩儿啦～=￣ω￣=～。&lt;br&gt;在纠结半天，看了好多资(si)料(bi)后，决定选用 CentOS 作为操作系统， 主要开发环境为 Python 和 Node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="后端" scheme="https://buptsteve.github.io/blog/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Linux" scheme="https://buptsteve.github.io/blog/tags/Linux/"/>
    
      <category term="Server" scheme="https://buptsteve.github.io/blog/tags/Server/"/>
    
      <category term="Python" scheme="https://buptsteve.github.io/blog/tags/Python/"/>
    
      <category term="Node.js" scheme="https://buptsteve.github.io/blog/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>「1」优雅地打开软件是怎样的体验？</title>
    <link href="https://buptsteve.github.io/blog/2015/11/01/1.%20the-way-to-open-software/"/>
    <id>https://buptsteve.github.io/blog/2015/11/01/1. the-way-to-open-software/</id>
    <published>2015-11-01T11:04:58.000Z</published>
    <updated>2016-10-14T09:03:34.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、问题的由来"><a href="#零、问题的由来" class="headerlink" title="零、问题的由来"></a>零、问题的由来</h2><p>不知道大家平时是怎么打开常用软件的：</p>
<h3 id="1-windows-用户："><a href="#1-windows-用户：" class="headerlink" title="1. windows 用户："></a>1. windows 用户：</h3><ul>
<li>从桌面上一堆杂乱的文件中找到快捷方式双击打开？</li>
<li>从桌面上分类整理好的文件夹中找到快捷方式双击打开？</li>
<li>同样利用 <a href="http://www.stardock.com/products/fences/" target="_blank" rel="external">Fences</a> 从桌面选择？</li>
<li>利用 <a href="http://www.voidtools.com/" target="_blank" rel="external">Everything</a> 进行文件名搜索？</li>
<li>win8下，win10下 blablabla…</li>
</ul>
<h3 id="2-OS-X-用户："><a href="#2-OS-X-用户：" class="headerlink" title="2. OS X 用户："></a>2. OS X 用户：</h3><a id="more"></a>
<ul>
<li>通过在 Dock 中寻找后，单击打开？</li>
<li>通过拇指与其他三个手指合拢进入 Launchpad 后，单击打开？</li>
<li>利用自带的 spotlight 或者 <a href="https://www.alfredapp.com/" target="_blank" rel="external">alfred</a> 等工具输入软件名打开？</li>
<li>通过终端…</li>
</ul>
<h3 id="3-linux-用户："><a href="#3-linux-用户：" class="headerlink" title="3. linux 用户："></a>3. linux 用户：</h3><ul>
<li>通过终端…</li>
<li>要啥自行车…╮(╯▽╰)╭… <del>(才不会告诉你是因为我不造呢…)</del></li>
</ul>
<h2 id="一、我的选择～-￣ω￣-～-私のchoice"><a href="#一、我的选择～-￣ω￣-～-私のchoice" class="headerlink" title="一、我的选择～=￣ω￣=～ (私のchoice)"></a>一、我的选择～=￣ω￣=～ <del>(私のchoice)</del></h2><h3 id="1-1-OS-X-下："><a href="#1-1-OS-X-下：" class="headerlink" title="1.1. OS X 下："></a>1.1. OS X 下：</h3><p>通过 alfred 打开。<br>(btw 可以将 Application 中的各个 app 的名字重新缩写过，比如将 <code>网易云音乐</code> 缩写成 <code>wyy</code>)</p>
<h3 id="1-2-windows-下："><a href="#1-2-windows-下：" class="headerlink" title="1.2. windows 下："></a>1.2. windows 下：</h3><h4 id="1-2-1-首先通过自带的运行打开。"><a href="#1-2-1-首先通过自带的运行打开。" class="headerlink" title="1.2.1. 首先通过自带的运行打开。"></a>1.2.1. 首先通过自带的运行打开。</h4><p>(就是 <code>win + r</code> 那个→_→，不过为了保持与 OS X 操作的一致性利用了 <a href="http://www.autohotkey.com/" target="_blank" rel="external">AutoHotkey</a> 将其修改为 <code>ctrl + space</code>。配置文件是 <a href="https://github.com/BuptStEve/useful-settings" target="_blank" rel="external">点我</a> 中的 steve.ahk )</p>
<h4 id="1-2-2-那么接着问题来了，打开运行后应该输入啥？"><a href="#1-2-2-那么接着问题来了，打开运行后应该输入啥？" class="headerlink" title="1.2.2. 那么接着问题来了，打开运行后应该输入啥？"></a>1.2.2. 那么接着问题来了，打开运行后应该输入啥？</h4><p>还需要2步设置：(居然比把大象放冰箱还少一步啊喂！)</p>
<ol>
<li>将 (桌面上或者其他地方的) 软件快捷方式改名缩写成2~3个字母</li>
<li>把该快捷方式 duang～ 地一声剪切到 <code>C:\Windows</code> 下，搞定收工～=￣ω￣=～</li>
</ol>
<blockquote>
<p>不过有的软件比如 <code>Github.appref-ms</code> 这种格式的就没办法通过以上方法快速打开了。这时候就又要推荐一个好用软件啦：<a href="http://www.irolan.com/" target="_blank" rel="external">Rolan</a>，将快捷方式或其他的文件/文件夹拖进去就ok。要使用的时候就通过快捷键呼叫出 Rolan 后即可打开。</p>
</blockquote>
<h2 id="二、综上"><a href="#二、综上" class="headerlink" title="二、综上"></a>二、综上</h2><p>无论何时，无论当前层叠了多少窗口…只需要:</p>
<ol>
<li>按下 <code>Ctrl + Space</code></li>
<li>输入缩写过的 2~3 个字母的软件名称</li>
<li>按下 <code>Enter</code> 确认</li>
</ol>
<p>Duang～一下就优雅地把软件打开了~\(≧▽≦)/~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、问题的由来&quot;&gt;&lt;a href=&quot;#零、问题的由来&quot; class=&quot;headerlink&quot; title=&quot;零、问题的由来&quot;&gt;&lt;/a&gt;零、问题的由来&lt;/h2&gt;&lt;p&gt;不知道大家平时是怎么打开常用软件的：&lt;/p&gt;
&lt;h3 id=&quot;1-windows-用户：&quot;&gt;&lt;a href=&quot;#1-windows-用户：&quot; class=&quot;headerlink&quot; title=&quot;1. windows 用户：&quot;&gt;&lt;/a&gt;1. windows 用户：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;从桌面上一堆杂乱的文件中找到快捷方式双击打开？&lt;/li&gt;
&lt;li&gt;从桌面上分类整理好的文件夹中找到快捷方式双击打开？&lt;/li&gt;
&lt;li&gt;同样利用 &lt;a href=&quot;http://www.stardock.com/products/fences/&quot;&gt;Fences&lt;/a&gt; 从桌面选择？&lt;/li&gt;
&lt;li&gt;利用 &lt;a href=&quot;http://www.voidtools.com/&quot;&gt;Everything&lt;/a&gt; 进行文件名搜索？&lt;/li&gt;
&lt;li&gt;win8下，win10下 blablabla…&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-OS-X-用户：&quot;&gt;&lt;a href=&quot;#2-OS-X-用户：&quot; class=&quot;headerlink&quot; title=&quot;2. OS X 用户：&quot;&gt;&lt;/a&gt;2. OS X 用户：&lt;/h3&gt;
    
    </summary>
    
      <category term="工欲善其事" scheme="https://buptsteve.github.io/blog/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B/"/>
    
    
      <category term="效率" scheme="https://buptsteve.github.io/blog/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>「0」Hello World</title>
    <link href="https://buptsteve.github.io/blog/2015/10/29/0.%20hello-world/"/>
    <id>https://buptsteve.github.io/blog/2015/10/29/0. hello-world/</id>
    <published>2015-10-29T11:04:58.000Z</published>
    <updated>2016-10-14T09:43:26.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零、Blog的由来"><a href="#零、Blog的由来" class="headerlink" title="零、Blog的由来"></a>零、Blog的由来</h2><p>作为一个学计算机的，一直想整个自己的 Blog，尤其是最近在搞前端。先是看到 <a href="http://jekyllcn.com/" target="_blank" rel="external">jekyll</a> 感觉不错，折腾了半天感觉还是不够给力。<br>最后还是选择了 <a href="https://hexo.io/" target="_blank" rel="external">hexo3</a>。</p>
<a id="more"></a>
<p>主要是这几个优点吧：</p>
<ul>
<li>免费╮(╯▽╰)╭</li>
<li>基于 Node.js</li>
<li>速度快、操作更简单、命令少，专注于写作本身</li>
<li>由于 deploy 命令，发布到 github 上生成静态站点也很简单</li>
</ul>
<p>所以整个 Blog 就是采用 <a href="https://hexo.io/" target="_blank" rel="external">hexo3</a> + <a href="https://pages.github.com/" target="_blank" rel="external">github pages</a>,主题基于 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a> 进行修改，下面就详细说说怎么搭起来吧…</p>
<h2 id="一、hexo的安装"><a href="#一、hexo的安装" class="headerlink" title="一、hexo的安装"></a>一、hexo的安装</h2><p>首先由于 hexo 是基于 Node.js 开发的，所以我们先要安装 Node.js 环境，进入<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>，一般会发现有两个版本：LTS 和 Stable。</p>
<p>这两个版本的区别在于一个是 LTS 长期支持版（也是推荐选项），另一个是拥有最新功能的稳定版（适合有新功能需求的尝鲜用户）。</p>
<p>安装完成后，在命令行运行以下命令（其中括号的意思是 install 可以缩写为 i）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) -g hexo</div></pre></td></tr></table></figure>
<p><em>npm 安装方式中 -g 的意思是全局安装。</em></p>
<h2 id="二、初体验"><a href="#二、初体验" class="headerlink" title="二、初体验~"></a>二、初体验~</h2><h3 id="2-1-生成项目"><a href="#2-1-生成项目" class="headerlink" title="2.1. 生成项目"></a>2.1. 生成项目</h3><p>找到一个合适的位置，创建我们的项目文件夹：</p>
<ul>
<li>一般的用户：自己图形界面新建了一个,然后点进去</li>
<li>命令行用户：<code>mkdir &lt;folder&gt; &amp;&amp; cd &lt;folder&gt;</code></li>
<li>hexo的用户：<code>hexo init &lt;folder&gt; &amp;&amp; cd &lt;folder&gt;</code></li>
</ul>
<h3 id="2-2-安装依赖"><a href="#2-2-安装依赖" class="headerlink" title="2.2. 安装依赖"></a>2.2. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall)</div></pre></td></tr></table></figure>
<p>npm 就会自动根据 package.json 中的配置自动进行安装</p>
<h3 id="2-3-运行预览"><a href="#2-3-运行预览" class="headerlink" title="2.3. 运行预览"></a>2.3. 运行预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g(enerate)</div><div class="line">$ hexo s(erver)</div></pre></td></tr></table></figure>
<p><em>如果这步报错一般是因为没装 hexo-server，运行以下命令安装即可：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) --save  hexo-server</div></pre></td></tr></table></figure>
<blockquote>
<p>npm 安装方式中 –save 的意思是作为项目依赖(dependencies)进行安装，可以缩写为 -S (注意大写)<br>此外还有 –save-dev 的意思是作为项目的「开发」依赖(devDependencies)进行安装，可以缩写为 -D (注意大写)<br>这两种安装方式都会将这个包的名称和版本写进 package.json 配置文件中</p>
</blockquote>
<p>最后打开浏览器输入<code>http://localhost:4000</code>就可以看到页面啦～</p>
<h2 id="三、换主题（theme）"><a href="#三、换主题（theme）" class="headerlink" title="三、换主题（theme）"></a>三、换主题（theme）</h2><p>然而只是使用默认的主题（theme）怎么会有逼格→_→，果断要整一个吊炸天的主题呀~，下面以 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a> 为例作为说明。</p>
<h3 id="3-1-下载主题"><a href="#3-1-下载主题" class="headerlink" title="3.1. 下载主题"></a>3.1. 下载主题</h3><p>首先在项目目录下（就是说有个 themes 的文件夹），执行以下命令，将主题下载到 themes 文件夹下的 indigo 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/yscoder/hexo-theme-indigo themes/indigo</div></pre></td></tr></table></figure>
<h3 id="3-2-配置使用主题"><a href="#3-2-配置使用主题" class="headerlink" title="3.2. 配置使用主题"></a>3.2. 配置使用主题</h3><p>接着修改 _config.yml（项目的配置文件，不是主题的） 将 theme 改为 indigo</p>
<h2 id="四、部署到-github-pages"><a href="#四、部署到-github-pages" class="headerlink" title="四、部署到 github pages"></a>四、部署到 github pages</h2><h3 id="4-1-安装-hexo-deployer-git"><a href="#4-1-安装-hexo-deployer-git" class="headerlink" title="4.1. 安装 hexo-deployer-git"></a>4.1. 安装 hexo-deployer-git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i(nstall) hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h3 id="4-2-关于-github-pages"><a href="#4-2-关于-github-pages" class="headerlink" title="4.2. 关于 github pages"></a>4.2. 关于 github pages</h3><h4 id="4-2-1-分类"><a href="#4-2-1-分类" class="headerlink" title="4.2.1. 分类"></a>4.2.1. 分类</h4><h5 id="1-项目站点（Project-Pages）"><a href="#1-项目站点（Project-Pages）" class="headerlink" title="1. 项目站点（Project Pages）"></a>1. 项目站点（Project Pages）</h5><p>github 会根据 gh-pages 分支下文件生成静态页面，地址是  [yourName].github.io/[projectName]。（[yourName] 是你的账户名，[projectName] 是你的项目名）</p>
<h5 id="2-个人或公司站点（User-Organization-Pages）"><a href="#2-个人或公司站点（User-Organization-Pages）" class="headerlink" title="2. 个人或公司站点（User/Organization Pages）"></a>2. 个人或公司站点（User/Organization Pages）</h5><p>首先要创建一个叫做 [yourName].github.io 的项目，接着 github 会根据 master 分支下文件生成静态页面，地址是 [yourName].github.io/。</p>
<h4 id="4-2-2-一些坑…"><a href="#4-2-2-一些坑…" class="headerlink" title="4.2.2. 一些坑…"></a>4.2.2. 一些坑…</h4><ul>
<li>有的主题中各种静态文件路径是写死的，比如好多主题中的文件引入是针对第二类页面写死的。</li>
<li>有些主题中的 CDN 资源被墙，那就需要找到这些文件手动修改地址╮(╯▽╰)╭。</li>
</ul>
<h3 id="4-3-修改-config-yml-文件"><a href="#4-3-修改-config-yml-文件" class="headerlink" title="4.3. 修改 _config.yml 文件"></a>4.3. 修改 _config.yml 文件</h3><p><a href="htjtps://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">官方文档</a>中是这么介绍的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># You can use this:</span></div><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div><div class="line"></div><div class="line"><span class="comment"># or this:</span></div><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  message: [message]</div><div class="line">  repo:</div><div class="line">    github: &lt;repository url&gt;,[branch]</div><div class="line">    gitcafe: &lt;repository url&gt;,[branch]</div></pre></td></tr></table></figure>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* repo: Repository URL</div><div class="line">* branch: Git branch <span class="keyword">to</span> deploy the <span class="keyword">static</span> site <span class="keyword">to</span></div><div class="line">* <span class="keyword">message</span>: Commit <span class="keyword">message</span>. The <span class="keyword">default</span> commit <span class="keyword">message</span> <span class="keyword">is</span> Site updated: <span class="comment">&#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;</span>&#125;.</div></pre></td></tr></table></figure>
<blockquote>
<p>根据 4.2. 所述，部署部分的填写也分为两种情况：</p>
</blockquote>
<h4 id="1-个人或公司站点"><a href="#1-个人或公司站点" class="headerlink" title="1. 个人或公司站点"></a>1. 个人或公司站点</h4><ul>
<li>repo：填写项目地址，例如 <code>git@github.com:BuptStEve/BuptStEve.github.io.git</code></li>
<li>branch：填写 <code>master</code></li>
</ul>
<h4 id="2-项目站点"><a href="#2-项目站点" class="headerlink" title="2. 项目站点"></a>2. 项目站点</h4><ul>
<li>repo：填写项目地址，例如 <code>git@github.com:BuptStEve/blog.git</code></li>
<li>branch：填写 <code>gh-pages</code></li>
<li>url：<a href="https://buptsteve.github.io/blog/">https://buptsteve.github.io/blog/</a> （注意最后的 /）</li>
<li>root：/blog/ （注意最后的 /）</li>
</ul>
<h3 id="4-4-开始部署"><a href="#4-4-开始部署" class="headerlink" title="4.4. 开始部署"></a>4.4. 开始部署</h3><p>首先生成站点文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<p>接着发布</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo d(eploy)</div></pre></td></tr></table></figure>
<p>最后打开对应地址就可以看到自己的博客啦～=￣ω￣=～。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;零、Blog的由来&quot;&gt;&lt;a href=&quot;#零、Blog的由来&quot; class=&quot;headerlink&quot; title=&quot;零、Blog的由来&quot;&gt;&lt;/a&gt;零、Blog的由来&lt;/h2&gt;&lt;p&gt;作为一个学计算机的，一直想整个自己的 Blog，尤其是最近在搞前端。先是看到 &lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll&lt;/a&gt; 感觉不错，折腾了半天感觉还是不够给力。&lt;br&gt;最后还是选择了 &lt;a href=&quot;https://hexo.io/&quot;&gt;hexo3&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="https://buptsteve.github.io/blog/categories/blog/"/>
    
    
      <category term="hexo" scheme="https://buptsteve.github.io/blog/tags/hexo/"/>
    
  </entry>
  
</feed>
