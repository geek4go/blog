<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>「5」JavaScript 面向对象深入理解 | BuptStEve&#39;s Blog | Talk is cheap show me the offer!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="JavaScript">
  <meta name="description" content="零、前言最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。
同样按照书本的顺序分为如下三部分
理解对象属性
理解并创建对象
理解继承">
<meta property="og:type" content="article">
<meta property="og:title" content="「5」JavaScript 面向对象深入理解">
<meta property="og:url" content="http://buptsteve.github.io/blog/2016/03/17/5. js-oo-chapter6/index.html">
<meta property="og:site_name" content="BuptStEve's Blog">
<meta property="og:description" content="零、前言最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。
同样按照书本的顺序分为如下三部分
理解对象属性
理解并创建对象
理解继承">
<meta property="og:updated_time" content="2016-10-14T02:56:45.393Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="「5」JavaScript 面向对象深入理解">
<meta name="twitter:description" content="零、前言最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。
同样按照书本的顺序分为如下三部分
理解对象属性
理解并创建对象
理解继承">
  
    <link rel="alternative" href="/atom.xml" title="BuptStEve&#39;s Blog" type="application/atom+xml">
  
  <meta name="summary" content="&lt;h2 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h2&gt;&lt;p&gt;最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。&lt;/p&gt;
&lt;h3 id=&quot;同样按照书本的顺序分为如下三部分&quot;&gt;&lt;a href=&quot;#同样按照书本的顺序分为如下三部分&quot; class=&quot;headerlink&quot; title=&quot;同样按照书本的顺序分为如下三部分&quot;&gt;&lt;/a&gt;同样按照书本的顺序分为如下三部分&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;理解对象属性&lt;/li&gt;
&lt;li&gt;理解并创建对象&lt;/li&gt;
&lt;li&gt;理解继承&lt;/li&gt;
&lt;/ul&gt;">
  <link rel="shortcut icon" href="/blog/favicon.ico">
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/blog/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Steve Young</h5>
        <a href="mailto:buptsteve@icloud.com" title="buptsteve@icloud.com" class="mail">buptsteve@icloud.com</a>
      </hgroup>
    </div>
  </div>
  <div class="scroll-wrap flex-col">
    <ul class="nav">
      
          <li class="waves-block waves-effect">
            <a href="/blog/"  >
              <i class="icon icon-lg icon-home"></i>
              主页
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/blog/archives"  >
              <i class="icon icon-lg icon-archives"></i>
              Archives
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/blog/tags"  >
              <i class="icon icon-lg icon-tags"></i>
              Tags
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="https://github.com/buptsteve" target="_blank" >
              <i class="icon icon-lg icon-github"></i>
              Github
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="http://weibo.com/0osteveyoungo0" target="_blank" >
              <i class="icon icon-lg icon-weibo"></i>
              Weibo
            </a>
          </li>
      
          <li class="waves-block waves-effect">
            <a href="/blog/404"  >
              <i class="icon icon-lg icon-link"></i>
              测试
            </a>
          </li>
      
    </ul>

    <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>BuptStEve&#39;s Blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

  </div>
</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">「5」JavaScript 面向对象深入理解</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">「5」JavaScript 面向对象深入理解</h1>
    <h5 class="subtitle">
        
            <time datetime="2016-03-17T08:27:58.000Z" itemprop="datePublished" class="page-time">
  2016-03-17
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/全栈/">全栈</a></li></ul>

        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <article id="post-5. js-oo-chapter6" 
  class="article article-type-post" itemprop="blogPost">
    <div class="post-meta flex-row">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JavaScript/">JavaScript</a></li></ul>

    </div>
    <div class="post-body">
        <aside class="post-widget" id="post-widget">

            
            <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

            

            
            <nav class="post-toc-wrap" id="post-toc">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#零、前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">零、前言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同样按照书本的顺序分为如下三部分"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">同样按照书本的顺序分为如下三部分</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#一、第6章-面向对象的程序设计"><span class="post-toc-number"></span> <span class="post-toc-text">一、第6章 面向对象的程序设计</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-理解对象"><span class="post-toc-number">1.</span> <span class="post-toc-text">6.1. 理解对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-1-属性类型"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">6.1.1. 属性类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-2-数据属性"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">6.1.2. 数据属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-3-访问器属性"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">6.1.3. 访问器属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-4-定义多个属性"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">6.1.4. 定义多个属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-1-5-读取属性的特性"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">6.1.5. 读取属性的特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-创建对象"><span class="post-toc-number">2.</span> <span class="post-toc-text">6.2. 创建对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-1-工厂模式"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">6.2.1. 工厂模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-2-构造函数模式"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">6.2.2. 构造函数模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#与工厂模式的不同之处"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">与工厂模式的不同之处</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#要创建新实例，必须使用-new-操作符。这个过程经历以下4个步骤："><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-构造函数当作普通函数"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">1. 构造函数当作普通函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-构造函数的问题"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">2. 构造函数的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-1-每个方法有独立的内存，造成浪费。"><span class="post-toc-number">2.2.4.1.</span> <span class="post-toc-text">2.1. 每个方法有独立的内存，造成浪费。</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-3-原型模式"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">6.2.3. 原型模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-深入理解原型对象"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">1. 深入理解原型对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#下面进行详细说明："><span class="post-toc-number">2.3.1.1.</span> <span class="post-toc-text">下面进行详细说明：</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#那么这玩意儿这么复杂有啥用咧…"><span class="post-toc-number">2.3.1.2.</span> <span class="post-toc-text">那么这玩意儿这么复杂有啥用咧…?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#a-那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？"><span class="post-toc-number">2.3.1.2.1.</span> <span class="post-toc-text">a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#b-那么问题又来了，如果就是没有咋办？"><span class="post-toc-number">2.3.1.2.2.</span> <span class="post-toc-text">b. 那么问题又来了，如果就是没有咋办？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-原型与-in-操作符"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">2. 原型与 in 操作符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-更简单的原型方法"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">3. 更简单的原型方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-原型的动态性"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">4. 原型的动态性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-原型对象的原型"><span class="post-toc-number">2.3.5.</span> <span class="post-toc-text">5. 原型对象的原型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6-原型对象的问题"><span class="post-toc-number">2.3.6.</span> <span class="post-toc-text">6. 原型对象的问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-4-组合使用构造函数模式和原型模式"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">6.2.4. 组合使用构造函数模式和原型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-5-动态原型模式"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">6.2.5. 动态原型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-6-寄生构造函数模式"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">6.2.6. 寄生构造函数模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#这个模式其实利用了构造函数的特性："><span class="post-toc-number">2.6.1.</span> <span class="post-toc-text">这个模式其实利用了构造函数的特性：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-7-稳妥构造函数模式"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">6.2.7. 稳妥构造函数模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-继承"><span class="post-toc-number">3.</span> <span class="post-toc-text">6.3. 继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-1-原型链"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">6.3.1. 原型链</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#下面再来看看一种实现原型链的基本模式"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">下面再来看看一种实现原型链的基本模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-别忘记默认的原型"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">1. 别忘记默认的原型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-确定原型和实例的关系"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">2. 确定原型和实例的关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-谨慎地定义方法"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">3. 谨慎地定义方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-原型链的问题"><span class="post-toc-number">3.1.6.</span> <span class="post-toc-text">4. 原型链的问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-2-借用构造函数"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">6.3.2. 借用构造函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-传递参数"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">1. 传递参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-借用构造函数的问题"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">2. 借用构造函数的问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-3-组合继承"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">6.3.3. 组合继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#要解决组合模式存在的问题，首先来看几个其他方式的继承。"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">要解决组合模式存在的问题，首先来看几个其他方式的继承。</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-4-原型式继承"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">6.3.4. 原型式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-5-寄生式继承"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">6.3.5. 寄生式继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-6-寄生组合式继承"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">6.3.6. 寄生组合式继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-4-小结"><span class="post-toc-number">4.</span> <span class="post-toc-text">6.4. 小结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建对象"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">创建对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对象继承"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">对象继承</span></a></li></ol></li></ol>
            </nav>
            
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h2><p>最近为了找暑假实习，正在恶补基础╮(╯▽╰)╭，仔细研读了《JavaScript 高级程序设计（第三版）》第6章 面向对象的程序设计。感觉收获颇多，在此献丑分享一点儿自己的理解。</p>
<h3 id="同样按照书本的顺序分为如下三部分"><a href="#同样按照书本的顺序分为如下三部分" class="headerlink" title="同样按照书本的顺序分为如下三部分"></a>同样按照书本的顺序分为如下三部分</h3><ul>
<li>理解对象属性</li>
<li>理解并创建对象</li>
<li>理解继承</li>
</ul>
<a id="more"></a>
<h1 id="一、第6章-面向对象的程序设计"><a href="#一、第6章-面向对象的程序设计" class="headerlink" title="一、第6章 面向对象的程序设计"></a>一、第6章 面向对象的程序设计</h1><h2 id="6-1-理解对象"><a href="#6-1-理解对象" class="headerlink" title="6.1. 理解对象"></a>6.1. 理解对象</h2><p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”简单来说，对象就是一些名值对（Key-Value），而对象的名字就是一个指针。</p>
<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1. 属性类型"></a>6.1.1. 属性类型</h3><p>ECMAScript 中有两种属性：数据属性和访问器属性。</p>
<h3 id="6-1-2-数据属性"><a href="#6-1-2-数据属性" class="headerlink" title="6.1.2. 数据属性"></a>6.1.2. 数据属性</h3><ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。</li>
<li>[[Writable]]：表示能否修改属性的值，默认为 true。</li>
<li>[[Value]]：包含这个属性的数据值，默认为 undefined。</li>
</ul>
<p>要修改以上属性，必须使用 ES5 中的 Object.defineProperty()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例1</span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span>   : <span class="string">"steve"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(person.name); <span class="comment">// steve</span></div><div class="line">person.name = <span class="string">"abc"</span>;</div><div class="line">alert(person.name); <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="comment">// 例2</span></div><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</div><div class="line">  <span class="attr">value</span>       : <span class="string">"steve"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">value</span>       : <span class="string">"steve"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>ps 在调用 Object.defineProperty() 方法时，默认值为 false(就是说其他没写的属性是 false)。</p>
<h3 id="6-1-3-访问器属性"><a href="#6-1-3-访问器属性" class="headerlink" title="6.1.3. 访问器属性"></a>6.1.3. 访问器属性</h3><p>访问器属性不包括数据值(Value)，取而代之的是一对儿 getter 和 setter 函数(非必须)。</p>
<ul>
<li>[[Configurable]]：表能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，能否把属性修改为访问器属性，默认为 true。</li>
<li>[[Enumerable]]：表能否通过 for-in 循环返回属性，以及 console.log 时是否显示，默认为 true。</li>
<li>[[Get]]：在读取属性时调用的函数，默认为 true。</li>
<li>[[Set]]：在写入属性时调用的函数，默认为 undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">  <span class="attr">_year</span>  : <span class="number">2004</span>,</div><div class="line">  <span class="attr">edition</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">      <span class="keyword">this</span>._year = newValue;</div><div class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>ps 如果只定义了两个方法的其中之一，那么另一种方式则无法使用，例如只定义了 getter，则属性不可写。</p>
<h3 id="6-1-4-定义多个属性"><a href="#6-1-4-定义多个属性" class="headerlink" title="6.1.4. 定义多个属性"></a>6.1.4. 定义多个属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">  <span class="attr">_year</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="number">2004</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">year</span>: &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._year = newValue;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h3 id="6-1-5-读取属性的特性"><a href="#6-1-5-读取属性的特性" class="headerlink" title="6.1.5. 读取属性的特性"></a>6.1.5. 读取属性的特性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</div><div class="line"></div><div class="line">alert(desc.value);        <span class="comment">// 2004</span></div><div class="line">alert(desc.configurable); <span class="comment">// false</span></div><div class="line">alert(<span class="keyword">typeof</span> desc.get);   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2. 创建对象"></a>6.2. 创建对象</h2><p>使用 Object 构造函数和字面量创建对象，会产生大量重复代码，所以以下代码重用机制应运而生。</p>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1. 工厂模式"></a>6.2.1. 工厂模式</h3><p>特点：使用函数封装特定接口创建对象的细节。简单来说就是在函数的内部创建对象，为其添加属性和方法后，将其用 return 返回，在实例化时不使用 new 操作符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="attr">name</span>: name,</div><div class="line">    <span class="attr">age</span> : age,</div><div class="line">    <span class="attr">job</span> : job,</div><div class="line"></div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"young"</span>, <span class="number">25</span>, <span class="string">"fs"</span>);</div></pre></td></tr></table></figure>
<p>问题：没有解决对象识别的问题（即怎样知道一个对象的类型），重复构造相同的方法造成内存浪费，也无法进行继承复用。</p>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2. 构造函数模式"></a>6.2.2. 构造函数模式</h3><p>特点：在构造函数中使用 this 对象在运行时基于函数的执行环境动态绑定，使用 new 操作符实例化。</p>
<p>ps 通过 new 关键字方式调用的函数都被认为是构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age  = age;</div><div class="line">  <span class="keyword">this</span>.job  = job;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"young"</span>, <span class="number">25</span>, <span class="string">"fs"</span>);</div><div class="line"></div><div class="line">alert(person1.constructor === Person); <span class="comment">// true</span></div><div class="line">alert(person2.constructor === Person); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="与工厂模式的不同之处"><a href="#与工厂模式的不同之处" class="headerlink" title="与工厂模式的不同之处"></a>与工厂模式的不同之处</h4><ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋值给了 this 对象</li>
<li>没有 return 语句</li>
</ul>
<h4 id="要创建新实例，必须使用-new-操作符。这个过程经历以下4个步骤："><a href="#要创建新实例，必须使用-new-操作符。这个过程经历以下4个步骤：" class="headerlink" title="要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤："></a>要创建新实例，必须使用 new 操作符。这个过程经历以下4个步骤：</h4><ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（this 指向新对象）</li>
<li>执行构造函数中的代码（为之添加属性）</li>
<li>返回新对象</li>
</ul>
<p>这种方式胜过工厂模式的地方就在于：可以将实例标识为一种特定的类型。</p>
<h4 id="1-构造函数当作普通函数"><a href="#1-构造函数当作普通函数" class="headerlink" title="1. 构造函数当作普通函数"></a>1. 构造函数当作普通函数</h4><p>既然实例化需要使用 new 操作符，万一不使用又会怎么样的？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line">person.sayName();          <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="comment">// 当作普通函数使用</span></div><div class="line">Person(<span class="string">"young"</span>, <span class="number">24</span>, <span class="string">"fe"</span>); <span class="comment">// 添加到 window 对象中</span></div><div class="line"><span class="built_in">window</span>.sayName();          <span class="comment">// young</span></div><div class="line"></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"sasuke"</span>, <span class="number">24</span>, <span class="string">"fe"</span>);</div><div class="line">o.sayName();               <span class="comment">// sasuke</span></div></pre></td></tr></table></figure>
<h4 id="2-构造函数的问题"><a href="#2-构造函数的问题" class="headerlink" title="2. 构造函数的问题"></a>2. 构造函数的问题</h4><h5 id="2-1-每个方法有独立的内存，造成浪费。"><a href="#2-1-每个方法有独立的内存，造成浪费。" class="headerlink" title="2.1. 每个方法有独立的内存，造成浪费。"></a>2.1. 每个方法有独立的内存，造成浪费。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 虽然可以把函数定义转移到构造函数外</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age  = age;</div><div class="line">  <span class="keyword">this</span>.job  = job;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.Name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这样将其设置成了全局函数，但是新问题就是：全局函数却只能被某个对象调用，并且如果需要定义很多方法，就需要定义很多全局函数，也就是说毫无封装性可言。</p>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3. 原型模式"></a>6.2.3. 原型模式</h3><p>首先我们要知道每一个函数都有一个属性叫做 prototype，这个属性是一个指针，指向函数的原型对象。</p>
<blockquote>
<p>原型对象的用途：包含可以由特定类型的「所有实例」[共享]的属性和方法。</p>
</blockquote>
<p>换句话来说就是：所有对象实例可以一起通过这个 prototype 来共享属性和方法～=￣ω￣=～。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 属性</span></div><div class="line">Person.prototype.name = <span class="string">"steve"</span>;</div><div class="line">Person.prototype.age  = <span class="number">24</span>;</div><div class="line">Person.prototype.job  = <span class="string">"Web Developer"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 方法</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">// steve</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">// steve</span></div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true 共享同一个方法</span></div></pre></td></tr></table></figure>
<h4 id="1-深入理解原型对象"><a href="#1-深入理解原型对象" class="headerlink" title="1. 深入理解原型对象"></a>1. 深入理解原型对象</h4><ul>
<li>只要是函数，都有一个 prototype 指针，指向原型对象。</li>
<li>而原型对象默认会自动获得一个 constructor 指针，指向上一条中的函数。（你指我？我也指你→_→）</li>
<li>调用构造函数创建一个新实例后，实例内部也会获得一个 [[prototype]] 指针（ES5 中这么叫），指向原型对象（不是创造它的构造函数！）。</li>
</ul>
<h5 id="下面进行详细说明："><a href="#下面进行详细说明：" class="headerlink" title="下面进行详细说明："></a>下面进行详细说明：</h5><ul>
<li>第一条很好理解，当作大自然的规律来记就好啦，你否认也没用╮(╯▽╰)╭</li>
<li>第二条就是说原型对象与一般的对象最大的不同就是这个 constructor 指针，所以在重写构造函数的 prototype 时，要想与之前的原型对象保持一致，最好也加上这个 constructor 指针（显得专业嘛～=￣ω￣=～）。</li>
<li>第三条，其实在 Firefox、Safari 和 Chrome 中，[[prototype]] 就是 <code>__proto__</code> 指针。</li>
<li>ps 无论有没有 <code>__proto__</code> 指针，我们都可以通过 isPrototypeOf() 方法来确定对象之间是否存在原型关系。（<code>Person.prototype.isPrototypeOf(person1) // true</code>）</li>
<li>pps ES5 中增加了一个新方法 Object.getPrototypeOf() （<code>Object.getPrototypeOf(person1) === Person.prototype // true</code>）</li>
</ul>
<p>总结一下就是：构造函数有指向原型对象的指针(prototype)，原型对象也有指向构造函数的指针(constructor)，实例同样也有指向原型对象的指针([[prototype]])</p>
<hr>
<h5 id="那么这玩意儿这么复杂有啥用咧…"><a href="#那么这玩意儿这么复杂有啥用咧…" class="headerlink" title="那么这玩意儿这么复杂有啥用咧…?"></a>那么这玩意儿这么复杂有啥用咧…?</h5><p>简单举个栗子，上文中 6.2.3.原型模式一节中的两个实例(person1,person2)并不包含任何属性和方法，但是我们仍然可以调用 person1.sayName() 方法，这就是通过查找对象属性的过程实现的。</p>
<p>还有我们经常使用的各种数组方法(slice,splice,sort…)，同样也是定义在 Array.prototype 这个对象上的。</p>
<p>其实每当读取某个对象的某个属性时，都会执行一次搜索，目标就是给定的属性名。首先当然先搜索对象实例自身，如果没找到再继续搜索 [[prototype]] 指针指向的原型对象，如果找不到再向上查找…</p>
<p>所以实例的属性可以“屏蔽“原型链上的同名属性。（通过 delete 可以删除实力属性，消除屏蔽）</p>
<h6 id="a-那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？"><a href="#a-那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？" class="headerlink" title="a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？"></a>a. 那么问题来了，怎么判断一个属性究竟是实例的还是原型链上的？</h6><p>很简单，使用 hasOwnProperty() 犯法。</p>
<h6 id="b-那么问题又来了，如果就是没有咋办？"><a href="#b-那么问题又来了，如果就是没有咋办？" class="headerlink" title="b. 那么问题又来了，如果就是没有咋办？"></a>b. 那么问题又来了，如果就是没有咋办？</h6><p>还记得 JavaScript 中的数据类型么，不平凡的那个引用类型 Object。我们使用的 Array、Function、Date、RegExp… 都是由 Object 派生而成。换句话说他们的原型对象都指向了 Object.prototype。最后 Object.prototype 又指向了 null。</p>
<p>所以如果寻找属性直到 Object.prototype 中都没有，从而找到 null。那么 JS 引擎就会抛出 undefined。</p>
<h4 id="2-原型与-in-操作符"><a href="#2-原型与-in-操作符" class="headerlink" title="2. 原型与 in 操作符"></a>2. 原型与 in 操作符</h4><p>in 操作符用来判断对象能否访问给定属性（前提是 enumerable 为 true），有两种方法使用 in 操作符：</p>
<ul>
<li>单独使用</li>
<li>在 for-in 循环中使用</li>
</ul>
<p>但由于 in 操作符不区分实例和原型链，所以日常使用中需要结合 hasOwnProperty() 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>) </span>&#123;</div><div class="line">  <span class="comment">// 判断是否是原型链上的属性</span></div><div class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外要取得对象上所有可枚举的实例属性，可以用 ES5 中的 Object.keys() 方法（返回数组）。</p>
<p>当然如果要取得所有实例属性，无论是否可枚举，可以用 Object.getOwnPropertyNames() 方法。</p>
<h4 id="3-更简单的原型方法"><a href="#3-更简单的原型方法" class="headerlink" title="3. 更简单的原型方法"></a>3. 更简单的原型方法</h4><p>日常使用中，每当要为原型对象添加一个属性或方法，都要敲一遍 Person.prototype，这样太不优雅了…</p>
<p>所以一般采用对象字面量将属性和方法都包起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person, <span class="comment">// 别忘了之前说过的 constructor 指针。</span></div><div class="line"></div><div class="line">  name: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span> : <span class="string">"Web Developer"</span>,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，如果你是个完美主义者，还有一点要注意：原生 constructor 属性是不可枚举的，所以可以用 Object.defineProperty() 将其改写回来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span> : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span> : <span class="string">"Web Developer"</span>,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">  <span class="attr">enumerable</span>  : <span class="literal">false</span>, <span class="comment">// 默认值，其实可以不写</span></div><div class="line">  writable    : <span class="literal">true</span>,</div><div class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">value</span>       : Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="4-原型的动态性"><a href="#4-原型的动态性" class="headerlink" title="4. 原型的动态性"></a>4. 原型的动态性</h4><p>略，只要你了概（解）了指针是咩（什么）就大丈夫（没问题）。</p>
<h4 id="5-原型对象的原型"><a href="#5-原型对象的原型" class="headerlink" title="5. 原型对象的原型"></a>5. 原型对象的原型</h4><p>略，大概内容就是说了下俺们原生的对象和乃们“野生”对象一样也是有原型的╮(╯▽╰)╭。</p>
<h4 id="6-原型对象的问题"><a href="#6-原型对象的问题" class="headerlink" title="6. 原型对象的问题"></a>6. 原型对象的问题</h4><p>问题其实是来自于自身共享的本性。</p>
<p>例如，包含引用类型的属性。由于引用类型实际上就是指针，所以所有实例操作的都是同一个引用对象，见下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line"></div><div class="line">  <span class="attr">name</span>   : <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">age</span>    : <span class="number">24</span>,</div><div class="line">  <span class="attr">job</span>    : <span class="string">"Web Developer"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>],</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4. 组合使用构造函数模式和原型模式"></a>6.2.4. 组合使用构造函数模式和原型模式</h3><p>经过上文的讨论我们知道：</p>
<ul>
<li>构造函数模式可以为每个实例生成单独的属性，但无法共享。</li>
<li>原型模式可以共享，但无法为实例生成单独的属性。</li>
</ul>
<p>既然构造函数模式和原型模式的优缺点正好互补，那么为何不将两者结合，发挥各自的长处？</p>
<p>组合模式就是基于这一朴素的思想：</p>
<ul>
<li>构造函数用于定义实例属性</li>
<li>原型模式用于定义共享的属性和方法</li>
</ul>
<p>这样一来，每个实例都有自己的实例属性副本，但同时又共享着原型对象中的方法和属性，最大限度地节省了内存，还支持向构造函数中传递参数，可谓博采众长也～=￣ω￣=～。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name    = name;</div><div class="line">  <span class="keyword">this</span>.age     = age;</div><div class="line">  <span class="keyword">this</span>.job     = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"shirley"</span>, <span class="string">"jame"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line"></div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"Web Developer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"nicholas"</span>, <span class="number">29</span>, <span class="string">"Soft Engineer"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-5-动态原型模式"><a href="#6-2-5-动态原型模式" class="headerlink" title="6.2.5. 动态原型模式"></a>6.2.5. 动态原型模式</h3><p>本质其实还是组合模式，只不过把原型对象中共享的属性和方法，也封装在构造函数里…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name    = name;</div><div class="line">  <span class="keyword">this</span>.age     = age;</div><div class="line">  <span class="keyword">this</span>.job     = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"shirley"</span>, <span class="string">"jame"</span>];</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">    <span class="comment">// 不能使用对象字面量 Person.prototype = &#123;...&#125;;</span></div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"Web Developer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"nicholas"</span>, <span class="number">29</span>, <span class="string">"Soft Engineer"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">// ["shirley", "jame","van"]</span></div><div class="line">alert(person2.friends); <span class="comment">// ["shirley", "jame"]</span></div><div class="line">alert(person1.friends === person2.friends); <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6. 寄生构造函数模式"></a>6.2.6. 寄生构造函数模式</h3><p>首先一般来说，组合模式已经足够应付日常需求，所以这个模式是为了应对特殊需求：例如我们需要创建一个具有额外方法的特殊数组，但是不能直接修改 Array 的构造函数（见下例）。</p>
<p>具体形式上除了使用 new 操作符创建实例以外，和工厂模式一毛（模）一样（同样的问题）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 内部创建一个新数组</span></div><div class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">  <span class="comment">// 添加值</span></div><div class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 添加方法</span></div><div class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> values;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>); <span class="comment">// 注意：使用 new 创建实例</span></div><div class="line">alert(colors.toPipedString()); <span class="comment">// red|blue|green</span></div></pre></td></tr></table></figure>
<h4 id="这个模式其实利用了构造函数的特性："><a href="#这个模式其实利用了构造函数的特性：" class="headerlink" title="这个模式其实利用了构造函数的特性："></a>这个模式其实利用了构造函数的特性：</h4><ul>
<li>如果被调用的函数没有显式的 return 表达式，则隐式地会返回 this 对象 - 也就是新创建的隐式对象。</li>
<li>显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo().constructor === <span class="built_in">Number</span> <span class="comment">// false，返回新创建的隐式对象</span></div><div class="line"><span class="keyword">new</span> Bar().constructor === <span class="built_in">Number</span> <span class="comment">// true，返回 Number 对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.value = <span class="number">2</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test()); <span class="comment">// &#123;foo: 1&#125;，返回的对象，this 对象被销毁了，value 丢失了</span></div></pre></td></tr></table></figure>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7. 稳妥构造函数模式"></a>6.2.7. 稳妥构造函数模式</h3><p>首先要介绍 Douglas Crockford 发明的「稳妥对象」(durable objects) 这个概念：没有公共属性，而且方法也不引用 this 的对象。</p>
<p>主要用在需要安全的环境（禁止 this 和 new），或者在防止数据被其他程序（如 Mashup）改动时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="comment">//创建要返回的对象</span></div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">  <span class="comment">//可以在这里定义私有变量和函数</span></div><div class="line"></div><div class="line">  <span class="comment">//添加方法</span></div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); <span class="comment">// 注意：这里没有使用 this，因此我的理解是相当于闭包，保存住了外部 Person 的 AO（活动对象）</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//返回对象</span></div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = Person(<span class="string">"steve"</span>, <span class="number">24</span>, <span class="string">"web developer"</span>);</div><div class="line">person.sayName(); <span class="comment">//"steve"</span></div></pre></td></tr></table></figure>
<p>这里变量 person 中保存的就是一个稳妥对象，因为除了调用 sayName() 方法以外，没有别的方法可以访问内部的数据。</p>
<p>即使有其他代码会给这个对象添加方法或数据，也无法访问传入到构造函数中的原始数据。</p>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3. 继承"></a>6.3. 继承</h2><p>许多面向对象的编程语言都支持两种继承方式：</p>
<ul>
<li>接口继承：只继承方法签名</li>
<li>实现继承：继承实际的方法</li>
</ul>
<p>在 ECMAScript 中由于函数没有签名，所以无法实现接口继承，只支持实现继承，而这正是依靠「原型链」来实现的。</p>
<h3 id="6-3-1-原型链"><a href="#6-3-1-原型链" class="headerlink" title="6.3.1. 原型链"></a>6.3.1. 原型链</h3><p>既然这继承的关键在于「原型链」，我们就先来了概（解）下原型链的概念究竟是神马…</p>
<blockquote>
<p>基本思想：利用 prototype（原型对象），让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p>简单回顾一下之前讨论过的关于，构造函数、原型对象和实例的关系：</p>
<ul>
<li>每个构造函数都有一个指向自己原型对象的 prototype 指针。</li>
<li>原型对象又都包含一个指向构造函数的 constructor 指针。</li>
<li>实例都包含一个指向原型对象的 [[prototype]] 内部指针（<code>__proto__</code>）。</li>
</ul>
<h4 id="假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？"><a href="#假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？" class="headerlink" title="假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？"></a>假如我们让「原型对象」等于另一个类型的「实例」，结果会是怎样的呢？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> foo(); <span class="comment">// a 是父类 foo 的实例</span></div><div class="line">bar.prototype = a; <span class="comment">// 「原型对象 bar.prototype」等于另一个类型的「实例 a」</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> bar(); <span class="comment">// b 是子类 bar 的实例</span></div></pre></td></tr></table></figure>
<p>简单分析一下以上代码：</p>
<ul>
<li>「1」a 作为 foo 的实例，a 的内部指针 [[prototype]] 指向原型对象 foo.prototype。</li>
<li>「2」bar.prototype 被赋值为 a，所以相当于 bar.prototype 有内部指针 [[prototype]] 指向原型对象 foo.prototype。</li>
<li>「3」b 作为 bar 的实例，b 的内部指针 [[prototype]] 指向原型对象 bar.prototype。</li>
<li>「4」综上，这样便形成了一条：<code>b -&gt; bar.prototype -&gt; foo.prototype</code> 的原型链。</li>
<li>「5」假如另一个原型又是另一个类型的实例，那么上述关系仍然成立，如此层层递进，可以生成更长的原型链。</li>
</ul>
<p>以上就是原型链的基本概念…╮(╯_╰)╭</p>
<h4 id="下面再来看看一种实现原型链的基本模式"><a href="#下面再来看看一种实现原型链的基本模式" class="headerlink" title="下面再来看看一种实现原型链的基本模式"></a>下面再来看看一种实现原型链的基本模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 注意：使用 new 生成父类实例，重写了原型对象</span></div><div class="line"></div><div class="line"><span class="comment">// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）</span></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">// true，成功继承父类原型对象上的方法</span></div><div class="line">alert(instance.constructor);     <span class="comment">// SuperType，因为访问的是 Super.prototype 中的 constructor</span></div></pre></td></tr></table></figure>
<h4 id="1-别忘记默认的原型"><a href="#1-别忘记默认的原型" class="headerlink" title="1. 别忘记默认的原型"></a>1. 别忘记默认的原型</h4><p>其实，所有的引用类型都默认继承自 Object，而这个继承也是通过原型链实现的。所以所有自定义类型都能够使用 toString()、valueOf() 等方法。</p>
<h4 id="2-确定原型和实例的关系"><a href="#2-确定原型和实例的关系" class="headerlink" title="2. 确定原型和实例的关系"></a>2. 确定原型和实例的关系</h4><p>有两种方法确定原型和实例的关系：</p>
<ul>
<li>instanceof 操作符</li>
<li>isPrototypeof() 方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">// true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">// true</span></div><div class="line">alert(instance <span class="keyword">instanceof</span> SubType);   <span class="comment">// true</span></div><div class="line"></div><div class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeof(instance));    <span class="comment">// true</span></div><div class="line">alert(SuperType.prototype.isPrototypeof(instance)); <span class="comment">// true</span></div><div class="line">alert(SubType.prototype.isPrototypeof(instance));   <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h4 id="3-谨慎地定义方法"><a href="#3-谨慎地定义方法" class="headerlink" title="3. 谨慎地定义方法"></a>3. 谨慎地定义方法</h4><p>子类型有时候需要覆盖超类型的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后，这点很好理解。</p>
<p>还要注意以下这种使用对象字面量创建原型方法的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// blabla...</span></div><div class="line"></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 注意：使用 new 生成父类实例，重写了原型对象</span></div><div class="line"></div><div class="line"><span class="comment">// 隐式地创建了一个新对象，改写了 SubType.prototype 的指针指向</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">  <span class="attr">getSubValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">someOtherMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="4-原型链的问题"><a href="#4-原型链的问题" class="headerlink" title="4. 原型链的问题"></a>4. 原型链的问题</h4><ul>
<li>引用类型属性的问题：相当于将父类属性添加到子类原型对象上形成共享。</li>
<li>创建子类实例时，不能向超类型的构造函数中传递参数：准确的说是无法在不影响所有对象实例的情况下，给父类的构造函数传递参数。</li>
</ul>
<h3 id="6-3-2-借用构造函数"><a href="#6-3-2-借用构造函数" class="headerlink" title="6.3.2. 借用构造函数"></a>6.3.2. 借用构造函数</h3><p>在解决原型链以上问题的过程中，产生了一种叫做「借用构造函数（伪造对象、经典继承）」的技术。</p>
<p>基本思想是：在子类构造函数内部调用父类构造函数，主要通过 call() 和 apply() 方法实现。</p>
<h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p>相对于原型链而言，借用构造函数最大的优势就是解决了传递参数的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'steve'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = <span class="number">24</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name); <span class="comment">// steve</span></div><div class="line">alert(instance.age);  <span class="comment">// 24</span></div></pre></td></tr></table></figure>
<h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><p>源自于构造函数的问题：方法都在构造函数中定义，无法函数复用，子类方法也无法使用父类原型对象中的方法。</p>
<h3 id="6-3-3-组合继承"><a href="#6-3-3-组合继承" class="headerlink" title="6.3.3. 组合继承"></a>6.3.3. 组合继承</h3><p>顾名思义，就是将原型链和借用构造函数结合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 借用构造函数继承属性</span></div><div class="line">  SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用原型链继承了方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div></pre></td></tr></table></figure>
<p>虽然看起来结合了两者的优点，既能够传递参数，又能实现原型链继承，但是应该注意到 <code>SubType.prototype = new SuperType();</code> 一句。</p>
<p>我们的预期只是子类 SubType 拥有父类的属性，即 <code>SuperType.call(this, name);</code> 的工作。</p>
<p>但是 SubType.prototype 上也拥有了一个值为 undefined 的 name 属性和 colors 数组。这不是我们的本意，这就是直接使用 new 操作符将父类实例赋值给子类原型对象的副作用╮(╯▽╰)╭。</p>
<h4 id="要解决组合模式存在的问题，首先来看几个其他方式的继承。"><a href="#要解决组合模式存在的问题，首先来看几个其他方式的继承。" class="headerlink" title="要解决组合模式存在的问题，首先来看几个其他方式的继承。"></a>要解决组合模式存在的问题，首先来看几个其他方式的继承。</h4><h3 id="6-3-4-原型式继承"><a href="#6-3-4-原型式继承" class="headerlink" title="6.3.4. 原型式继承"></a>6.3.4. 原型式继承</h3><p>由 Douglas Crockford（又是你→_→）在2006年的一篇文章中介绍，基本思想是：基于已有对象，借助原型创建新对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">  F.prototype = o;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即先创建一个临时性的构造函数 F，然后将传入的对象 o 作为这个构造函数的原型 <code>F.prototype</code>，最后返回这个临时类型的一个新实例 <code>new F()</code>。从本质上将就是对于传入的对象 o 进行了一次浅复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"young"</span>;</div><div class="line">anotherPerson.friends.push(<span class="string">"sasuke"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"nicholas"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"jobs"</span>);</div><div class="line"></div><div class="line">alert(person.friends); <span class="comment">// shirley,jame,sasuke,jobs，friends 被共享了</span></div></pre></td></tr></table></figure>
<p>ES5 中新增了 Object.create() 方法规范化了原型式继承。可以接收两个参数，第一个参数就是要继承的对象，第二个对象是可选的一个为新对象定义额外属性的对象。其实只传一个参数时，两个方法行为相同。</p>
<p>第二个参数与 Object.defineProperties() 方法的第二个参数格式相同（覆盖同名属性），见下例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">  <span class="attr">name</span>: &#123;</div><div class="line">    <span class="attr">value</span>: <span class="string">"greg"</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">// greg</span></div></pre></td></tr></table></figure>
<h3 id="6-3-5-寄生式继承"><a href="#6-3-5-寄生式继承" class="headerlink" title="6.3.5. 寄生式继承"></a>6.3.5. 寄生式继承</h3><p>基本思路类似用工厂模式包装原型式继承：创建一个仅用于封装继承过程的函数，在内部以某种方式来增强对象，最后返回该对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"steve"</span>,</div><div class="line">  <span class="attr">friends</span>: [<span class="string">"shirley"</span>, <span class="string">"jame"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> clone = object(original); <span class="comment">// 原型式继承对象 original</span></div><div class="line"></div><div class="line">  <span class="comment">// 增强对象</span></div><div class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi"</span>);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// Hi</span></div></pre></td></tr></table></figure>
<h3 id="6-3-6-寄生组合式继承"><a href="#6-3-6-寄生组合式继承" class="headerlink" title="6.3.6. 寄生组合式继承"></a>6.3.6. 寄生组合式继承</h3><p>首先实力吹一波：作为压轴出场的终极继承方式，几乎是最理想的继承范式。</p>
<p>前面在介绍组合继承的时候说到了主要问题出在 <code>SubType.prototype = new SuperType();</code> 这句。它将父类构造函数中的属性也添加到了子类原型对象中，而这不符合我们的期望。</p>
<blockquote>
<p>其实让我们回到需求本身：我们希望子类的原型对象能够指向父类的原型对象，实现原型链继承。</p>
</blockquote>
<p>那么想一想 6.3.4. 原型式继承，我们让子类原型式继承父类的原型对象不就完美了么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 借用构造函数，继承父类属性（解决了传参）</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = <span class="built_in">Object</span>.create(SuperType.prototype, &#123;</div><div class="line">  <span class="attr">constructor</span>: &#123;</div><div class="line">    <span class="attr">value</span>       : SubType, <span class="comment">// 指回子类构造函数</span></div><div class="line">    enumerable  : <span class="literal">false</span>,   <span class="comment">// 默认值，其实可以不写</span></div><div class="line">    writable    : <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 必须后添加方法（不然方法就加到之前的对象上去了_(:зゝ∠)_，要理解指针）</span></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4. 小结"></a>6.4. 小结</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li>工厂模式：简单地在函数内部创建对象，添加属性和方法，然后返回对象。</li>
<li>构造函数模式：在函数内部使用 this 添加属性和方法，可以创建自定义引用类型，可以使用 new 操作符创建实例。但是无法实现函数复用，造成内存浪费等问题。</li>
<li>原型模式：使用构造函数的 prototype 属性来指定共享的属性和方法，本质上就是为了共享而生。</li>
<li>组合模式：结合构造函数和原型模式的优点。</li>
</ul>
<h3 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h3><ul>
<li>原型链：将父类的实例赋值给子类构造函数的原型对象。但这样会有两个问题：传参和子类原型上有多余的父类构造函数中的属性。</li>
<li>借用构造函数：为了解决传参问题，采用在子类中调用父类构造函数的方法。</li>
<li>原型式：可以在不必预先定义构造函数的情况下实现继承，本质是执行对给定对象的浅复制。</li>
<li>寄生组合式：巧妙利用原型式继承解决原型链中的第二个问题，是基于类型继承的最好方式。</li>
</ul>


            
            
            <blockquote>
                <p>
                本文地址：
                <a href="http://buptsteve.github.io/blog/blog/2016/03/17/5. js-oo-chapter6/" target="_blank" rel="external">http://buptsteve.github.io/blog/blog/2016/03/17/5. js-oo-chapter6/</a>
                </p>
                <footer><cite><a href="http://buptsteve.github.io/blog">@BuptStEve's Blog</a></cite></footer>
            </blockquote>
            </div>
            
<nav class="post-nav">
  
    <div class="waves-block waves-effect prev fl">
      <a href="/blog/2016/03/23/6. js-function-chapter7/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">「6」JavaScript 函数表达式学习笔记</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/blog/2016/03/16/4. byrs-news notes 1/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">「4」Byrs-News 建站笔记（一）</h4>
      </a>
    </div>
  
</nav>


            
            
<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="5. js-oo-chapter6" data-title="「5」JavaScript 面向对象深入理解" data-url="http://buptsteve.github.io/blog/2016/03/17/5. js-oo-chapter6/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"buptsteve"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





        </div>
    </div>
</article>
    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "「5」JavaScript 面向对象深入理解",
    pic: "/blog/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://buptsteve.github.io/blog/2016/03/17/5. js-oo-chapter6/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>




<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/blog/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/blog/js/search.js"></script>







<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-85691829-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



</body>
</html>
